<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>info-collection</title>
      <link href="/2020/09/04/info-collection/"/>
      <url>/2020/09/04/info-collection/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>江湖上流传着这样一句话，渗透测试的本质就是信息收集，一次成功的渗入，百分之80的时间都花在了信息收集上，信息收集真的这么重要么？那么具体要收集什么信息呢？</p><p><img src="/2020/09/04/info-collection/1599192497061.png" alt="1599192497061"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>m01ly-wiki</title>
      <link href="/2020/09/03/m01ly-wiki/"/>
      <url>/2020/09/03/m01ly-wiki/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TLS-安全配置"><a href="#TLS-安全配置" class="headerlink" title="TLS 安全配置"></a>TLS 安全配置</h1><h2 id="DHparam"><a href="#DHparam" class="headerlink" title="DHparam"></a>DHparam</h2><h3 id="Diffie-Hellman-group-smaller-than-2048-bits-漏洞"><a href="#Diffie-Hellman-group-smaller-than-2048-bits-漏洞" class="headerlink" title="Diffie-Hellman group smaller than 2048 bits 漏洞"></a>Diffie-Hellman group smaller than 2048 bits 漏洞</h3><p><strong>漏洞描述：</strong></p><ol><li>Diffie-Hellman group smaller than 2048 bits：</li></ol><p>TLS服务器使用Diffie-Hellman组，质数模长度小于2048位。目前的估计是，一个学术团队可以打破768位素数，而一个国家级团队可以打破1024位素数。</p><ol start="2"><li>TLS/SSL Server Is Using Commonly Used Prime Numbers </li></ol><p>在Diffie-Hellman密钥交换期间，服务器使用一个公共素数或默认质数作为参数。这使得安全会话容易受到预计算攻击。攻击者可以花费大量时间为特定质数生成查找/彩虹表。然后，可以使用此查找表获取握手的共享机密并解密会话。</p><p><strong>漏洞分析：</strong></p><p>漏洞1，只需要重新生成2048位DH参数即可。</p><p>漏洞2，因为用了已知的素数，会导致爆破后破解出密钥，因此只需要升级到2048位参数，在2048位DH组下进行这种攻击的可行性被评估为不确定且未经证实。</p><p><strong>漏洞解决方法：</strong>重新生成2048位dhparams。nginx配置如下，其他容器详见<a href="https://weakdh.org/sysadmin.html">https://weakdh.org/sysadmin.html</a> 。</p><p>1 利用openssl生成2048bit dhparams.pem命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">openssl dhparam -out dhparams.pem 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dh协议文件生成速度随长度增长而急剧增长，使用随机数种子可以加快生成速度，如下所示</p><pre class="line-numbers language-bash"><code class="language-bash">openssl dhparam -rand rand.seed -out dhparams.pem 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 nginx配置 （nginx.conf文件）：</p><pre class="line-numbers language-bash"><code class="language-bash">ssl_dhparam dhparams.pem的路径<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参考：</strong></p><p><a href="https://weakdh.org/sysadmin.html">https://weakdh.org/sysadmin.html</a>   官方TLS部署Diffie-Hellman指南，包括apache,iis环境下的配置</p><p><a href="https://gist.github.com/fotock/9cf9afc2fd0f813828992ebc4fdaad6f">https://gist.github.com/fotock/9cf9afc2fd0f813828992ebc4fdaad6f</a>  TLS 的nginx安全配置</p><p><a href="https://kb.fortinet.com/kb/documentLink.do?externalID=FD43985">https://kb.fortinet.com/kb/documentLink.do?externalID=FD43985</a>   <a href="https://www.rapid7.com/db/vulnerabilities/tls-dh-primes">https://www.rapid7.com/db/vulnerabilities/tls-dh-primes</a> 解决方法</p><p><a href="https://www.openssl.org/docs/man1.1.0/man1/dhparam.html">https://www.openssl.org/docs/man1.1.0/man1/dhparam.html</a>  openssl生成 dhparam具体用法</p><p><a href="https://weakdh.org/logjam.html">https://weakdh.org/logjam.html</a>   <a href="https://weakdh.org/">https://weakdh.org/</a> 相关DH的攻击</p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7103791.html">https://www.cnblogs.com/f-ck-need-u/p/7103791.html</a>  加快生成速度</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS攻击之心脏滴血</title>
      <link href="/2020/09/03/htps-attack-heartbleed/"/>
      <url>/2020/09/03/htps-attack-heartbleed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-心脏滴血介绍"><a href="#一-心脏滴血介绍" class="headerlink" title="一 心脏滴血介绍"></a>一 心脏滴血介绍</h1><p> <strong>心脏滴血漏洞(CVE-2014-0160)</strong> 是一个出现在加密程序库OpenSSL的安全漏洞，openssl是用于实现TLS协议的库。</p><p><strong>受影响的版本：</strong> OpenSSL1.0.1、1.0.1a 、1.0.1b 、1.0.1c 、1.0.1d 、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等版本 </p><p><strong>影响范围</strong>：只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。 因为缺陷在于OpenSSL的实现，而不是SSL/TLS协议本身，所以除了OpenSSL之外的其他TLS实现方式，如GnuTLS、Mozilla的网络安全服务（NSS）和Windows平台的TLS实现都不受影响。</p><p><strong>漏洞原理：</strong>在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查，因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多 。</p><h1 id="二-漏洞原理分析"><a href="#二-漏洞原理分析" class="headerlink" title="二 漏洞原理分析"></a>二 漏洞原理分析</h1><h2 id="2-1-心跳机制"><a href="#2-1-心跳机制" class="headerlink" title="2.1 心跳机制"></a>2.1 心跳机制</h2><p> TLS / SSL协议的一个重要组成部分被称为“心跳”。从本质上讲，<strong>心跳就是两台电脑互相通信从而让对方知道它们仍然相连，即使用户没有下载或上传任何东西。</strong></p><p><strong>（1） 正常心跳检测</strong></p><p>每过一段时间，浏览器会发送一个加密的数据到服务器端，这被称为心跳请求，至关重要的是，心跳请求里包含自己的长度信息。例如下图中，</p><p><strong>客户端：</strong>内容为abcdefghij,，自己的长度为10字节 。</p><p><strong>服务器</strong>：收到消息时，会分配一个内存缓冲区（一个物理内存区域用以存储信息），该区域的存储空间和心跳请求信号里的长度一致，即10字节。接下来，它会存储请求信号的加密数据到内存缓冲区，然后读取数据并将其发送回你的浏览器，来证明连接仍然存在。</p><p><img src="/2020/09/03/htps-attack-heartbleed/1599116465905.png" alt="1599116465905"></p><p><strong>（2） 心脏滴血</strong></p><p> 心脏出血漏洞的出现是因为，**OpenSSL的心跳功能缺少了一个至关重要的安全维护手段：计算机接受心跳请求时从不检查该请求和它声称的内容是否一致，及从不检查所请求的数据长度是否和声称的数据长度一致，导致响应方返回额外长度的数据，具体如下图所示：</p><p><strong>客户端心跳请求：</strong>abcdefghij,，心跳长度为10字节 。</p><p><strong>服务器端：</strong>接收心跳数据后，没有对心跳请求数据长度和声称 的10字节长度进行检查，直接分配200字节缓存区，存储心跳数据。返回数据时，从缓冲区读取200字节的数据返回给客户端。这时候缓冲区可能会存在密钥，用户名，密码等隐私信息（可想而知payload需要精心构造以读取有用的隐私信息，这里仅仅简单描述攻击原理）。</p><p><img src="/2020/09/03/htps-attack-heartbleed/1599117066503.png" alt="1599117066503"></p><h2 id="2-2-心脏出血错误代码"><a href="#2-2-心脏出血错误代码" class="headerlink" title="2.2 心脏出血错误代码"></a>2.2 心脏出血错误代码</h2><p>导致心脏出血漏洞的编程错误可以归于一行代码：</p><pre><code>memcpy(bp, pl, payload);</code></pre><p>memcpy()是复制数据的命令。bp是被复制的数据的存储区域，pl是被复制的数据的来源，payload是被复制的数据长度。<strong>问题在于，该命令没有检验pl复制的数据是否和payload给予的长度相符。</strong></p><h1 id="3-修复心脏滴血漏洞"><a href="#3-修复心脏滴血漏洞" class="headerlink" title="3 修复心脏滴血漏洞"></a>3 修复心脏滴血漏洞</h1><p>修补心脏出血漏洞的方式是更新最新的OpenSSL版本，你可以在官网上获取相关链接 <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a> 。</p><p>因为OpenSSL是开源的，以下是<strong>修复过的代码</strong>： 代码的第一部分的功能是确定心跳请求的大小不是0KB，不然可能会出错。第二部分用来检验心跳的长度是否和它声称的相符。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">*</span> Read type <span class="token operator">and</span> payload length first<span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">16</span> <span class="token operator">></span> s<span class="token operator">-</span><span class="token operator">></span>s3<span class="token operator">-</span><span class="token operator">></span>relent<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">/</span>silently discard <span class="token operator">*</span><span class="token operator">/</span>hbtype <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>n2s<span class="token punctuation">(</span>p<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> payload <span class="token operator">+</span> <span class="token number">16</span> <span class="token operator">></span> s<span class="token operator">-</span><span class="token operator">></span>s3<span class="token operator">-</span><span class="token operator">></span>rrec<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">/</span> silently discard per RFC <span class="token number">6520</span> sec<span class="token punctuation">.</span> <span class="token number">4</span> <span class="token operator">*</span><span class="token operator">/</span>pl <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-心脏滴血漏洞检测"><a href="#4-心脏滴血漏洞检测" class="headerlink" title="4  心脏滴血漏洞检测"></a>4  心脏滴血漏洞检测</h1><h2 id="4-1-nmap"><a href="#4-1-nmap" class="headerlink" title="4.1  nmap"></a>4.1  nmap</h2><pre class="line-numbers language-bash"><code class="language-bash">nmap -p 443 --script ssl-heartbleed 66.175.219.225或者nmap -sV --script<span class="token operator">=</span>ssl-heartbleed 111.X.X.53 -p 443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其他检测TLS工具也可检测，具体见：<a href="https://m01ly.github.io/2020/08/26/htps-tools/">TLS检测小工具</a> </p><h2 id="4-2-网上在线检测"><a href="#4-2-网上在线检测" class="headerlink" title="4.2 网上在线检测"></a>4.2 网上在线检测</h2><p> <a href="http://possible.lv/tools/hb/">http://possible.lv/tools/hb/</a> </p><p> <a href="http://filippo.io/Heartbleed/">http://filippo.io/Heartbleed/</a> </p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>1  <a href="https://www.aqniu.com/news-views/28453.html">https://www.aqniu.com/news-views/28453.html</a>   通俗易懂</p><p>2 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160</a>  漏洞详情</p><p>3 <a href="https://blog.csdn.net/yaofeiNO1/article/details/54428021">https://blog.csdn.net/yaofeiNO1/article/details/54428021</a>  可利用的payload</p><p>4 <a href="https://www.cnblogs.com/KevinGeorge/p/8029947.html">https://www.cnblogs.com/KevinGeorge/p/8029947.html</a>   POC</p><p>5<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E">https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</a>  wiki</p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS 攻击之POODLE</title>
      <link href="/2020/09/01/htps-attack-paddingoracle/"/>
      <url>/2020/09/01/htps-attack-paddingoracle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载 <a href="http://www.bewindoweb.com/272.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%8C%E5%86%99%E7%9A%84%E5%BE%88%E5%A5%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E6%96%87%E7%AB%A0%E6%88%91%E5%8A%A0%E5%85%A5%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82">http://www.bewindoweb.com/272.html，具体实例分析，写的很好，然后文章我加入了自己的理解。</a></p><h2 id="一、-POODLE简介"><a href="#一、-POODLE简介" class="headerlink" title="一、 POODLE简介"></a>一、 POODLE简介</h2><p>2014年9月Google的一份研究报告<a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">《This POODLE Bites: Exploiting The SSL 3.0 Fallback》</a>指出，SSL存在安全漏洞CVE­-2014-3566，代号为POODLE（Padding Oracle On Downgraded Legacy Encryption，基于降级旧加密协议的填充提示），该漏洞可以使得攻击者获取到一段明文数据，比如HTTP的cookie。</p><p><strong>漏洞影响版本：</strong>SSL v3.0以下</p><p><strong>防御方法：</strong>完全禁用SSL，或者利用TLS_FALLBACK_SCSV字段禁止协议降级到SSL</p><h1 id="二、Padding-Oracle-攻击原理"><a href="#二、Padding-Oracle-攻击原理" class="headerlink" title="二、Padding Oracle 攻击原理"></a>二、Padding Oracle 攻击原理</h1><p>Padding Oracle是Web程序渗透的经典攻击方式，由Juliano Rizzo和Thai Duong于2010年<a href="http://netifera.com/research/">《Practical Padding Oracle Attacks》</a>提出，该攻击利用CBC（Cipher-block chaining，密码块链接模式）加密模式中的填充漏洞给出的提示信息逐步推导出明文数据。</p><h2 id="2-1-CBC密码块链接模式——加密"><a href="#2-1-CBC密码块链接模式——加密" class="headerlink" title="2.1 CBC密码块链接模式——加密"></a><strong>2.1 CBC密码块链接模式——加密</strong></h2><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950607286.png" alt="1598950607286"></p><p>（1）对明文进行分组，每组长度相同（一般为8字节或16字节），对长度不足的分组需要进行填充（Padding）。</p><p>填充通常遵循的是PKCS5标准，即填充的字符是需要填充字符的个数。</p><p>例如，这里的明文字符串为“GET /a HTTP/1.1\r”，那么按ASCII的十六进制就可以表示为：</p><ul><li>第一组明文：“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”</li><li>第二组明文：“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”</li></ul><p>假设后面还有字符不能构成8字节的一组，那么需要进行填充，例如（前面字符没有用十六进制表示）：</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950619500.png" alt="1598950619500"></p><p>当然，一般不会有全填充的组。</p><p>（2）随机生成一个初始化向量IV，与第一个明文分组进行异或运算得到中间值（Intermediary Value）。</p><p>例如这里随机生成的IV为“0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08”，与第一个分组“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”进行异或后得到“0x46、0x47、0x57、0x24、0x2A、0x67、0x27、0x40”。</p><p>（3）将异或结果进行加密，得到第一个明文分组的密文。</p><p>一般会使用密钥（key）加密，这里简单假设密钥加密效果等同于加密函数y = f(x) = x + 1，那么可以得到第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”。</p><p>（4）从第二个明文分组开始，将上一组密文当作IV，进行异或运算，再进行加密，得到该组密文。</p><p>例如这里由第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”与第二组明文“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”进行异或，得到“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”，再进行相同加密，得到“0x14、0x1D、0x09、0x0B、0x1B、0x47、0x1A、0x4D”，这就是第二组密文。</p><h2 id="2-2-CBC密码块链接模式——解密"><a href="#2-2-CBC密码块链接模式——解密" class="headerlink" title="2.2 CBC密码块链接模式——解密"></a><strong>2.2 CBC密码块链接模式——解密</strong></h2><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950639436.png" alt="1598950639436"></p><p>加密的IV是随机生成的，而解密则必须使用这个IV。</p><p>（1）对密文进行分组，每组长度相同（一般为8字节或16字节）。</p><p>例如这里将密文分为了两组：</p><ul><li>第一组密文：“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”</li><li>第二组密文：“0x14、0x1D、0x09、0x0B、0x1B、0x47、0x1A、0x4D”</li></ul><p>（2）对密文进行解密，得到中间值。</p><p>一般使用密钥，同样的这里假设密钥效果等同于函数x = f(y) = y - 1</p><ul><li>第一组中间值：“0x46、0x47、0x57、0x24、0x2A、0x67、0x27、0x40”</li><li>第二组中间值：“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”</li></ul><p>（3）使用初始化向量IV，与第一个分组进行异或运算得到第一组明文。</p><p>这是利用异或的性质：a⊕b=c，a⊕c=b，b⊕c=a，所以无论如何异或都能得到唯一的第三个数。</p><p>例如这里IV为“0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08”，第一个数0x01与第一组第一个中间值0x46异或结果为0x47，就是明文“G”的ASCII十六进制表示，于是得到第一组明文“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”</p><p>（4）从第二组开始，依次将前一组密文和该组中间值异或，得到该组明文。</p><p>例如第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”和第二组中间值“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”异或得到第二组明文“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”。</p><p>值得注意的是，<strong>解密可以并行计算，因为密文都是已经获取好的</strong>；加密则不行，因为前一组密文必须要计算出来。</p><h2 id="2-3-Padding-Oracle-攻击"><a href="#2-3-Padding-Oracle-攻击" class="headerlink" title="2.3 Padding Oracle 攻击"></a><strong>2.3 Padding Oracle 攻击</strong></h2><h4 id="2-3-1-攻击原理"><a href="#2-3-1-攻击原理" class="headerlink" title="2.3.1 攻击原理"></a>2.3.1 攻击原理</h4><p><img src="/2020/09/01/htps-attack-paddingoracle/1599017277323.png" alt="1599017277323"></p><p><strong>攻击最终原理：</strong></p><p><strong>目标：</strong>已知IV，密文。求中间值。</p><p><strong>方法：</strong></p><p>通过逐字节伪造IV使得：<br>$$<br>伪造IV+中间值=0x01(明文)<br>$$<br>（因为服务器端会进行padding校验，回显成功与否，这里用的padding是pkcs#5）</p><p>然后利用：<br>$$<br>0x01(明文)+真实IV=中间值<br>$$<br>即可求得中间值，从而通过下列等式求得明文。<br>$$<br>真实IV+中间值=明文<br>$$</p><h4 id="2-3-2-攻击过程"><a href="#2-3-2-攻击过程" class="headerlink" title="2.3.2 攻击过程"></a>2.3.2 攻击过程</h4><hr><p>首先请注意，始终在字符串的末尾附加至少一个填充字节，因此将使用0x01填充7字节的值（如AVOCADO），而将8字节的值（如PLANTAIN）具有向其中添加了完整的填充块。填充字节的值还指示字节数，因此逻辑上最后一个密文块末尾的逻辑最终值必须是：</p><ul><li>单个0x01字节（0x01）</li><li>两个0x02字节（0x02、0x02）</li><li>三个0x03字节（0x03、0x03、0x03）</li><li>四个0x04字节（0x04、0x04、0x04、0x04）</li><li>…等等</li></ul><p><strong>如果最终的解密块未以这些有效字节序列之一结尾，则大多数密码提供程序将抛出无效的填充异常。引发此异常的事实对于攻击者（我们）而言至关重要，因为它是填充预言攻击的基础</strong>。</p><p>现在构造一个场景：假设密文仍然是上述字段“GET /a HTTP/1.1\r”，且用户连接到的是公共WIFI，攻击者可以通过抓包获取CBC密文以及初始化向量IV（当然要把IV明文传给服务器否则服务器无法解密第一个分组）。</p><p>我们现在希望通过密文和IV获取明文，由于“IV⊕中间值=明文”，问题转变为如何求IV对应的中间值。</p><p>我们知道，对大多数Web服务器而言：</p><ul><li><p>收到有效的密文（正确填充并包含有效数据的密文）后，应用程序将正常响应（200 OK）</p></li><li><p>收到无效的密文（解密后不会以有效填充结尾）时，应用程序将引发加密异常（500 Internal Server Error）</p></li><li><p><em>收到有效的密文（正确填充的密文）但解密为无效值时，应用程序将显示自定义错误消息（200 OK）</em></p><p>上面描述的场景是经典的Padding Oracle，因为我们可以使用应用程序的行为轻松确定提供的加密值是否正确填充。术语oracle是指可以用来确定测试通过还是失败的机制。</p><p>IV出现在解密的最后一步，而且是可以构造的，那么攻击者可以通过构造特殊的IV，直到符合“填充”规则通过解密流程（虽然不一定能通过数据合法性校验），具体而言：</p></li></ul><p>（1）构造“0x00、0x00、0x00、0x00、0x00、0x00、0x00、0x00”的特殊IV发送给服务端，不断尝试递增最后一位并发送给服务端，直到服务端解密成功。</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950652145.png" alt="1598950652145"></p><p>此时必然产生了1位填充（因为我们已经知道IV是0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08），最多尝试次数为256次。（<strong>这里最后一位必须为01才可以通过服务器的padding校验，因为采用的是PKCS5标准填充</strong>）</p><p>（2）计算出末位中间值，其值等于伪造向量末位异或0x01：0x41⊕0x01=0x40</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950673196.png" alt="1598950673196"></p><p>（3）利用原始向量末位值异或中间值，得到明文0x48，即字符“H”：0x40⊕0x08=0x48</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950689577.png" alt="1598950689577"></p><p>（4）利用中间值计算出末位为0x02的伪造向量应有值：0x40⊕0x02=0x42</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950705091.png" alt="1598950705091"></p><p>（5）通过改变倒数第二位，直到生成0x020x02的末位明文填充字符，符合2位填充规则，然后类似地推测倒数第二位的中间值：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/9a93974acc1def3a2247974deb3a6392.jpeg" alt="img"></p><p>重复上述步骤，就能够得到完整的明文信息，这就是Padding Oracle 填充提示攻击。</p><h1 id="三、POODLE攻击原理"><a href="#三、POODLE攻击原理" class="headerlink" title="三、POODLE攻击原理"></a>三、POODLE攻击原理</h1><h2 id="3-1-SSLv3-0存在的问题"><a href="#3-1-SSLv3-0存在的问题" class="headerlink" title="3.1 SSLv3.0存在的问题"></a><strong>3.1 SSLv3.0存在的问题</strong></h2><p>SSLv3.0的记录层可以使用如下加密方式：</p><table><thead><tr><th align="left">加密类型</th><th align="left">加密方式</th></tr></thead><tbody><tr><td align="left">块加密 Block Cipher</td><td align="left">IDEA</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">RC2-40</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">DES-40</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">DES</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">3DES</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">FORTEZZA</td></tr><tr><td align="left">流加密 Stream Cipher</td><td align="left">RC-40</td></tr><tr><td align="left">流加密 Stream Cipher</td><td align="left">RC4-128</td></tr></tbody></table><p>流加密这里不讨论，也是有安全问题，主要讨论CBC块加密。</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598952050289.png" alt="1598952050289"></p><p>SSL记录层加密的是原始数据+MAC（消息验证码）信息摘要+填充字节，MAC一般是Hash值，SSLv3.0中MAC通常为20字节。也就是说，SSL先对数据做完整性校验，再进行CBC加密。在CBC解密的一端（服务器），SSL没有规定padding填充块字节内容，只校验填充块最后一个字节，该字节为填充长度，然后去掉填充的字符，再进行MAC验证，最后获得明文数据。</p><ul><li>先校验完整性，再加密，使得对端收到数据后先解密，后校验完整性，解密是否成功为攻击提供了判断依据；</li><li>只验证填充块的最后一个字节，因此填充块可以填充任意字符，且最后字符固定使得攻击者可以利用类似Padding Oracle的攻击机制。</li></ul><p>我们可以利用类似前面Padding Oracle的思路，将要解密的字符放到最后一个块末尾，不断地调整前一个IV的值（可能是初始化向量，也可能是前一段的密文，并且无论是哪个攻击者都是知道的），直到成功通过解密，此时明文必定为0x07或0x15（16字节一块的话）（因为需要填充一整块），最多尝试256次（或512次），就能够通过服务器验证，从而推导出对应的中间值，然后利用该中间值和IV推导出明文。这期间不用担心修改IV导致MAC校验失败，因为那是CBC解密之后的事情。</p><h2 id="3-2-利用SSL漏洞进行POODLE攻击"><a href="#3-2-利用SSL漏洞进行POODLE攻击" class="headerlink" title="3.2 利用SSL漏洞进行POODLE攻击"></a><strong>3.2 利用SSL漏洞进行POODLE攻击</strong></h2><p>假设攻击者B代理了客户端A的HTTPS访问服务器C的请求，可以截获到SSL密文数据以及SSL握手阶段的IV，且可以通过A去发送HTTPS请求，此时如果A没有退出登录，都会自动携带上Cookie。这样，B可以控制A发送的HTTP请求中的请求路径Path和请求体Body，并通过调整Path和Body，让A发出的请求满足两个条件：</p><ul><li>填充字段恰好填充了一个块长度</li><li>Cookie的第一个未知字符刚好出现在前面某个块的末尾</li></ul><p>例如，加密采用3DES，8字节一个块，且SSL上层为HTTP协议，发送的明文为：</p><pre class="line-numbers language-html"><code class="language-html">GET / HTTP/1.1\r\nCookie: abcdefgh \r\n\r\nXXXX MAC数据 XXXXXX7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://cdn.bewindoweb.com/uploadpic/4343d6e74ca6d402f60be08d3af7e425.jpeg" alt="img"></p><p>MAC数据可能并不是刚好8字节，不过无所谓。攻击者并不知道明文，但知道Cookie密文的位置，知道此时想要解密的cookie的最后一个字符在第4个块末尾。然后攻击者将整个块的密文复制到最后一个填充块密文上：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/865b1480ac514fd22f27de5b08825418.jpeg" alt="img"></p><p>然后不断调整前一块（MAC数据）对应密文位置的值，直到通过解密校验，根据SSL的漏洞，此时最后一块最后一个值必然为0x07：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/be0160296022f639c6aa6c25b3917167.jpeg" alt="img"></p><p>这里例子举得不好，0x07密文也是0x07，后面用0x07明、0x07密来区分，此时我们假设未知加密函数为f(x)，其逆为g(y)，那么根据CBC解密流程，有：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token number">0x07</span>明 <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密<span class="token punctuation">)</span> ⊕  <span class="token number">0x01</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x06</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在要求：（此时要注意不是拿0x6E ⊕ g(0x07密）,因为如果解密第四块，应该是第三块 最后一字符⊕g(0x07密））</p><pre class="line-numbers language-c"><code class="language-c">x <span class="token operator">=</span> <span class="token number">0x6E</span> ⊕ <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此x = 0x68，即字符”h”，得到解密明文”h”。</p><p>同理，通过控制请求路径，例如GET /a、GET /aa，不断地把已经解密的Cookie字符挤出，把未知字符留在该块末尾，然后循环进行前述操作，即可得到完整的Cookie字段。</p><h2 id="3-3-Padding验证和MAC验证返回结果不同的情况"><a href="#3-3-Padding验证和MAC验证返回结果不同的情况" class="headerlink" title="3.3 Padding验证和MAC验证返回结果不同的情况"></a><strong>3.3 Padding验证和MAC验证返回结果不同的情况</strong></h2><p>前面的操作都是建立在Padding验证和MAC验证返回结果不同的基础之上，如果返回结果相同，那么MAC会校验不过导致失去判断Padding验证成功的依据。此时攻击者需要利用响应时间的差异来进行判断。如果响应时间仍然相同，那么这种攻击就无效了。</p><h2 id="3-4-POODLE中“降级”的体现"><a href="#3-4-POODLE中“降级”的体现" class="headerlink" title="3**.4 POODLE中“降级”的体现**"></a>3**.4 POODLE中“降级”的体现**</h2><p>POODLE只在SSLv3.0以下版本才容易攻击成功，TLS会检查填充字符，所以TLS构造的padding通过服务器验证概率极低，TLSv1.3以后则完全避免了该漏洞。2014年，TLS已经得到广泛应用，但不乏少数服务器、客户端（比如IE6）和中间网络设备仍然采用SSL协议。因此为了平滑过渡增加用户体验，TLS1.2、TLS1.1、TLS1.0协议实现都会向后兼容SSLv3.0协议，最终协商通信协议为服务端和客户端支持的最高版本协议。如果记录协议中采用的是RC4流加密或者CBC模式的块加密，那么攻击者就可以进行POODLE攻击。</p><h1 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4 解决方法"></a>4 解决方法</h1><p>禁用SSL 3.0协议(ssl version ssl3.0 disable)。</p><h2 id="4-1-服务端禁用方法"><a href="#4-1-服务端禁用方法" class="headerlink" title="4.1 服务端禁用方法"></a>4.1 服务端禁用方法</h2><p><strong>（1）Apache 2.x:</strong><br>在mod_ssl配置文件中使用如下命令禁用SSLv2和SSLv3：<br>SSLProtocol All -SSLv2 -SSLv3<br>重启Apache</p><p><strong>（2）Nginx:</strong><br>在配置文件中使用：<br>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>重启Nginx</p><p><strong>（3）lighttpd：</strong><br>确认lighttpd为1.4.29及以上版本<br>在配置文件中使用<br>ssl.use-sslv3 = “disable”<br>重启lighttpd</p><p><strong>（4）tomcat参考:</strong></p><pre><code>https://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html</code></pre><p><a href="https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html</a></p><p><strong>（5）IIS:</strong><br>查找如下注册表项：<br>HKey_Local_MachineSystemCurrentControlSetControlSecurityProviders SCHANNELProtocols<br>该注册表项通常包含以下子项：</p><ul><li>PCT 1.0</li><li>SSL 2.0</li><li>SSL 3.0</li><li>TLS 1.0<br>每个注册表项都保留适用于该项的协议相关信息。可以在服务器上禁用这些协议中的任一种。为此，</li></ul><p>请在协议SSL 3.0的服务器子项中创建一个新的DWORD值。名称为Enabled,将DWORD值设置为“00 00 00 00”。 重启IIS服务</p><h2 id="4-2-浏览器禁用方法"><a href="#4-2-浏览器禁用方法" class="headerlink" title="4.2 浏览器禁用方法"></a>4.2 浏览器禁用方法</h2><p><strong>（1）IE:</strong><br>“工具” -&gt; “Internet 选项” -&gt; “高级” ，取消”使用 SSL 3.0”的复选框。<br><strong>（2）Chrome:</strong></p><p>复制一个平时打开 Chrome 浏览器的快捷方式，在新的快捷方式上右键点击，进入属性，<br>在”目标”后面的空格中字段的末尾输入以下命令 –ssl-version-min=tls1<br><strong>（3）FireFox:</strong></p><p>在地址栏输入”about:config”，然后将 security.tls.version.min 调至 1。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1、<a href="https://www.jianshu.com/p/ad8bdd87e131">《Web狗要懂的Padding Oracle攻击》</a>：很详细</p><p>2、<a href="https://www.jianshu.com/p/1851f778e579">《Padding Oracle》</a></p><p>3、[《百度百科：Padding Oracle》](<a href="https://baike.baidu.com/item/Padding">https://baike.baidu.com/item/Padding</a> Oracle/3530091?fr=aladdin)</p><p>4、<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">《ASCII表》</a>和<a href="https://www.23bei.com/tool-531.html">在线异或计算器</a>：便于实验</p><p>5、<a href="https://www.cnblogs.com/xzjf/p/8251651.html">《HTTPS 协议降级攻击原理》</a>：对攻击原理理解透彻</p><p>6、<a href="http://www.vuln.cn/6135">《CVE-2014-3566 SSLv3 POODLE原理分析 – insight-labs》</a>：有些许理解错误，注意辨别</p><p>7、<a href="https://www.imperialviolet.org/2014/10/14/poodle.html">《POODLE attacks on SSLv3 (14 Oct 2014)》</a>：英文原文例子</p><p>8、<a href="https://blog.csdn.net/howeverpf/article/details/40350113">《漏洞分析—SSLv3降级加密协议Padding Oracle攻击（POODLE）技术分析》</a>：例子详细</p><p>9、<a href="http://www.bubuko.com/infodetail-413104.html">《SSLv3 POODLE 攻击分析》</a>：最正确的一篇分析</p><p>10、<a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">《This POODLE Bites: Exploiting The SSL 3.0 Fallback》</a>：Google研究报告原文</p><p>11  <a href="https://www.onebug.org/%E7%BB%BF%E7%9B%9F%E6%BC%8F%E6%B4%9E%E5%BA%93/87280.html">https://www.onebug.org/%E7%BB%BF%E7%9B%9F%E6%BC%8F%E6%B4%9E%E5%BA%93/87280.html</a> ：预防办法</p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组密码--填充模式</title>
      <link href="/2020/08/31/blockcipher-padding/"/>
      <url>/2020/08/31/blockcipher-padding/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自 <a href="https://www.jianshu.com/p/16e1cbc0b7a9">https://www.jianshu.com/p/16e1cbc0b7a9</a> </p><p>填充模式不仅仅适用于对称密码，非对称密码也会用到，比如RSA</p><p>分组密码中，需要将明文按指定大小进行分组，由于明文并非指定大小的整数倍，因此在明文的最后一个分组需要将其填充至加密算法所要求的分组大小后进行加密。</p><p>在解密时，按照同样的填充模式将填充的数据去除。</p><p>斜体表示 SunJCE 支持，非斜体为 BouncyCastle 支持</p><h3 id="NOPADDING"><a href="#NOPADDING" class="headerlink" title="NOPADDING"></a><em>NOPADDING</em></h3><p>不填充，在此填充下原始数据必须是分组大小的整数倍，非整数倍时无法使用该模式</p><h3 id="PKCS5PADDING，PKCS7PADDING"><a href="#PKCS5PADDING，PKCS7PADDING" class="headerlink" title="PKCS5PADDING，PKCS7PADDING"></a><em>PKCS5PADDING</em>，PKCS7PADDING</h3><p>填充至符合块大小的整数倍，填充值为填充数量数</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code></li></ul><p><code>PKCS5PADDING</code> 的块大小应为 8 个字节，而 <code>PKCS7PADDING</code> 的块大小可以在 1~255 的范围内。但 SunJCE 的 Provider 实现中 <code>PKCS5PADDING</code> 也按 <code>PKCS7PADDING</code> 来进行处理了。</p><h3 id="ISO10126PADDING"><a href="#ISO10126PADDING" class="headerlink" title="ISO10126PADDING"></a>ISO10126PADDING</h3><p>填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 3F 7A B4 09 14 36 07</code></li></ul><h3 id="ISO7816-4PADDING"><a href="#ISO7816-4PADDING" class="headerlink" title="ISO7816-4PADDING"></a>ISO7816-4PADDING</h3><p>填充至符合块大小的整数倍，填充值第一个字节为 0x80，其他字节填 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00</code></li></ul><h3 id="ZEROBYTEPADDING"><a href="#ZEROBYTEPADDING" class="headerlink" title="ZEROBYTEPADDING"></a>ZEROBYTEPADDING</h3><p>填充至符合块大小的整数倍，填充值为 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</code></li></ul><h3 id="X923PADDING"><a href="#X923PADDING" class="headerlink" title="X923PADDING"></a>X923PADDING</h3><p>填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节填 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07</code></li></ul><h3 id="TBCPADDING（Trailing-Bit-Compliment）"><a href="#TBCPADDING（Trailing-Bit-Compliment）" class="headerlink" title="TBCPADDING（Trailing-Bit-Compliment）"></a>TBCPADDING（Trailing-Bit-Compliment）</h3><p>填充至符合块大小的整数倍，原文最后一位为“1”时填充 0x00，最后一位为“0”时填充“0xFF”</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</code></li><li>原始：<code>FF FF FF FF FF FF FF FF F0</code></li><li>填充：<code>FF FF FF FF FF FF FF FF F0 FF FF FF FF FF FF FF</code></li></ul><h3 id="PKCS1PADDING"><a href="#PKCS1PADDING" class="headerlink" title="PKCS1PADDING"></a><em>PKCS1PADDING</em></h3><p>该填充模式是 RSA 加密中使用的，详见 <a href="https://tools.ietf.org/html/rfc2313">RFC 2313</a>。RSA 加密时，需要将原文填充至密钥大小，填充的格式为：</p><pre><code>00 + BT + PS + 00 + D</code></pre><ul><li><code>00</code> 为固定字节</li><li><code>BT</code> 为处理模式。公钥操作时为 <code>02</code>，私钥操作为 <code>00</code> 或 <code>01</code></li><li><code>PS</code> 为填充字节，填充数量为 <code>k - 3 - D</code>，<code>k</code> 表示密钥长度，<code>D</code> 表示原文长度。<code>PS</code> 的最小长度为 8 个字节。填充的值根据 <code>BT</code> 值不同而不同： <ul><li><code>BT = 00</code> 时，填充全 <code>00</code></li><li><code>BT = 01</code> 时，填充全 <code>FF</code></li><li><code>BT = 02</code> 时，随机填充，但不能为 <code>00</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组密码--工作模式</title>
      <link href="/2020/08/31/blockcipher-operation-mode/"/>
      <url>/2020/08/31/blockcipher-operation-mode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载wiki</p><h2 id="1-前期知识"><a href="#1-前期知识" class="headerlink" title="1 前期知识"></a>1 前期知识</h2><p>分组密码算法</p><h2 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2 工作模式"></a>2 工作模式</h2><p>我们知道分组密码属于对称密码算法，但是每次只能处理特定长度的一块数据的算法，每块都是一个分组，分组的比特数就称为分组长度。因此针对加密的内容超过分组密码的分组长度时，该如何安全加密呢？这时候就需要工作模式来解决这个问题， 分组密码工作模式描述了如何重复加密比较长的多个数据块，工作模式中会用到加密算法，加密算法只是工作模式中的一环节，这里要区分开。</p><p> 常见的分组加密算法有: DES、3DES、AES、IDEA 。</p><p><strong>常见分组密码算法分组长度和密钥长度如下表:</strong></p><table><thead><tr><th>密码算法</th><th>分组长度</th><th>密钥长度</th></tr></thead><tbody><tr><td>DES</td><td>64 bit/8 byte</td><td>64(56+8) bit/8 byte</td></tr><tr><td>3DES</td><td>64 bit/8 byte</td><td>64/64*2/64 * 3 bit</td></tr><tr><td>AES</td><td>128 bit/16 byte</td><td>128/192/256 bit</td></tr></tbody></table><p>经典的工作模式有以下5种。</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598927024511.png" alt="1598927024511"></p><p> <img src="https://img-blog.csdnimg.cn/20200412155237387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9xaWFvbGl1c2h1aUND,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><h3 id="2-1-电子密码本（ECB）"><a href="#2-1-电子密码本（ECB）" class="headerlink" title="2.1 电子密码本（ECB）"></a>2.1 电子密码本（ECB）</h3><p>最简单的加密模式即为<strong>电子密码本</strong>（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。</p><p><a href="https://zh.wikipedia.org/wiki/File:Ecb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/Ecb_encryption.png" alt="Ecb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ecb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Ecb_decryption.png" alt="Ecb decryption.png"></a></p><p>本方法的缺点在于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。下面的例子显示了ECB在密文中显示明文的模式的程度：该图像的一个位图版本（左图）通过ECB模式可能会被加密成中图，而非ECB模式通常会将其加密成右图。</p><table><thead><tr><th><a href="https://zh.wikipedia.org/wiki/File:Tux.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Tux.jpg" alt="Tux.jpg"></a></th><th><a href="https://zh.wikipedia.org/wiki/File:Tux_ecb.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg" alt="Tux ecb.jpg"></a></th><th><a href="https://zh.wikipedia.org/wiki/File:Tux_secure.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/a/a0/Tux_secure.jpg" alt="Tux secure.jpg"></a></th></tr></thead><tbody><tr><td>原图</td><td>使用ECB模式加密</td><td>提供了伪随机性的非ECB模式</td></tr></tbody></table><p>右图是使用CBC，CTR或任何其它的更安全的模式加密左图可能产生的结果——与随机噪声无异。注意右图看起来的随机性并不能表示图像已经被安全的加密；许多不安全的加密法也可能产生这种“随机的”输出。</p><p>ECB模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用ECB模式的Blowfish密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。</p><h3 id="2-2-密码块链接（CBC）"><a href="#2-2-密码块链接（CBC）" class="headerlink" title="2.2 密码块链接（CBC）"></a>2.2 密码块链接（CBC）</h3><p>1976年，IBM发明了<strong>密码分组链接</strong>（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><p><a href="https://zh.wikipedia.org/wiki/File:Cbc_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/d/d3/Cbc_encryption.png" alt="Cbc encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Cbc_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Cbc_decryption.png" alt="Cbc decryption.png"></a></p><p>若第一个块的下标为1，则CBC模式的加密过程为</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926624504.png" alt="1598926624504"></p><p>而其解密过程则为</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926632436.png" alt="1598926632436"></p><p>CBC是最为常用的工作模式。它的主要缺点在于<strong>加密过程是串行</strong>的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。</p><p>注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，<strong>解密过程可以被并行化</strong>，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。</p><h3 id="2-3-填充密码块链接（PCBC）"><a href="#2-3-填充密码块链接（PCBC）" class="headerlink" title="2.3 填充密码块链接（PCBC）"></a>2.3 填充密码块链接（PCBC）</h3><p><strong>填充密码块链接</strong>（<strong>PCBC</strong>，Propagating cipher-block chaining）或称为<strong>明文密码块链接</strong>（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p><p><a href="https://zh.wikipedia.org/wiki/File:Pcbc_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Pcbc_encryption.png" alt="Pcbc encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Pcbc_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Pcbc_decryption.png" alt="Pcbc decryption.png"></a></p><p>加密和解密算法如下：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926657325.png" alt="1598926657325"></p><p>PCBC主要用于Kerberos v4和WASTE中，而在其它场合的应用较少。对于使用PCBC加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5没有使用PCBC。</p><h3 id="2-4-密文反馈（CFB）"><a href="#2-4-密文反馈（CFB）" class="headerlink" title="2.4 密文反馈（CFB）"></a>2.4 密文反馈（CFB）</h3><p><strong>密文反馈</strong>（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%AF%86%E7%A0%81">流密码</a>；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926692468.png" alt="1598926692468"></p><p><a href="https://zh.wikipedia.org/wiki/File:Cfb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/f/fd/Cfb_encryption.png" alt="Cfb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Cfb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Cfb_decryption.png" alt="Cfb decryption.png"></a></p><p>上述公式是描述的是最简单的CFB，在这种模式下，它的自同步特性仅仅与CBC相同，即若密文的一整块发生错误，CBC和CFB都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用CFB的自同步性。</p><p>为了利用CFB制作一种自同步的，可以处理任意位情况错误的流密码，需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高<em>x</em>位与明文的<em>x</em>进行异或，以产生密文的<em>x</em>位。下一步将生成的<em>x</em>位密文移入寄存器中，并对下面的<em>x</em>位明文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高<em>x</em>与密文异或，产生<em>x</em>位明文，再将密文的下面<em>x</em>位移入寄存器。</p><p>下式中Si是移位寄存器的第<em>i</em>个状态，a &lt;&lt; x是指将<em>a</em>移位<em>x</em>位，head(a, x)是指<em>a</em>的高<em>x</em>位，<em>n</em>则是指IV的位数。</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926716035.png" alt="1598926716035"></p><p>若密文的<em>x</em>位发生错误，则密码在移位寄存器恢复与加密时的状态相同之前，输出不正确的结果，而当寄存器状态恢复后，密码即可以重新同步，恢复正常输出，因此最多只有一块数据发生错误。</p><p>与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。</p><p>CFB拥有一些CBC所不具备的特性，这些特性与OFB和CTR的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。</p><h3 id="2-5-输出反馈（OFB）"><a href="#2-5-输出反馈（OFB）" class="headerlink" title="2.5 输出反馈（OFB）"></a>2.5 输出反馈（OFB）</h3><p><strong>输出反馈</strong>模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。</p><p>由于XOR操作的对称性，加密和解密操作是完全相同的：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926747469.png" alt="1598926747469"></p><p><a href="https://zh.wikipedia.org/wiki/File:Ofb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Ofb_encryption.png" alt="Ofb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ofb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Ofb_decryption.png" alt="Ofb decryption.png"></a></p><p>每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。</p><p>可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。</p><h3 id="2-6计数器模式（CTR）"><a href="#2-6计数器模式（CTR）" class="headerlink" title="2.6计数器模式（CTR）"></a>2.6计数器模式（CTR）</h3><p>与OFB相似，CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非CTR模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。</p><p>CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。</p><p>注意图中的“nonce”与其它图中的IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。</p><p><a href="https://zh.wikipedia.org/wiki/File:Ctr_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/3/3f/Ctr_encryption.png" alt="Ctr encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ctr_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Ctr_decryption.png" alt="Ctr decryption.png"></a></p><p>参考文献：</p><p> <a href="https://blog.csdn.net/xiaoqiaoliushuiCC/article/details/105470567">https://blog.csdn.net/xiaoqiaoliushuiCC/article/details/105470567</a> </p><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo踩坑</title>
      <link href="/2020/08/26/hexo-guide/"/>
      <url>/2020/08/26/hexo-guide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo自建博客"><a href="#Hexo自建博客" class="headerlink" title="Hexo自建博客"></a>Hexo自建博客</h1><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p><a href="https://www.dazhuanlan.com/2019/12/18/5df99e24d6d27/">https://www.dazhuanlan.com/2019/12/18/5df99e24d6d27/</a></p><p><a href="https://www.jianshu.com/p/7f06d10f2e3e">https://www.jianshu.com/p/7f06d10f2e3e</a></p><p><a href="https://www.jianshu.com/p/db02d775aed0">https://www.jianshu.com/p/db02d775aed0</a></p><h1 id="1-插入图片"><a href="#1-插入图片" class="headerlink" title="1 插入图片"></a>1 插入图片</h1><h2 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1  配置文件"></a>1.1  配置文件</h2><blockquote><p>根目录配置_config.yml里面的post_asset_folder:false这个选项设置为true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder</p><pre><code>post_asset_folder: true</code></pre></blockquote><h2 id="1-2-安装图片插件"><a href="#1-2-安装图片插件" class="headerlink" title="1.2 安装图片插件"></a>1.2 安装图片插件</h2><p>先卸载 hexo-asset-image: npm uninstall hexo-asset-image</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图片居中</p><pre><code>&lt;style&gt;img &#123;  position:relative;  width:60%;  left:15%;/*left为（img父元素元素的width - img元素自己的width)÷2*/&#125;&lt;/style&gt;</code></pre><h1 id="2-建立-about等页面"><a href="#2-建立-about等页面" class="headerlink" title="2  建立 about等页面"></a>2  建立 about等页面</h1><h1 id="3-使用标签和分类"><a href="#3-使用标签和分类" class="headerlink" title="3 使用标签和分类"></a>3 使用标签和分类</h1><p> <strong>注：文章标签可以添加多个，分类却只能有一个，设置多个只有第一个生效。</strong> </p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><p>在Hexo博客本地根目录右键选择<code>Git Bash</code>（前提是已安装好<code>Git</code>和<code>Node.js</code>,可参照<a href="https://sogrey.github.io/article/%E5%A6%82%E4%BD%95%E5%9C%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E4%B8%BB%E9%A1%B5%EF%BC%9F/">如何在Github Pages搭建个人独立主页？</a>）,输入命令：</p><pre><code>hexo new page tags</code></pre><p>回车，提示：</p><pre><code>INFO  Created: ...\source\tags\index.md</code></pre><p>就创建完成了。在<code>source\</code>目录下会多出一个<code>tags</code>文件夹，里面有一个<code>index.md</code>文件，打开该文件输入如下：</p><pre><code>---title: 标签云date: 2017-01-10 22:54:00type: &quot;tags&quot;comments: true---</code></pre><p>其中：<code>title</code>和<code>date</code>是标题和创建时间，<code>type</code>表示类型，值<code>tags</code>表示这是个标签云页面，<code>comments</code>是是否允许评论，<code>true</code>表示允许评论。</p><p>这样标签云页面已经创建好了，部署试一下：</p><h2 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h2><h3 id="3-2-1-站点配置"><a href="#3-2-1-站点配置" class="headerlink" title="3.2.1 站点配置"></a>3.2.1 站点配置</h3><p>在站点根目录下的<code>_config.yml</code>里有这么一段：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Directory</span>source_dir: <span class="token function">source</span>public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：<code>category_dir: categories</code>就是分配分类目录了，没有的可以按这样配置，下面就是创建了。</p><h3 id="3-2-2-创建分类"><a href="#3-2-2-创建分类" class="headerlink" title="3.2.2 创建分类"></a>3.2.2 创建分类</h3><p>跟创建<code>云标签</code>一样：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page categories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>source</code>目录下生成一个<code>categories\index.md</code>文件，编辑它：</p><pre class="line-numbers language-bash"><code class="language-bash">---date: 2017-01-12 02:23:17title: categoriestype: <span class="token string">"categories"</span>comments: <span class="token boolean">false</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一篇说道<code>type</code>值为<code>tags</code>是标签云，这里是分类<code>categories</code>。就这么简单不用再做其他输入。</p><p><img src="/2020/08/26/hexo-guide/1599186880480.png" alt="1599186880480"></p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h1><p>官方指南 <a href="https://hexo.io/zh-cn/docs/tag-plugins">https://hexo.io/zh-cn/docs/tag-plugins</a> </p><p>yelee主题使用指南: <a href="http://moxfive.xyz/yelee/">http://moxfive.xyz/yelee/</a> </p><p> <a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a></p><pre><code>hexo ghexo server 本地服务器浏览hexo d 上传</code></pre><p> <a href="https://m01ly.github.io/archives/">https://m01ly.github.io/archives/</a> </p><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4 注意事项"></a>4 注意事项</h1><p>md文件命名最好英文</p><p>用yelee主题的博客：</p><p> <a href="https://www.gokuweb.com/web/39c1ec60.html">https://www.gokuweb.com/web/39c1ec60.html</a> </p><p> <a href="https://sogrey.top/article/">https://sogrey.top/article/</a> </p><p>  [<a href="https://durant35.github.io/2016/09/16/hexo_Theme%20Yelee%20Migrant%20Note/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF]">https://durant35.github.io/2016/09/16/hexo_Theme%20Yelee%20Migrant%20Note/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF]</a>(<a href="https://durant35.github.io/2016/09/16/hexo_Theme">https://durant35.github.io/2016/09/16/hexo_Theme</a> Yelee Migrant Note/#自定义版权信息)   好的文章推荐–待安装</p><p> <a href="https://os_heartstill.gitee.io/chih-ping/2019/05/10/Hexo%E7%9A%84Yelee%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">https://os_heartstill.gitee.io/chih-ping/2019/05/10/Hexo%E7%9A%84Yelee%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS安全检测小工具</title>
      <link href="/2020/08/26/htps-tools/"/>
      <url>/2020/08/26/htps-tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-工具汇总"><a href="#1-工具汇总" class="headerlink" title="1 工具汇总"></a>1 工具汇总</h2><p><strong>ssllabs</strong><br>强烈推荐这个网站,简洁直观,非常好<br><a href="https://www.ssllabs.com/">https://www.ssllabs.com/</a></p><p><strong>htbridge</strong><br>这个网站检测全面,SSL检测项目更新最快<br><a href="https://www.htbridge.com/ssl/">https://www.htbridge.com/ssl/</a></p><p><strong>myssl</strong><br>这个网站是中国特供,国内访问速度最快,并提供对各大国产浏览器的SSL检测<br><a href="https://myssl.com/">https://myssl.com</a></p><p><strong>testssl</strong> </p><p>非常全的工具 <a href="https://testssl.sh/">https://testssl.sh/</a> </p><h2 id="2-sslscan"><a href="#2-sslscan" class="headerlink" title="2  sslscan"></a>2  sslscan</h2><ul><li>是否支持TLS Fallback SCSV</li><li>是否支持压缩</li><li>是否有心脏滴血漏洞（heartbleed）</li><li>支持的密码套件（及服务器优选的preferred, 红色表示不安全算法，黄色代表中等强度的算法 ）</li><li>证书信息</li></ul><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>（1）下载源码</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># git clone https://github.com/rbsec/sslscan</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）进入目录</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localname~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd sslscan</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）编译安装</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localname sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># make static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）查看是否编译成功</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localhost sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#./sslscan -version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/08/26/htps-tools/1597831322514.png" alt="1597831322514"></p><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p> [root@localhost sslscan]# ./sslscan –tlsall <a href="http://www.baidu.com:443/">www.baidu.com:443</a></p><p>​    OR</p><p>  [root@localhost sslscan]# ./sslscan –tlsall 192.168.5.200   —-假如192.168.5.200是你的服务器IP</p><p>​    PS：上述两个命令的前提是能够ping通。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ./sslscan --tlsall www.baidu.com:443</span>Version: 2.0.0-staticOpenSSL 1.1.1h-dev  xx XXX xxxxConnected to 180.97.34.96Testing SSL server www.baidu.com on port 443 using SNI name www.baidu.com  SSL/TLS Protocols:TLSv1.0   enabledTLSv1.1   enabledTLSv1.2   enabledTLSv1.3   disabled  TLS Fallback SCSV:Server supports TLS Fallback SCSV  TLS renegotiation:Secure session renegotiation supported  TLS Compression:Compression disabled  Heartbleed:TLSv1.2 not vulnerable to heartbleedTLSv1.1 not vulnerable to heartbleedTLSv1.0 not vulnerable to heartbleed  Supported Server Cipher<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:Preferred TLSv1.2  128 bits  ECDHE-RSA-AES128-GCM-SHA256   Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.2  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  AES128-SHA                   Accepted  TLSv1.2  256 bits  AES256-SHA                   Accepted  TLSv1.2  128 bits  RC4-SHA                      Preferred TLSv1.1  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.1  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.1  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.1  128 bits  AES128-SHA                   Accepted  TLSv1.1  256 bits  AES256-SHA                   Accepted  TLSv1.1  128 bits  RC4-SHA                      Preferred TLSv1.0  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.0  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.0  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.0  128 bits  AES128-SHA                   Accepted  TLSv1.0  256 bits  AES256-SHA                   Accepted  TLSv1.0  128 bits  RC4-SHA                        Server Key Exchange Group<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:TLSv1.2  128 bits  secp256r1 <span class="token punctuation">(</span>NIST P-256<span class="token punctuation">)</span>  Server Signature Algorithm<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:TLSv1.2  Server accepts all signature algorithms.  SSL Certificate:Signature Algorithm: sha256WithRSAEncryptionRSA Key Strength:    2048Subject:  baidu.comAltnames: DNS:baidu.com, DNS:baifubao.com, DNS:www.baidu.cn, DNS:www.baidu.com.cn, DNS:mct.y.nuomi.com, DNS:apollo.auto, DNS:dwz.cn, DNS:*.baidu.com, DNS:*.baifubao.com, DNS:*.baidustatic.com, DNS:*.bdstatic.com, DNS:*.bdimg.com, DNS:*.hao123.com, DNS:*.nuomi.com, DNS:*.chuanke.com, DNS:*.trustgo.com, DNS:*.bce.baidu.com, DNS:*.eyun.baidu.com, DNS:*.map.baidu.com, DNS:*.mbd.baidu.com, DNS:*.fanyi.baidu.com, DNS:*.baidubce.com, DNS:*.mipcdn.com, DNS:*.news.baidu.com, DNS:*.baidupcs.com, DNS:*.aipage.com, DNS:*.aipage.cn, DNS:*.bcehost.com, DNS:*.safe.baidu.com, DNS:*.im.baidu.com, DNS:*.baiducontent.com, DNS:*.dlnel.com, DNS:*.dlnel.org, DNS:*.dueros.baidu.com, DNS:*.su.baidu.com, DNS:*.91.com, DNS:*.hao123.baidu.com, DNS:*.apollo.auto, DNS:*.xueshu.baidu.com, DNS:*.bj.baidubce.com, DNS:*.gz.baidubce.com, DNS:*.smartapps.cn, DNS:*.bdtjrcv.com, DNS:*.hao222.com, DNS:*.haokan.com, DNS:*.pae.baidu.com, DNS:*.vd.bdstatic.com, DNS:click.hm.baidu.com, DNS:log.hm.baidu.com, DNS:cm.pos.baidu.com, DNS:wn.pos.baidu.com, DNS:update.pan.baidu.comIssuer:   GlobalSign Organization Validation CA - SHA256 - G2Not valid before: Apr  2 07:04:58 2020 GMTNot valid after:  Jul 26 05:31:02 2021 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-sslscan原理"><a href="#2-3-sslscan原理" class="headerlink" title="2.3 sslscan原理"></a>2.3 sslscan原理</h3><p> ① sslscan通过创建多个https的连接来试探服务器支持的加密方式；</p><p>   ② 当使用https连接到服务器的时候，会交换双方所支持的加密方式，之后选择双发都能支持的方式进行通信；</p><p>​      如果https服务器配置不当，就会存在MITM攻击，攻击者就可以通过客户端支持的弱加密算法来欺骗服务器；</p><p>​      假如使用的是SSLV2的56位DES，当攻击者拦截并使用了这种加密流量过后，可能在很短时间之内就能够破解加密密钥。</p><h3 id="2-4-功能"><a href="#2-4-功能" class="headerlink" title="2.4 功能"></a>2.4 功能</h3><p> ① sslscan能够检测heartbleed，这是一个openssl的漏洞；</p><p>​      heartbleed漏洞存在于OpenSSL TSL中，它由一个缓冲区导致，允许从内存中读取数据；实际上，Heartbleed 可以在任何未装补丁的支持 TLS 的 OpenSSL （1.0.1 到 1.0.1f 之间）服务器上利用；它从服务器内存中读取 64 KB 的纯文本数据，这能够重复执行，服务器上不会留下任何踪迹或日志。 这意味着攻击者可以从服务器读取纯文本信息，包括服务器的的私钥或者加密方式，会话 Cookie 或 HTTPS 请求会包含用户的密码或其它敏感信息。</p><h2 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3 nmap"></a>3 nmap</h2><p> <a href="https://jumpnowtek.com/security/Using-nmap-to-check-certs-and-supported-algos.html">https://jumpnowtek.com/security/Using-nmap-to-check-certs-and-supported-algos.html</a> </p><p>查看证书</p><p>支持的密码套件</p><p>检测漏洞：心脏滴血 Poodle drown 等漏洞</p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> nmap    <span class="token comment" spellcheck="true">#输入y安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>（1）查看证书nmap –script ssl-cert -p 443 baidu.com</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nmap --script ssl-cert -p 443 baidu.com</span>Starting Nmap 6.40 <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at 2020-08-20 16:22 CSTNmap scan report <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>39.156.69.79<span class="token punctuation">)</span>Host is up <span class="token punctuation">(</span>0.0085s latency<span class="token punctuation">)</span>.Other addresses <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: 220.181.38.148PORT    STATE SERVICE443/tcp <span class="token function">open</span>  https<span class="token operator">|</span> ssl-cert: Subject: commonName<span class="token operator">=</span>www.baidu.cn/organizationName<span class="token operator">=</span>BeiJing Baidu Netcom Science Technology Co., Ltd/stateOrProvinceName<span class="token operator">=</span>Beijing/countryName<span class="token operator">=</span>CN<span class="token operator">|</span> Issuer: commonName<span class="token operator">=</span>DigiCert SHA2 Secure Server CA/organizationName<span class="token operator">=</span>DigiCert Inc/countryName<span class="token operator">=</span>US<span class="token operator">|</span> Public Key type: rsa<span class="token operator">|</span> Public Key bits: 2048<span class="token operator">|</span> Not valid before: 2020-02-27T00:00:00+00:00<span class="token operator">|</span> Not valid after:  2021-02-26T12:00:00+00:00<span class="token operator">|</span> MD5:   d0cf b084 759f 231b 9b22 c197 6bd5 d271<span class="token operator">|</span>_SHA-1: e357 f6c5 b7d3 7464 8055 89c9 3797 c98d 9d38 2497Nmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> 0.60 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）查看支持的TLS密码套件nmap –script ssl-enum-ciphers -p 443 baidu.com</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nmap --script ssl-enum-ciphers -p 443 baidu.com</span>Starting Nmap 6.40 <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at 2020-08-20 16:23 CSTNmap scan report <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>220.181.38.148<span class="token punctuation">)</span>Host is up <span class="token punctuation">(</span>0.0093s latency<span class="token punctuation">)</span>.Other addresses <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: 39.156.69.79PORT    STATE SERVICE443/tcp <span class="token function">open</span>  https<span class="token operator">|</span> ssl-enum-ciphers: <span class="token operator">|</span>   SSLv3: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.0: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.1: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.2: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_GCM_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_GCM_SHA384 - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>_  least strength: strongNmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> 2.23 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3) More</p><p>您还可以使用Nmap脚本查找众所周知的ssl和tls漏洞</p><ul><li><a href="https://nmap.org/nsedoc/scripts/ssl-ccs-injection.html">ssl-ccs-injection</a>：允许MITM攻击的连接设置错误（<a href="http://ccsinjection.lepidum.co.jp/">ccs-injection-vuln</a>，<a href="https://www.tripwire.com/state-of-security/vulnerability-management/openssl-ccs-injection-primer/">ccs-injection-primer</a>）</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-cert-intaddr.html">ssl-cert-intaddr</a>：内部IP地址泄漏</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-date.html">ssl-date</a>：远程服务器时间泄漏</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-dh-params.html">ssl-dh-params</a>：使用弱<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman</a>参数</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-heartbleed.html">ssl-heartbleed</a>：易受OpenSSL <a href="https://www.us-cert.gov/ncas/alerts/TA14-098A">Heartbleed </a><a href="https://nmap.org/nsedoc/scripts/ssl-heartbleed.html">攻击</a></li><li><a href="https://nmap.org/nsedoc/scripts/ssl-known-key.html">ssl-known-key</a>：服务器正在使用已知的错误证书</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-poodle.html">ssl-poodle</a>：服务器允许易受攻击的SSLv3 CBC密码（<a href="https://www.us-cert.gov/ncas/alerts/TA14-290A">POODLE</a>）</li><li><a href="https://nmap.org/nsedoc/scripts/sslv2.html">sslv2</a>：服务器允许使用过时的SSLv2密码</li><li><a href="https://nmap.org/nsedoc/scripts/sslv2-drown.html">sslv2-drown</a>：服务器允许与<a href="https://www.us-cert.gov/ncas/current-activity/2016/03/01/SSLv2-DROWN-Attack">DROWN</a>攻击相关的SSLv2密码</li></ul><h2 id="4-testssl"><a href="#4-testssl" class="headerlink" title="4 testssl"></a>4 testssl</h2><p>testssl.sh是我们首选的测试工具，它涵盖了TLS和SSL评估所需的所有测试所需工具，并定期更新。</p><h3 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h3><pre><code>git clone https://github.com/drwetter/testssl.sh.git</code></pre><h3 id="4-2-testssl-sh示例"><a href="#4-2-testssl-sh示例" class="headerlink" title="4.2 testssl.sh示例"></a>4.2 testssl.sh示例</h3><p>有许多可以用于testssl.sh的测试选项，您应该使用的选项将在很大程度上取决于您的测试要求。以下是部分有关testssl.sh命令行选项的示例。运行./testssl.sh可以看到所有选项。详情见 <a href="https://testssl.sh/">https://testssl.sh/</a> </p><pre><code>[root@m01ly ~]#  cd testssl.sh[root@m01ly testssl.sh]# ./testssl.sh -e www.baidu.com</code></pre><h4 id="4-2-1-测试单个主机上的所有内容并输出到控制台"><a href="#4-2-1-测试单个主机上的所有内容并输出到控制台" class="headerlink" title="4.2.1 测试单个主机上的所有内容并输出到控制台"></a>4.2.1 测试单个主机上的所有内容并输出到控制台</h4><pre><code>./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST</code></pre><h4 id="4-2-2-测试单个主机上的所有内容并输出到HTML"><a href="#4-2-2-测试单个主机上的所有内容并输出到HTML" class="headerlink" title="4.2.2 测试单个主机上的所有内容并输出到HTML"></a>4.2.2 测试单个主机上的所有内容并输出到HTML</h4><pre><code>./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST | aha&gt; OUTPUT-FILE.html</code></pre><h4 id="4-2-3测试子网上的所有主机并输出到HTML"><a href="#4-2-3测试子网上的所有主机并输出到HTML" class="headerlink" title="4.2.3测试子网上的所有主机并输出到HTML"></a>4.2.3测试子网上的所有主机并输出到HTML</h4><pre><code>./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U 192.168.1.0/24 | aha&gt; OUTPUT-FILE.html</code></pre><p>与上述相同，但只列举每个服务器支持的密码类型：</p><pre><code>./testssl.sh -E 192.168.1.0/24 | aha&gt; OUTPUT-FILE.html</code></pre><p>还有很多功能。</p><h2 id="5-SSLyze"><a href="#5-SSLyze" class="headerlink" title="5 SSLyze"></a>5 SSLyze</h2><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><pre class="line-numbers language-bash"><code class="language-bash">$ pip <span class="token function">install</span> --upgrade setuptools$ pip <span class="token function">install</span> --upgrade sslyze<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><pre class="line-numbers language-bash"><code class="language-bash">$ python -m sslyze --regular www.yahoo.com:443 www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"> SCAN RESULTS FOR WWW.YAHOO.COM:443 - 202.165.107.50 --------------------------------------------------- * Deflate Compression:                                          OK - Compression disabled * SSLV3 Cipher Suites:      Server rejected all cipher suites. * TLSV1 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  * Session Renegotiation:       Client-initiated Renegotiation:    OK - Rejected       Secure Renegotiation:              OK - Supported * OpenSSL CCS Injection:                                          OK - Not vulnerable to OpenSSL CCS injection * SSLV2 Cipher Suites:      Server rejected all cipher suites. * Certificate Information:     Content       SHA1 Fingerprint:                  3672d010de4097e1d06898229df2821a1b49a2a1       Common Name:                       *.www.yahoo.com       Issuer:                            DigiCert SHA2 High Assurance Server CA       Serial Number:                     9093429354078714021559623999443547105       Not Before:                        2020-05-11 00:00:00       Not After:                         2020-11-07 12:00:00       Signature Algorithm:               sha256       Public Key Algorithm:              EllipticCurve       Key Size:                          256       Curve:                             secp256r1       DNS Subject Alternative Names:     <span class="token punctuation">[</span>u<span class="token string">'yahoo.com'</span>, u<span class="token string">'*.yahoo.com'</span>, u<span class="token string">'*.www.yahoo.com'</span>, u<span class="token string">'mbp.yimg.com'</span>, u<span class="token string">'*.media.yahoo.com'</span>, u<span class="token string">'brb.yahoo.net'</span>, u<span class="token string">'*.att.yahoo.com'</span>, u<span class="token string">'s.yimg.com'</span>, u<span class="token string">'*.amp.yimg.com'</span>, u<span class="token string">'fr-ca.rogers.yahoo.com'</span>, u<span class="token string">'tw.rd.yahoo.com'</span>, u<span class="token string">'ddl.fp.yahoo.com'</span>, u<span class="token string">'ca.rogers.yahoo.com'</span>, u<span class="token string">'ca.my.yahoo.com'</span>, u<span class="token string">'add.my.yahoo.com'</span>, u<span class="token string">'*.global.vespa.oath.cloud'</span>, u<span class="token string">'hk.rd.yahoo.com'</span><span class="token punctuation">]</span>     Trust       Hostname Validation:               OK - Certificate matches www.yahoo.com       Android CA Store <span class="token punctuation">(</span>8.1.0_r9<span class="token punctuation">)</span>:       OK - Certificate is trusted       iOS CA Store <span class="token punctuation">(</span>11<span class="token punctuation">)</span>:                 OK - Certificate is trusted       Java CA Store <span class="token punctuation">(</span>jre-10.0.2<span class="token punctuation">)</span>:        OK - Certificate is trusted       macOS CA Store <span class="token punctuation">(</span>High Sierra<span class="token punctuation">)</span>:      OK - Certificate is trusted       Mozilla CA Store <span class="token punctuation">(</span>2018-04-12<span class="token punctuation">)</span>:     OK - Certificate is trusted       Windows CA Store <span class="token punctuation">(</span>2018-06-30<span class="token punctuation">)</span>:     OK - Certificate is trusted       Symantec 2018 Deprecation:         OK - Not a Symantec-issued certificate       Received Chain:                    *.www.yahoo.com --<span class="token operator">></span> DigiCert SHA2 High Assurance Server CA       Verified Chain:                    *.www.yahoo.com --<span class="token operator">></span> DigiCert SHA2 High Assurance Server CA --<span class="token operator">></span> DigiCert High Assurance EV Root CA       Received Chain Contains Anchor:    OK - Anchor certificate not sent       Received Chain Order:              OK - Order is valid       Verified Chain contains SHA1:      OK - No SHA1-signed certificate <span class="token keyword">in</span> the verified certificate chain     Extensions       OCSP Must-Staple:                  NOT SUPPORTED - Extension not found       Certificate Transparency:          WARNING - Only 2 SCTs included but Google recommends 3 or <span class="token function">more</span>     OCSP Stapling       OCSP Response Status:              successful       Validation w/ Mozilla Store:       OK - Response is trusted       Responder Id:                      5168FF90AF0207753CCCD9656462A212B859723B       Cert Status:                       good       Cert Serial Number:                06D754AE96D28371A4DEF60AC211B3E1       This Update:                       Aug 19 15:03:00 2020 GMT       Next Update:                       Aug 26 14:18:00 2020 GMT * Resumption Support:      With Session IDs:                  NOT SUPPORTED <span class="token punctuation">(</span>0 successful, 5 failed, 0 errors, 5 total attempts<span class="token punctuation">)</span>.      With TLS Tickets:                  OK - Supported * TLSV1_1 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  * TLSV1_3 Cipher Suites:      Server rejected all cipher suites. * OpenSSL Heartbleed:                                          OK - Not vulnerable to Heartbleed * Downgrade Attacks:       TLS_FALLBACK_SCSV:                 OK - Supported * ROBOT Attack:                                          OK - Not vulnerable * TLSV1_2 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        RSA_WITH_AES_256_CCM_8                            -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256       -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384           ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_256_CCM                              -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA256                   -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384             ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_256_CCM                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384           ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384             ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256     -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_256_CCM_8                    -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_GCM_SHA384                   -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_128_CCM_8                            -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_128_CCM                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_128_CCM                              -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_128_CCM_8                    -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256             ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA256                   -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_GCM_SHA256                   -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256             ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  SCAN COMPLETED IN 7.29 S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-TLSSLed"><a href="#6-TLSSLed" class="headerlink" title="6 TLSSLed"></a>6 TLSSLed</h2><p>该工具是基于sslscan的脚本工具，使用非常简单。用户可以一次性执行所有检测任务，并且会生成详细的日志文件。它可以检测支持的协议类型、空密码和弱密码以及强密码等功能。</p><pre><code>[root@localhost ~]# yum install tlssled[root@localhost ~]# tlssled [ip/domain] 443</code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tlssled www.baidu.com 443</span>------------------------------------------------------ TLSSLed - <span class="token punctuation">(</span>1.3<span class="token punctuation">)</span> based on sslscan and openssl                 by Raul Siles <span class="token punctuation">(</span>www.taddong.com<span class="token punctuation">)</span>------------------------------------------------------    openssl version: OpenSSL 1.1.1g  21 Apr 2020    sslscan version 1.10.2 ------------------------------------------------------    Date: 20200821-110138------------------------------------------------------<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Analyzing SSL/TLS on www.baidu.com:443 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Output directory: TLSSLed_1.3_www.baidu.com_443_20200821-110138 <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Checking <span class="token keyword">if</span> the target <span class="token function">service</span> speaks SSL/TLS<span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> The target <span class="token function">service</span> www.baidu.com:443 seems to speak SSL/TLS<span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Using SSL/TLS protocol version:         <span class="token punctuation">(</span>empty means I'm using the default openssl protocol version<span class="token punctuation">(</span>s<span class="token punctuation">))</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Running sslscan on www.baidu.com:443 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSLv2 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the NULL cipher <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> weak ciphers <span class="token punctuation">(</span>based on key length - 40 or 56 bits<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> strong ciphers <span class="token punctuation">(</span>based on AES<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    Accepted  TLSv1  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLSv1  256 bits  AES256-SHA    Accepted  TLSv1  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLSv1  128 bits  AES128-SHA    Accepted  TLS11  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLS11  256 bits  AES256-SHA    Accepted  TLS11  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLS11  128 bits  AES128-SHA    Accepted  TLS12  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLS12  256 bits  AES256-SHA    Accepted  TLS12  128 bits  ECDHE-RSA-AES128-GCM-SHA256    Accepted  TLS12  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLS12  128 bits  AES128-SHA    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> MD5 signed certificate <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate public key length <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate subject <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate CA issuer <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate validity period <span class="token punctuation">..</span>.    Today: Fri Aug 21 03:02:05 UTC 2020    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Checking preferred server ciphers <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSL/TLS renegotiation MitM vuln. <span class="token punctuation">(</span>CVE-2009-3555<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> secure renegotiation support <span class="token punctuation">(</span>RFC 5746<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    Secure Renegotiation IS supported<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSL/TLS renegotiation DoS vuln. <span class="token punctuation">(</span>CVE-2011-1473<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client initiated <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation <span class="token punctuation">(</span>secure<span class="token punctuation">)</span><span class="token punctuation">..</span>.    <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation IS NOT enabled <span class="token punctuation">(</span>no renegotiation<span class="token punctuation">)</span>    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client initiated <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation <span class="token punctuation">(</span>insecure<span class="token punctuation">)</span><span class="token punctuation">..</span>.    <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation IS NOT enabled <span class="token punctuation">(</span>no renegotiation<span class="token punctuation">)</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client authentication using digital certificates <span class="token punctuation">..</span>.    SSL/TLS client certificate authentication IS NOT required<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.1 and v1.2 <span class="token punctuation">(</span>CVE-2011-3389 vuln. aka BEAST<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSLv3 and TLSv1 support <span class="token punctuation">..</span>.    Accepted  SSLv3  112 bits  RC4-SHA    Accepted  TLSv1  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLSv1  256 bits  AES256-SHA    Accepted  TLSv1  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLSv1  128 bits  AES128-SHA    Accepted  TLSv1  112 bits  ECDHE-RSA-RC4-SHA    Accepted  TLSv1  112 bits  RC4-SHA    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> RC4 <span class="token keyword">in</span> the prefered cipher<span class="token punctuation">(</span>s<span class="token punctuation">)</span> list <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.1 support <span class="token punctuation">..</span>.    TLS v1.1 IS supported    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.2 support <span class="token punctuation">..</span>.    TLS v1.2 IS supported<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTPS <span class="token punctuation">(</span>SSL/TLS<span class="token punctuation">)</span> security headers using HTTP/1.0 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTP Strict-Transport-Security <span class="token punctuation">(</span>HSTS<span class="token punctuation">)</span> header <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies with the secure flag <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies without the secure flag <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTPS <span class="token punctuation">(</span>SSL/TLS<span class="token punctuation">)</span> security headers using HTTP/1.1 <span class="token operator">&amp;</span> Host <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTP Strict-Transport-Security <span class="token punctuation">(</span>HSTS<span class="token punctuation">)</span> header <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies with the secure flag <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies without the secure flag <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> New files created:    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Output directory: TLSSLed_1.3_www.baidu.com_443_20200821-110138 <span class="token punctuation">..</span>.openssl_HEAD_1.0_www.baidu.com_443_20200821-110138.err    openssl_HEAD_www.baidu.com_443_20200821-110138.log        openssl_RENEG_www.baidu.com_443_20200821-110138.erropenssl_HEAD_1.0_www.baidu.com_443_20200821-110138.log    openssl_RENEG_LEGACY_www.baidu.com_443_20200821-110138.err  openssl_RENEG_www.baidu.com_443_20200821-110138.logopenssl_HEAD_www.baidu.com_443_20200821-110138.err    openssl_RENEG_LEGACY_www.baidu.com_443_20200821-110138.log  sslscan_www.baidu.com_443_20200821-110138.log<span class="token punctuation">[</span>*<span class="token punctuation">]</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-openssl"><a href="#7-openssl" class="headerlink" title="7 openssl"></a>7 openssl</h2><pre><code> openssl s_client -connect www.baidu.com:443　　【s_client:作为一个客户端 -connect：连接 +服务器域名:端口】 </code></pre><p><img src="/2020/08/26/htps-tools/1598432415793.png" alt="1598432415793"></p><p><img src="/2020/08/26/htps-tools/1596439698251.png" alt="1596439698251"></p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p> <a href="https://blog.csdn.net/qq_42696904/article/details/85267927?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_42696904/article/details/85267927?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242</a> </p><p> <a href="https://github.com/nabla-c0d3/sslyze">https://github.com/nabla-c0d3/sslyze</a> </p><p> <a href="https://nabla-c0d3.github.io/sslyze/documentation/">https://nabla-c0d3.github.io/sslyze/documentation/</a> </p><p> <a href="https://www.freebuf.com/sectool/99151.html">https://www.freebuf.com/sectool/99151.html</a> </p><p> <a href="https://www.infinisign.com/faq/tls-ssl-security-testing">https://www.infinisign.com/faq/tls-ssl-security-testing</a> </p><p> <a href="https://testssl.sh/">https://testssl.sh/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建https网站</title>
      <link href="/2020/08/26/htps-build/"/>
      <url>/2020/08/26/htps-build/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>环境：centos 7</p><p>nginx 版本：1.19.1</p><h2 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1 安装nginx"></a>1 安装nginx</h2><p>按照 <a href="https://www.runoob.com/linux/nginx-install-setup.html">https://www.runoob.com/linux/nginx-install-setup.html</a> 教程安装即可，记得安装最新版。</p><pre><code>wget http://nginx.org/download/nginx-1.19.1.tar.gz</code></pre><p>nginx安装目录配置 nginx.conf 如下：/usr/local/webserver/nginx/conf</p><h2 id="2-自签名证书"><a href="#2-自签名证书" class="headerlink" title="2 自签名证书"></a>2 自签名证书</h2><h3 id="2-1-CA根证书的生成步骤"><a href="#2-1-CA根证书的生成步骤" class="headerlink" title="2.1 CA根证书的生成步骤"></a>2.1 CA根证书的生成步骤</h3><p>新建一个文件夹ssl</p><pre><code>mkdir sslcd ssl</code></pre><h4 id="2-1-1-生成私钥"><a href="#2-1-1-生成私钥" class="headerlink" title="2.1.1 生成私钥"></a>2.1.1 <strong>生成私钥</strong></h4><p>生成CA私钥（.key）–&gt;生成CA证书请求（.csr）–&gt;自签名得到根证书（.crt）（CA给自已颁发的证书）。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property"># Generate CA private key </span>openssl genrsa <span class="token operator">-</span><span class="token keyword">out</span> ca<span class="token punctuation">.</span>key <span class="token number">2048</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/08/26/htps-build/1597046435726.png" alt="1597046435726"></p><h4 id="2-1-2-生成证书请求文件"><a href="#2-1-2-生成证书请求文件" class="headerlink" title="2.1.2   生成证书请求文件"></a>2.1.2   <strong>生成证书请求文件</strong></h4><p> 这个过程会要求输入很多信息如国家、城市、组织信息等，其中 <code>Common Name (eg, your name or your server&#39;s hostname)</code> 是 <strong>必填项</strong> ，可以是域名或者 IP，其他都可以回车跳过，但是这样的话在签名证书时候会报错，下一章详述，不过自签名证书不影响。 </p><pre><code># Generate CSR openssl req -new -key ca.key -out ca.csr</code></pre><p><img src="/2020/08/26/htps-build/1597046507003.png" alt="1597046507003"></p><h4 id="2-1-3-生成自签名证书"><a href="#2-1-3-生成自签名证书" class="headerlink" title="2.1.3    生成自签名证书"></a>2.1.3    <strong>生成自签名证书</strong></h4><pre><code># Generate Self Signed certificate（CA 根证书）openssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt</code></pre><p><img src="/2020/08/26/htps-build/1597046586371.png" alt="1597046586371"></p><h3 id="2-2-用户证书的生成步骤"><a href="#2-2-用户证书的生成步骤" class="headerlink" title="2.2 用户证书的生成步骤"></a>2.2 用户证书的生成步骤</h3><h4 id="2-2-1-生成私钥"><a href="#2-2-1-生成私钥" class="headerlink" title="2.2.1. 生成私钥"></a><strong>2.2.1. 生成私钥</strong></h4><p>生成私钥（.key）–&gt;生成证书请求（.csr）–&gt;用CA根证书签名得到证书（.crt）</p><p>服务器端用户证书：</p><pre class="line-numbers language-html"><code class="language-html"># private key$openssl genrsa -des3 -out server.key 1024 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/08/26/htps-build/1597046728463.png" alt="1597046728463"></p><h4 id="2-2-2-生成证书请求"><a href="#2-2-2-生成证书请求" class="headerlink" title="2.2.2 生成证书请求"></a>2.2.2 生成证书请求</h4><pre><code># generate csr$openssl req -new -key server.key -out server.csr</code></pre><p><img src="/2020/08/26/htps-build/1597046781761.png" alt="1597046781761"></p><h4 id="2-2-3-生成证书（根证书对用户的证书请求签名，最终生成用户证书）"><a href="#2-2-3-生成证书（根证书对用户的证书请求签名，最终生成用户证书）" class="headerlink" title="2.2.3  生成证书（根证书对用户的证书请求签名，最终生成用户证书）"></a>2.2.3  <strong>生成证书（根证书对用户的证书请求签名，最终生成用户证书）</strong></h4><p> 使用 <code>x509</code> 工具生成证书，因为它默认不使用 <code>openssl.cnf</code> </p><pre><code># generate certificate$openssl x509 -req -in server.csr -CA ca.crt \ -CAkey ca.key -out server.crt -CAcreateserial</code></pre><p><img src="/2020/08/26/htps-build/1597046922337.png" alt="1597046922337"></p><h4 id="2-2-4-验证证书有效性"><a href="#2-2-4-验证证书有效性" class="headerlink" title="2.2.4  验证证书有效性"></a>2.2.4  验证证书有效性</h4><pre><code>openssl verify -CAfile ca.crt server.crt</code></pre><p><img src="/2020/08/26/htps-build/1597047002938.png" alt="1597047002938"></p><h4 id="2-2-5-导出证书"><a href="#2-2-5-导出证书" class="headerlink" title="2.2.5 导出证书"></a>2.2.5 导出证书</h4><pre><code>cat server.crt server.key &gt; server.pem</code></pre><p><img src="/2020/08/26/htps-build/1597047735585.png" alt="1597047735585"></p><h2 id="3-配置nginx"><a href="#3-配置nginx" class="headerlink" title="3 配置nginx"></a>3 配置nginx</h2><p>将openssl生成的证书文件复制到nginx的目录下：</p><pre><code>[root@localname ~]#  cp -r ssl  /usr/local/webserver/nginx/conf/ssl</code></pre><h4 id="3-1-1-配置nginx-conf文件"><a href="#3-1-1-配置nginx-conf文件" class="headerlink" title="3.1.1 配置nginx.conf文件"></a>3.1.1 配置nginx.conf文件</h4><p>配置/usr/local/webserver/nginx/conf目录下的nginx.conf文件</p><pre><code>vim  /usr/local/webserver/nginx/conf/nginx.conf</code></pre><p>修改文件如下：</p><p><img src="/2020/08/26/htps-build/1597047296881.png" alt="1597047296881"></p><pre><code>server  &#123;    listen 443;#监听端口    server_name 192.168.10.136;#域名    index index.html index.htm index.php;    root /usr/local/webserver/nginx/html;#站点目录   #注意这些路径是相对于/etc/nginx/nginx.conf文件位置    ssl on;    ssl_certificate ssl/server.crt;    ssl_certificate_key ssl/server.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;    location ~ .*\.(php|php5)?$    &#123;      #fastcgi_pass unix:/tmp/php-cgi.sock;      fastcgi_pass 127.0.0.1:9000;      fastcgi_index index.php;      include fastcgi.conf;    &#125;    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$    &#123;      expires 30d;  # access_log off;    &#125;    location ~ .*\.(js|css)?$    &#123;      expires 15d;   # access_log off;    &#125;    access_log off;  &#125;</code></pre><h4 id="3-1-2-测试-停止-重启nginx服务"><a href="#3-1-2-测试-停止-重启nginx服务" class="headerlink" title="3.1.2  测试 /停止/重启nginx服务"></a>3.1.2  测试 /停止/重启nginx服务</h4><p>编译/usr/local/webserver/nginx/sbin/nginx  -t</p><p><img src="/2020/08/26/htps-build/1597044719436.png" alt="1597044719436"></p><p>重启  nginx：/usr/local/webserver/nginx/sbin/nginx  -s stop</p><p>启动：/usr/local/webserver/nginx/sbin/nginx</p><p>浏览器输入（本机ip地址）：<a href="https://192.168.10.136/">https://192.168.10.136/</a></p><p><img src="/2020/08/26/htps-build/1597044598226.png" alt="1597044598226"></p><p><img src="/2020/08/26/htps-build/1597044868039.png" alt="1597044868039"></p><p>这时候发现浏览器提示不安全的链接,这个时候将根证书ca.crt导入浏览器,重启,发现提示消失了.</p><h2 id="4-nginx日常操作命令"><a href="#4-nginx日常操作命令" class="headerlink" title="4 nginx日常操作命令"></a>4 nginx日常操作命令</h2><p>nginx -t 测试配置文件<br>nginx -s reload 修改配置后重载生效<br>nginx -s reopen 重新打开日志文件<br>nginx -s stop 快速停止<br>nginx -s quit</p><p>查看nginx进程<br>ps -ef | grep nginx</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.gokuweb.com/operation/d95eae05.html">https://www.gokuweb.com/operation/d95eae05.html</a><br><a href="https://blog.csdn.net/liuchunming033/article/details/48470575">https://blog.csdn.net/liuchunming033/article/details/48470575</a> </p><p><a href="https://juejin.im/post/6844903729632641031">https://juejin.im/post/6844903729632641031</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https/TLS1.2详解</title>
      <link href="/2020/08/26/apple/"/>
      <url>/2020/08/26/apple/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-https"><a href="#1-https" class="headerlink" title="1  https"></a>1  https</h2><p><strong>SSL</strong>(Secure Sockets Layer) 安全套接层，是一种安全协议，经历了 SSL 1.0、2.0、3.0 版本后发展成了标准安全协议 - <strong>TLS</strong>(Transport Layer Security) 传输层安全性协议。TLS 有 1.0 (RFC 2246)、1.1(RFC 4346)、1.2(RFC 5246)、1.3(RFC 8446) 版本。</p><img src="/2020/08/26/apple/1597202957092.png" alt="1597202957092" style="zoom: 50%;"><h3 id="1-1-安全协议必备元素"><a href="#1-1-安全协议必备元素" class="headerlink" title="1.1 安全协议必备元素"></a>1.1 安全协议必备元素</h3><p>在一个不安全的信道传输，我们需要保证三点:</p><p>(1)一是保证数据来源可靠性(身份认证)及在通信过程中数据的完整性（防篡改和防伪造），有数字签名和HMAC两种做法。数字签名是用私钥对报文进行签名生成数字签名，然后公钥对数字签名进行验证，常见的有SM2，RSA等；HMAC是通信两边用同一个密钥，运行常见的哈希函数MD5，SHA-1等进行哈希运算生成字符串，然后两边生成的字符串进行比较。具体细节，请参见XXXXXXXXX。</p><p>(2)另外一种是保证数据机密性，即对数据进行加密传输，加密算法分为对称算法和非对称算法，非对称算法有两个密钥，公钥加密，私钥解密，安全性较高，但加解密速度较慢，例如RSA加密算法；对称算法只有一个密钥，对称算法又分流加密（CR4等）和分组密码算法（AES，3DES等），流加密速度更快，相比于非对称加密，对称算法加解密速度较快，安全性较低。</p><p>(3)防重放:加入新鲜因子,随机数等.</p><img src="/2020/08/26/apple/1597634074757.png" alt="1597634074757" style="zoom: 67%;"><p>因此通常一个安全协议的设计需要满足基础三点，保证数据完整性（防篡改）和机密性，综合效率及安全性分析，通常的做法是将对称算法与非对称算法结合使用，即利用非对称算法协商出一个会话密钥，然后会话密钥作为对称算法的密钥进行加密，HMAC运行。</p><h3 id="1-2-TSL-协议体系结构"><a href="#1-2-TSL-协议体系结构" class="headerlink" title="1.2 TSL 协议体系结构"></a>1.2 TSL 协议体系结构</h3><img src="/2020/08/26/apple/1597635119718.png" alt="1597635119718" style="zoom:80%;"><p>TLS的体系结构中包含两个协议子层，其中底层是SSL记录协议层（SSL Record Protocol Layer）；高层是SSL握手协议层（SSL HandShake Protocol Layer）。</p><p>TLS协议主要分为两层：</p><p>(1) TLS记录协议层的作用是为高层协议提供基本的安全服务。TLS记录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在TLS运行。纪录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</p><p>(2) TLS握手协议层包括握手协议（HandShake Protocol）、密码参数修改协议（Change Cipher Spec Protocol）和告警协议（Alert Protocol）。握手层的这些协议用于管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。</p><p>其中最重要的是记录协议和握手协议：</p><p>(1) TLS记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。</p><p>(2) TLS握手协议：它建立在TLS记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p>如下图所示,可以看到TLS握手层是建立在TLS记录层之上的。</p><p><img src="/2020/08/26/apple/1597635346378.png" alt="1597635346378"></p><h3 id="1-3-TLS密码套件结构"><a href="#1-3-TLS密码套件结构" class="headerlink" title="1.3 TLS密码套件结构"></a>1.3 TLS密码套件结构</h3><p><img src="/2020/08/26/apple/1597654968578.png" alt="1597654968578"></p><p>密码套件是客户端与服务器约定交互过程中需要的密码算法系列，如上图所示，以TLS开头，</p><p>（1）第一个参数为密钥交换算法，即协商预主密钥pre-master key所用的算法，主要有两类。分别是</p><p>（a）基于Diffie-Hellman交换算法的：ECDHE，DHE，DH，ECDH</p><p>DH密钥交换原理如下图,图中的k即为pre-master key:</p><img src="/2020/08/26/apple/1597651450749.png" alt="1597651450749" style="zoom:67%;"><p>DH和ECDH主要不同在于基于的困难问题稍有不同，DH是基于离散对数困难问题，而ECDH是基于椭圆曲线上的离散对数问题；任何基于离散对数上的都可以换算到椭圆曲线上。椭圆曲线上密钥长度只需要较短的即可达到基础域中较长的安全性，例如160比特的椭圆曲线密钥和1024比特的RSA密钥的安全性相当。越小的密钥在速度、效率、带宽、存储上有着许多优势 。</p><p>对于DHE与DH的主要不同在于后面有个E，E代表了“临时”，即在握手流程中，作为服务器端，ECDH少了一步计算Pb的过程，Pb用证书中的公钥代替，而证书对应的私钥就是Xb。由此可见，使用ECDH密钥交换算法，服务器必须采用ECC证书；服务器不发送server key exchange报文，因为发送certificate报文时，证书本身就包含了Pb信息。 </p><p>（b）基于RSA的密钥交换算法：客户端利用RSA公钥加密pre-master key，服务器端私钥解密出预主密钥</p><img src="/2020/08/26/apple/1597651364544.png" alt="1597651364544" style="zoom: 67%;"><p>综上几种密钥交换算法比较如下表所示:</p><table><thead><tr><th></th><th>ECDHE</th><th>ECDH</th><th>DHE</th><th>DH</th><th>RSA</th></tr></thead><tbody><tr><td>server key exchange</td><td>Y</td><td>N（证书中的公钥Pb）</td><td>Y</td><td>N（证书中的公钥及Pb）</td><td>N</td></tr><tr><td>前向安全性</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><p>（2）第二部分为身份认证算法，即数字签名算法，这里根据密码套件不同，代表的含义也不同。</p><p>（a）密钥交换算法为ECDHE情况下，签名算法指的是 serverkeyexchange被签名的算法，只有2种ECDSA和RSA，具体是哪种完全取决于证书的公钥类型（ECC RSA）。如果你的证书是ECC公钥，那么服务器不可能选择ECDHE_RSA这种套件。 </p><p>（b）ECDH的情况下，签名算法 指的是 证书自身的被签名算法。 如果服务器部署的是RSA签名算法的证书，那么必须使用ECDH_RSA套件；反之亦然。 </p><p>（3）第三部分AES_128_GCM，主要为加密算法，一般是加密算法+加密强度（128位/256位）+工作模式（CBC/GCM），用于后面加密传输所用的算法，保证数据传输过程中的机密性。</p><p>（4） 第四部分SHA256为哈希算法，用于HMAC和PRF，保证数据在传输过程中的完整性。</p><h2 id="2-https协议总框架"><a href="#2-https协议总框架" class="headerlink" title="2 https协议总框架"></a>2 https协议总框架</h2><p>如下图为https协议总框架,首先</p><p>非对称协商会话密钥，然后用会话密钥加密传输。</p><img src="/2020/08/26/apple/1597630781001.png" alt="1597630781001" style="zoom:67%;"><p>下面以具体wireshark抓包具体报文进行解说。（密码套件TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256为例）拦截<a href="http://www.google.com的https连接报文.其中2.1到2.6为握手层协议,2.7为记录协议/">www.google.com的https连接报文。其中2.1到2.6为握手层协议,2.7为记录协议</a>.</p><h3 id="2-1-Client-hello"><a href="#2-1-Client-hello" class="headerlink" title="2.1 Client hello"></a>2.1 Client hello</h3><p>这条消息是客户端向服务器端发送连接请求。</p><p><img src="/2020/08/26/apple/1597635473766.png" alt="1597635473766"></p><p>Version: 协议版本（protocol version）指示客户端支持的最佳协议版本</p><p>Random: 一个 32 字节数据，28 字节是随机生成的 (图中的 Random Bytes)；剩余的 4 字节包含额外的信息，与客户端时钟有关 (图中使用的是 GMT Unix Time)。在握手时，客户端和服务器都会提供随机数，客户端的暂记作 random_C (用于后续的密钥的生成)。这种随机性对每次握手都是独一无二的，在身份验证中起着举足轻重的作用。它可以防止 <a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>，并确认初始数据交换的完整性。</p><p>Session ID: 在第一次连接时，会话 ID（session ID）字段是空的，这表示客户端并不希望恢复某个已存在的会话。典型的会话 ID 包含 32 字节随机生成的数据，一般由服务端生成通过 ServerHello 返回给客户端。</p><p>Cipher Suites: 密码套件（cipher suite）块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的.</p><pre><code>Cipher Suites (19 suites)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xc024)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (0xc028)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xc00a)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)    Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)    Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)    Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA256 (0x003d)    Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c)    Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)    Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)    Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</code></pre><p>Compression: 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是 null，代表没有压缩</p><p>Extensions: 扩展（extension）块由任意数量的扩展组成。这些扩展会携带额外数据</p><h3 id="2-2-Server-hello"><a href="#2-2-Server-hello" class="headerlink" title="2.2 Server hello"></a>2.2 Server hello</h3><p>这条消息是服务器对client hello的响应。</p><p><img src="/2020/08/26/apple/1597635614246.png" alt="1597635614246"></p><p>这个消息的结构与 ClientHello 类似，只是每个字段只包含一个选项，其中包含服务端的 random_S 参数 (用于后续的密钥协商)。服务器无需支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受。</p><p>图中的 <code>Cipher Suite</code> 是后续密钥协商和身份验证要用的加密套件TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256，此处选择的密钥交换与签名算法是 ECDHE_RSA，对称加密算法是 AES-128，后面会讲到这个</p><p>还有一点默认情况下 TLS 压缩都是关闭的，因为 <a href="https://zh.wikipedia.org/wiki/CRIME">CRIME</a> 攻击会利用 TLS 压缩恢复加密认证 cookie，实现会话劫持，而且一般配置 gzip 等内容压缩后再压缩 TLS 分片效益不大又额外占用资源，所以一般都关闭 TLS 压缩</p><h3 id="2-3-Certificate"><a href="#2-3-Certificate" class="headerlink" title="2.3 Certificate"></a>2.3 Certificate</h3><p>典型的 Certificate 消息用于携带服务器 X.509 <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88">证书链</a>。 服务器必须保证它发送的证书与选择的算法套件一致。</p><p><img src="/2020/08/26/apple/1597645649605.png" alt="1597645649605"></p><h4 id="2-3-1-证书内容"><a href="#2-3-1-证书内容" class="headerlink" title="2.3.1 证书内容"></a>2.3.1 证书内容</h4><p>注意证书链的顺序，最下层证书在前（用户证书在前，上级证书在后）。发送的证书是二进制格式，并非base64之后的格式。有个技巧，在wireshark右键<strong>“导出分组字节流”</strong>功能，然后保存证书,后缀为der，是可以变成一个正常证书的（二进制格式）。</p><img src="/2020/08/26/apple/1597648718865.png" alt="1597648718865" style="zoom:150%;"><p>下面对证书内容进行分析：</p><p>图中从右到左分别是1级根证书为Google Trust Services，二级中间证书为GTS CA，三级证书为google-analytics；从上到下为每个证书中的详细信息。</p><p>首先需要特别说明证书中的重点内容是什么？</p><p>（1）版本：Version，V3。对应的是X.509 V3标准</p><p>（2）序列号：证书颁发者唯一序列号</p><p>（3）签名算法：<strong>注意！证书中的签名算法指的是上级证书运行的签名算法，生成数字签名的；而不是</strong></p><p><strong>本级证书拥有的签名算法。</strong>例如，3级证书中的签名算法为sha256RSA，应该与2级证书的公钥RSA是一致的。</p><p>（４）签名哈希算法：同样是上级证书签名时用的哈希算法。</p><p>（５）公钥及公钥参数:<strong>注意本即证书的公钥，该公钥不是用于验证2级证书生成的数字签名的.**该公钥是用于后面</strong>server key exchange的;具体用法如下:</p><p>(a)对于ECDHE和DHE密钥交换算法,服务器端需要server key exchange,发送用于DH的公钥Pb及对公钥的数字签名(防止公钥在通信过程被篡改),那服务器证书的公钥就是用来验证该签名的;</p><p>(b)对于不需要server key exchange的DH,ECDH密钥交换算法,服务器证书中的公钥就是DH密钥交换的Pb;</p><p>(c) 对于不需要server key exchange的RSA密钥交换算法:服务器证书中的公钥是用于加密第三个随机数预主密钥pre-master key的.</p><h4 id="2-3-2-证书验证过程"><a href="#2-3-2-证书验证过程" class="headerlink" title="2.3.2 证书验证过程"></a>2.3.2 证书验证过程</h4><p>证书链验证过程如下:(简易图)</p><p>首先利用一级证书中的RSA公钥验证二级证书,再用二级证书中的RSA公钥验证三级证书,即服务器证书;服务器证书中的ECC公钥,公钥参数ECDSA用于密钥交换,具体功能在2.3.1已阐述;</p><p><img src="/2020/08/26/apple/1597651071958.png" alt="1597651071958"></p><h3 id="2-4-第三个随机数的密钥协商"><a href="#2-4-第三个随机数的密钥协商" class="headerlink" title="2.4  第三个随机数的密钥协商"></a>2.4  第三个随机数的密钥协商</h3><p>不同的密码套件,也会有不一样的密钥协商算法具体1.3节已分析;该次交互选择的密码交互算法为ECDHE_ECDSA;</p><h4 id="2-4-1-Server-key-exchange"><a href="#2-4-1-Server-key-exchange" class="headerlink" title="2.4.1 Server key exchange"></a>2.4.1 Server key exchange</h4><p>从下面可以看到报文信息如下:</p><p>(1)公钥Pubkey:服务器端发送Pb(对应的私钥为b),以及DH用到的相关参数,比如选择的椭圆曲线等</p><p>(2)数字签名Signature:服务器利用私钥b运行ECDSA签名算法生成的数字签名,保证公钥来源的可靠性和完整性,客户端收到该签名后,用之前收到的服务器证书中的ECC公钥进行签名验证.</p><p><img src="/2020/08/26/apple/1597651555493.png" alt="1597651555493"></p><h4 id="2-4-2-Client-key-exchange"><a href="#2-4-2-Client-key-exchange" class="headerlink" title="2.4.2 Client key exchange"></a>2.4.2 Client key exchange</h4><p>客户端发送公钥Pa</p><p><img src="/2020/08/26/apple/1597652043883.png" alt="1597652043883"></p><p>然后双方根据Diffie-Hellman算法分别计算出pre-master key;具体计算过程在1.3已写.</p><h3 id="2-5-Finished-Encrypted-Handshake-Message"><a href="#2-5-Finished-Encrypted-Handshake-Message" class="headerlink" title="2.5 Finished (Encrypted Handshake Message)"></a>2.5 Finished (Encrypted Handshake Message)</h3><p>这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据，发送了什么数据。来保证中间没人篡改报文。客户端和服务器端都会分别发送.</p><p>其次，这个报文作用就是确认密钥的正确性。因为Encrypted handshake message是使用对称密钥进行加密的第一个报文，如果这个报文加解密校验成功，那么就说明对称密钥是正确的。</p><p>计算方法也比较简单，将之前<strong>所有</strong>的握手数据（包括接受、发送），计算md运算，然后计算prf，然后就是使用协商好的对称密钥进行加密了。 ( 从client hello开始，到目前准备发送“Encrypted handshake message”前，自己所有收到和发送的handshake类型的握手数据。 )</p><p><img src="/2020/08/26/apple/1597653653860.png" alt="1597653653860"></p><h3 id="2-6-密钥产生"><a href="#2-6-密钥产生" class="headerlink" title="2.6 密钥产生"></a>2.6 密钥产生</h3><p><img src="/2020/08/26/apple/1597652305214.png" alt="1597652305214"></p><p>如上图所示,此时客户端,服务器端都已经获取全部的计算协商密钥需要的信息: 两个明文随机数 CR 和 SR与自己计算产生的 Pre-master，然后得到主密钥master.为了保证信息的完整性和机密性，TSL需要有六个密钥：四个密钥和两个IV。为了信息的可信性，客户端需要一个密钥（HMAC），为了加密要有一个密钥，为了分组加密要一个IV，服务也是如此。</p><pre><code>master= PRF(Pre_master, &quot;master secret&quot;, CR + SR)</code></pre><h4 id="2-6-1-生成主密钥Master-key"><a href="#2-6-1-生成主密钥Master-key" class="headerlink" title="2.6.1 生成主密钥Master key"></a>2.6.1 生成主密钥Master key</h4><p>主密钥Master key的生成如下,图中的MD5算法是在密码套件中指定的;根据三个参数预备主密钥PM,服务器端随机数SR,客户端随机数CR,经过不断的迭代,最终生成48字节的主密钥master key.</p><p><img src="/2020/08/26/apple/1598427741876.png" alt="1598427741876"></p><h4 id="2-6-2-生成密钥材料"><a href="#2-6-2-生成密钥材料" class="headerlink" title="2.6.2 生成密钥材料"></a>2.6.2 生成密钥材料</h4><p> 密钥材料需要以下6个,具体生成过程如下图所示.</p><p>(1)客户端MAC密钥 :Auth .Key</p><p>(2)服务器端MAC密钥 :Auth .Key</p><p>(3) 客户端加密密钥及IV:Enc.key</p><p>(4) 服务器端加密密钥及IV:Enc.key,IV</p><p>(5) 客户端分组密码需要的IV</p><p>(6) 服务器端分组密码需要的IV</p><p><img src="/2020/08/26/apple/1598427757814.png" alt="1598427757814"> </p><p><img src="/2020/08/26/apple/1598427767706.png" alt="1598427767706"></p><h3 id="2-7-记录协议"><a href="#2-7-记录协议" class="headerlink" title="2.7  记录协议"></a>2.7  记录协议</h3><p>记录协议负责在传输连接上交换的所有底层消息，并且可以配置加密。每一条 TLS 记录以一个短标头开始。标头包含记录内容的类型 (或子协议)、协议版本和长度。原始消息经过分段 (或者合并)、压缩、添加认证码、加密转为 TLS 记录的数据部分。 如下图所示.对应用数据进行分段,对分段信息先压缩,在加上对压缩进行的MAC,然后对压缩信息+MAC进行加密,最后加记录头,形成报文,发送.</p><p><img src="/2020/08/26/apple/1597653267305.png" alt="1597653267305"></p><p>报文如下:</p><p><img src="/2020/08/26/apple/1597653406484.png" alt="1597653406484"></p><h2 id="3-https-安全性分析"><a href="#3-https-安全性分析" class="headerlink" title="3 https 安全性分析"></a>3 https 安全性分析</h2><h3 id="3-1-TLS版本的选择"><a href="#3-1-TLS版本的选择" class="headerlink" title="3.1 TLS版本的选择"></a>3.1 TLS版本的选择</h3><p>目前在SSL/TLS家族中主要有7个协议: SSL v2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2和TLSv1.3。</p><p>1 SSL v2, SSL v3, TLS v1.0 , TLS v1.1协议均有明确的安全缺陷</p><ol><li><p>SSL v2: DROWN攻击</p></li><li><p>SSL v3: POODLE攻击</p></li><li><p>TLS v1.0: BEAST和POODLE攻击</p></li><li><p>TLS v1.1 密码套件较老,已不安全 </p></li></ol><p>2、TLS v1.2与v1.3目前均无已知的安全缺陷</p><p><strong>推荐使用TLS v1.2与v1.3.</strong></p><h3 id="3-2-密码套件的选择"><a href="#3-2-密码套件的选择" class="headerlink" title="3.2 密码套件的选择"></a>3.2 密码套件的选择</h3><p>从密码套件的各个部分去分析其安全性,具体如下:</p><p>(1)密钥交换：ECDHE，DHE，ECDH，DHE，ADH, RSA, PSK</p><p>其中RSA，ECDH，DH，PSK均不具有前向安全性，一旦私钥丢失，则以往所有的通信内容将会泄露，使用前向安全性算法（ECDHE，DHE），可以避免这种问题。</p><p>ADH为Anonymous DH，匿名DH算法，不提供身份验证，禁用。</p><p>PSK算法是预存key在客户端和服务端，因为PSK必须要预置密钥，这个预置的过程就代表了服务端已经知道有哪些客户端需要访问了，所以基于PSK的TLS适合在内部系统中使用，而不适合在公网环境用来提供Web服务。</p><p><strong>综上,推荐使用的密钥交换算法为:ECDHE，DHE</strong></p><p>(2)数字签名：ECDSA, RSA(2048位以上), DSS (又称DSA)</p><p>其中DSA只支持1024bits，不安全算法,RSA要2048位以上才安全.ECDSA速度较快,安全性也较高.</p><p><strong>推荐使用数字签名算法ECDSA和RSA.</strong></p><p>(3) 加密算法：<strong>DES，3DES ,**AES(256),ChaCha20</strong>,RC4, **ChaCha20</p><p>3DES运行缓慢且易被攻击。RC4已不安全</p><p>ChaCha20是一种流加密算法，实现较为简单，并且比纯软件实现的AES性能更好。</p><p>在支持AES指令的硬件平台上，推荐优先选择AES-GCM算法,不支持AES指令的硬件平台，ChaCha20性能优于AES</p><p>Camellia算法支持128比特的分组长度,128、192和256比特的密钥与AES的接口相同，Camellia算法128比特密钥的加、解密过程共有18轮,采用Feistel结构,加、解密过程完全相同,只是子密钥注入顺序相反</p><p>Camellia算法由NTT和Mitsubishi Electric Corporation于2000年联合开发，作为欧洲新一代的加密标准。与AES算法相比,Camellia算法在各种软硬件平台上表现出与之相当的加密速度。除了在各种软件和硬件平台上的高效性这一显著特点,它的另外一个特点是针对小规模硬件平台的设计.</p><p><strong>推荐使用AES(256),ChaCha20ChaCha20</strong></p><p>(4)<strong>工作模式：</strong>CBC，GCM</p><p>CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击,禁用</p><p><strong>推荐使用:GCM</strong></p><p>(5)MAC：md5，SHA-1（又名SHA），SHA-2（又名SHA128，SHA256和SHA384）</p><p>​     SHA1存在碰攻击，如果HTTPS证书使用sha1，扩展存在中间人攻击；  Md5也被破解</p><p><strong>推荐使用SHA256和SHA384</strong></p><h3 id="3-3-优先使用的密码套件"><a href="#3-3-优先使用的密码套件" class="headerlink" title="3.3 优先使用的密码套件"></a>3.3 优先使用的密码套件</h3><p>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384<br>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF:"></a>REF:</h2><p> <a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</a> </p><p> <a href="https://juejin.im/post/6844903667577929742#heading-12">https://juejin.im/post/6844903667577929742#heading-12</a> </p><p> <a href="https://www.jianshu.com/p/cf8c2f2cd18a">https://www.jianshu.com/p/cf8c2f2cd18a</a> </p><p> <a href="https://www.cnblogs.com/zhuqil/archive/2012/10/06/ssl_detail.html">https://www.cnblogs.com/zhuqil/archive/2012/10/06/ssl_detail.html</a> </p><p> <a href="https://blog.csdn.net/mrpre/article/details/77868570">https://blog.csdn.net/mrpre/article/details/77868570</a> </p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
